package cv;
/**
 * JNA Wrapper for library <b>cv</b><br>
 * @see OpenCV.cv<br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a>, <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface CvLibrary extends com.sun.jna.Library {
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_CB_FILTER_QUADS = 4;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_CHAIN_APPROX_NONE = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvReleaseData
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_FAIR = 5;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_DOMINANT_IPAN = 1;
	/**
	 * define<br>
	 * Conversion Error : CV_GRAPH_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvtypes.h</i><br>
	 * CV_GRAPH_FIELDS()
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGRA2GRAY = 10;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_L12 = 4;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_ARRAY = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvConvertPointsHomogeneous
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_YCrCb2RGB = 39;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MOP_OPEN = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5652GRAY = 21;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_ADAPTIVE_THRESH_MEAN_C = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_TOZERO_INV = 4;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_CHAIN_APPROX_SIMPLE = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2BGR565 = 13;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_LMEDS
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_TM_SQDIFF = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_64FC1
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5552RGBA = 29;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2BGRA = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_DIST_MASK_5 = 5;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_DIST_MASK_3 = 3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BayerBG2BGR
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_STEREO_BM_FISH_EYE = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_LKFLOW_PYR_B_READY = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_IS_SET_ELEM
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_LMEDS
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_INTRINSIC = 256;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5552RGB = 25;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_RIGHT = 3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvSetMemoryManager
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_LINK_RUNS = 5;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvKalmanPredict
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2Lab = 44;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * SHRT_MAX
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2BGR555 = 23;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_XYZ2RGB = 35;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvSplit
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HOUGH_STANDARD = 0;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_L1 = 1;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_L2 = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2HLS = 52;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BGRA2BGR
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvMultiplyAcc
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvAcc
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MAX_SOBEL_KSIZE = 7;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2BGR565 = 12;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvGetPerspectiveTransform
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2BGR555 = 22;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvSquareAcc
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_HAAR = "opencv-haar-classifier";
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_64FC1
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvIntegral
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvMean
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_GRAY2BGR
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_FM_7POINT = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_64FC1
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_USER = -1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2HSV = 40;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HOUGH_GRADIENT = 3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvConvertPointsHomogeneous
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_TM_CCOEFF_NORMED = 5;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2RGBA = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_SHAPE_CROSS = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_INPAINT_TELEA = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvtypes.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HOUGH_PROBABILISTIC = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvGet2D
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_CHAIN_APPROX_TC89_KCOS = 4;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HAAR_FIND_BIGGEST_OBJECT = 4;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2HLS = 53;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BayerGB2BGR = 47;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_INTER_CUBIC = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_CB_NORMALIZE_IMAGE = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_TOZERO = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2RGB = 4;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BILATERAL = 4;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_RETR_CCOMP = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2YCrCb = 37;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HSV2BGR = 54;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_ZERO_DISPARITY = 1024;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2HSV = 41;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_32FC1
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_C = 3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvtypes.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5652BGR = 14;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CONTOUR_TREES_MATCH_I1 = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_GRAY2BGR555 = 30;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_INTER_LINEAR = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_CB_ADAPTIVE_THRESH = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_TM_CCORR_NORMED = 3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_RGBA2BGR
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvSetHistBinRanges
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BGRA2RGBA
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MEDIAN = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_VALUE = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvPseudoInverse
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvUpdateMotionHistory
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_SHAPE_CUSTOM = 100;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_RANSAC
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_COLORCVT_MAX = 100;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_HUBER = 7;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2Luv = 50;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5652RGB = 15;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_INTER_NN = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvConvertPointsHomogeneous
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BayerGR2BGR = 49;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_CHAIN_CODE = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_32FC1
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HAAR_SCALE_IMAGE = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_GRAY2BGR565 = 20;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5652BGRA = 18;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2Luv = 51;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvReleaseData
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_K3 = 128;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_K2 = 64;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_K1 = 32;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_HAAR_FEATURE_MAX = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BLUR_NO_SCALE = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HLS2RGB = 61;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int IPL_GAUSSIAN_5x5 = 7;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_STEREO_BM_NARROW = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_FLOODFILL_FIXED_RANGE = (1 << 16);
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_COMP_CHISQR = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BayerBG2BGR = 46;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_RANSAC
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_DIST_WELSCH = 6;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2Lab = 45;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvKalmanCorrect
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_32FC1
	 */
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_RODRIGUES_V2M = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGRA2BGR565 = 16;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BayerRG2BGR = 48;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MOP_CLOSE = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_YCrCb2BGR = 38;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_CHAIN_APPROX_TC89_L1 = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGRA2BGR555 = 26;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_USE_INTRINSIC_GUESS = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_ASPECT_RATIO = 2;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_LEFT = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvGetRawData
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_64FC1
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_TM_SQDIFF_NORMED = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvReleaseMat
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_XYZ2BGR = 34;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_LMEDS = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CvPoint3D64f
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_TM_CCORR = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_Lab2BGR = 56;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_PRINCIPAL_POINT = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CvPoint2D64f
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5552GRAY = 31;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5552BGRA = 28;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_FM_8POINT = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HAAR_DO_CANNY_PRUNING = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvSetData
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5652RGBA = 19;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BGR2RGBA
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_LKFLOW_PYR_A_READY = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_WARP_FILL_OUTLIERS = 8;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_COMP_INTERSECT = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR5552BGR = 24;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_TRUNC = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RANSAC = 8;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_COMP_CORREL = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_TM_CCOEFF = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvReleaseData
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_Luv2RGB = 59;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_NONE = 2;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_RODRIGUES_M2V = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_FIX_FOCAL_LENGTH = 16;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_GRAY2BGR = 8;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGRA2RGBA = 5;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_SHAPE_ELLIPSE = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_INTER_AREA = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_COMP_BHATTACHARYYA = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_Luv2BGR = 58;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CvMat
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MOP_TOPHAT = 5;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_BINARY = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CLOCKWISE = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_ADAPTIVE_THRESH_GAUSSIAN_C = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_BINARY_INV = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGBA2BGR = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_ZERO_TANGENT_DIST = 8;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CALIB_SAME_FOCAL_LENGTH = 512;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BGR2RGB
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_MASK = 7;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HSV2RGB = 55;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvMerge
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_SUBDIV2D_VIRTUAL_POINT_FLAG = (1 << 30);
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HLS2BGR = 60;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvCreateData
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_POLY_APPROX_DP = 0;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_HAAR_MAGIC_VAL = 1112539136;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_SCHARR = -1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * int
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2YCrCb = 36;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_LKFLOW_INITIAL_GUESSES = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvCreateData
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BGR2BGRA
	 */
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_RETR_TREE = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MOP_GRADIENT = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_64FC1
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2GRAY = 7;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_THRESH_OTSU = 8;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HOUGH_MULTI_SCALE = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvCreateData
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_GRAY2BGRA = 9;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_GRAY2BGRA
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_32FC1
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BayerGR2BGR
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvPtr2D
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_STEREO_BM_NORMALIZED_RESPONSE = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CvBox2D
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_MOP_BLACKHAT = 6;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_RD = 11;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BLUR = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_DIST_MASK_PRECISE = 0;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_RU = 7;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_GAUSSIAN = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGBA2GRAY = 11;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_HAAR_DO_ROUGH_SEARCH = 8;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * cvMatchShapes
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGBA2BGR565 = 17;
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_RETR_EXTERNAL = 0;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_DOWN = 10;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_UP = 6;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGRA2BGR = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CANNY_L2_GRADIENT = (1 << 31);
	/// <i>native declaration : cv\include\cvtypes.h</i>
	public static final int CV_RETR_LIST = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_WARP_INVERSE_MAP = 16;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGBA2BGR555 = 27;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BayerGB2BGR
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_LKFLOW_GET_MIN_EIGENVALS = 8;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cv.h</i><br>
	 * CV_BayerRG2BGR
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CONTOURS_MATCH_I3 = 3;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CONTOURS_MATCH_I1 = 1;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_CONTOURS_MATCH_I2 = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_COUNTER_CLOCKWISE = 2;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_SHAPE_RECT = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2GRAY = 6;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_BGR2XYZ = 32;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_INPAINT_NS = 0;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_FLOODFILL_MASK_ONLY = (1 << 17);
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cv\include\cvcompat.h</i><br>
	 * CV_32FC1
	 */
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_RGB2XYZ = 33;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_Lab2RGB = 57;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_LD = 9;
	/// <i>native declaration : cv\include\cvcompat.h</i>
	public static final int CV_SHIFT_LU = 5;
	/// <i>native declaration : cv\include\cv.h</i>
	public static final int CV_STEREO_BM_BASIC = 0;
	/**
	 * Copies source 2D array inside of the larger destination array and<br>
	 * makes a border of the specified type (IPL_BORDER_*) around the copied area.<br>
	 * Original signature : <code>void cvCopyMakeBorder(const CvArr*, CvArr*, CvPoint, int, CvScalar)</code><br>
	 * <i>native declaration : cv\include\cv.h:52</i>
	 */
	void cvCopyMakeBorder(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvPoint.ByValue offset, int bordertype, cxcore.CvScalar.ByValue value);
	/**
	 * Smoothes array (removes noise)<br>
	 * Original signature : <code>void cvSmooth(const CvArr*, CvArr*, int, int, int, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:62</i>
	 */
	void cvSmooth(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int smoothtype, int size1, int size2, double sigma1, double sigma2);
	/**
	 * Convolves the image with the kernel<br>
	 * Original signature : <code>void cvFilter2D(const CvArr*, CvArr*, const CvMat*, CvPoint)</code><br>
	 * <i>native declaration : cv\include\cv.h:70</i>
	 */
	void cvFilter2D(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat kernel, cxcore.CvPoint.ByValue anchor);
	/**
	 * Finds integral image: SUM(X,Y) = sum(x<X,y<Y)I(x,y)<br>
	 * Original signature : <code>void cvIntegral(const CvArr*, CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:74</i>
	 */
	void cvIntegral(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr sum, highgui.HighguiLibrary.CvArr sqsum, highgui.HighguiLibrary.CvArr tilted_sum);
	/**
	 * Smoothes the input image with gaussian kernel and then down-samples it.<br>
	 * dst_width = floor(src_width/2)[+1],<br>
	 * dst_height = floor(src_height/2)[+1]<br>
	 * Original signature : <code>void cvPyrDown(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:83</i>
	 */
	void cvPyrDown(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int filter);
	/**
	 * Up-samples image and smoothes the result with gaussian kernel.<br>
	 * dst_width = src_width*2,<br>
	 * dst_height = src_height*2<br>
	 * Original signature : <code>void cvPyrUp(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:91</i>
	 */
	void cvPyrUp(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int filter);
	/**
	 * Builds pyramid for an image<br>
	 * Original signature : <code>CvMat** cvCreatePyramid(const CvArr*, int, double, const CvSize*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:95</i>
	 */
	cxcore.CvMat.ByReference[] cvCreatePyramid(highgui.HighguiLibrary.CvArr img, int extra_layers, double rate, cxcore.CvSize layer_sizes, highgui.HighguiLibrary.CvArr bufarr, int calc, int filter);
	/**
	 * Releases pyramid<br>
	 * Original signature : <code>void cvReleasePyramid(CvMat***, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:102</i>
	 */
	void cvReleasePyramid(com.sun.jna.ptr.PointerByReference pyramid, int extra_layers);
	/**
	 * Splits color or grayscale image into multiple connected components<br>
	 * of nearly the same color/brightness using modification of Burt algorithm.<br>
	 * comp with contain a pointer to sequence (CvSeq)<br>
	 * of connected components (CvConnectedComp)<br>
	 * Original signature : <code>void cvPyrSegmentation(IplImage*, IplImage*, CvMemStorage*, CvSeq**, int, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:109</i>
	 */
	void cvPyrSegmentation(cxcore.IplImage src, cxcore.IplImage dst, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference comp[], int level, double threshold1, double threshold2);
	/**
	 * Filters image using meanshift algorithm<br>
	 * Original signature : <code>void cvPyrMeanShiftFiltering(const CvArr*, CvArr*, double, double, int, CvTermCriteria)</code><br>
	 * <i>native declaration : cv\include\cv.h:115</i>
	 */
	void cvPyrMeanShiftFiltering(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double sp, double sr, int max_level, cxcore.CvTermCriteria.ByValue termcrit);
	/**
	 * Segments image using seed "markers"<br>
	 * Original signature : <code>void cvWatershed(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:120</i>
	 */
	void cvWatershed(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr markers);
	/**
	 * Inpaints the selected region in the image<br>
	 * Original signature : <code>void cvInpaint(const CvArr*, const CvArr*, CvArr*, double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:126</i>
	 */
	void cvInpaint(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr inpaint_mask, highgui.HighguiLibrary.CvArr dst, double inpaintRange, int flags);
	/**
	 * Calculates an image derivative using generalized Sobel<br>
	 * (aperture_size = 1,3,5,7) or Scharr (aperture_size = -1) operator.<br>
	 * Scharr can be used only for the first dx or dy derivative<br>
	 * Original signature : <code>void cvSobel(const CvArr*, CvArr*, int, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:135</i>
	 */
	void cvSobel(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int xorder, int yorder, int aperture_size);
	/**
	 * Calculates the image Laplacian: (d2/dx + d2/dy)I<br>
	 * Original signature : <code>void cvLaplace(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:140</i>
	 */
	void cvLaplace(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int aperture_size);
	/**
	 * Converts input array pixels from one color space to another<br>
	 * Original signature : <code>void cvCvtColor(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:239</i>
	 */
	void cvCvtColor(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int code);
	/**
	 * Resizes image (input array is resized to fit the destination array)<br>
	 * Original signature : <code>void cvResize(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:250</i>
	 */
	void cvResize(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int interpolation);
	/**
	 * Warps image with affine transform<br>
	 * Original signature : <code>void cvWarpAffine(const CvArr*, CvArr*, const CvMat*, int, CvScalar)</code><br>
	 * <i>native declaration : cv\include\cv.h:254</i>
	 */
	void cvWarpAffine(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat map_matrix, int flags, cxcore.CvScalar.ByValue fillval);
	/**
	 * Computes affine transform matrix for mapping src[i] to dst[i] (i=0,1,2)<br>
	 * Original signature : <code>CvMat* cvGetAffineTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:259</i>
	 */
	cxcore.CvMat cvGetAffineTransform(cxcore.CvPoint2D32f src, cxcore.CvPoint2D32f dst, cxcore.CvMat map_matrix);
	/**
	 * Computes rotation_matrix matrix<br>
	 * Original signature : <code>CvMat* cv2DRotationMatrix(CvPoint2D32f, double, double, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:264</i>
	 */
	cxcore.CvMat cv2DRotationMatrix(cxcore.CvPoint2D32f.ByValue center, double angle, double scale, cxcore.CvMat map_matrix);
	/**
	 * Warps image with perspective (projective) transform<br>
	 * Original signature : <code>void cvWarpPerspective(const CvArr*, CvArr*, const CvMat*, int, CvScalar)</code><br>
	 * <i>native declaration : cv\include\cv.h:268</i>
	 */
	void cvWarpPerspective(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat map_matrix, int flags, cxcore.CvScalar.ByValue fillval);
	/**
	 * Computes perspective transform matrix for mapping src[i] to dst[i] (i=0,1,2,3)<br>
	 * Original signature : <code>CvMat* cvGetPerspectiveTransform(const CvPoint2D32f*, const CvPoint2D32f*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:273</i>
	 */
	cxcore.CvMat cvGetPerspectiveTransform(cxcore.CvPoint2D32f src, cxcore.CvPoint2D32f dst, cxcore.CvMat map_matrix);
	/**
	 * Performs generic geometric transformation using the specified coordinate maps<br>
	 * Original signature : <code>void cvRemap(const CvArr*, CvArr*, const CvArr*, const CvArr*, int, CvScalar)</code><br>
	 * <i>native declaration : cv\include\cv.h:278</i>
	 */
	void cvRemap(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mapx, highgui.HighguiLibrary.CvArr mapy, int flags, cxcore.CvScalar.ByValue fillval);
	/**
	 * Converts mapx & mapy from floating-point to integer formats for cvRemap<br>
	 * Original signature : <code>void cvConvertMaps(const CvArr*, const CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:284</i>
	 */
	void cvConvertMaps(highgui.HighguiLibrary.CvArr mapx, highgui.HighguiLibrary.CvArr mapy, highgui.HighguiLibrary.CvArr mapxy, highgui.HighguiLibrary.CvArr mapalpha);
	/**
	 * Performs forward or inverse log-polar image transform<br>
	 * Original signature : <code>void cvLogPolar(const CvArr*, CvArr*, CvPoint2D32f, double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:288</i>
	 */
	void cvLogPolar(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvPoint2D32f.ByValue center, double M, int flags);
	/**
	 * creates structuring element used for morphological operations<br>
	 * Original signature : <code>IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)</code><br>
	 * <i>native declaration : cv\include\cv.h:298</i><br>
	 * @deprecated use the safer method {@link #cvCreateStructuringElementEx(int, int, int, int, int, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	cxcore.IplConvKernel cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, com.sun.jna.ptr.IntByReference values);
	/**
	 * creates structuring element used for morphological operations<br>
	 * Original signature : <code>IplConvKernel* cvCreateStructuringElementEx(int, int, int, int, int, int*)</code><br>
	 * <i>native declaration : cv\include\cv.h:298</i>
	 */
	cxcore.IplConvKernel cvCreateStructuringElementEx(int cols, int rows, int anchor_x, int anchor_y, int shape, java.nio.IntBuffer values);
	/**
	 * releases structuring element<br>
	 * Original signature : <code>void cvReleaseStructuringElement(IplConvKernel**)</code><br>
	 * <i>native declaration : cv\include\cv.h:303</i>
	 */
	void cvReleaseStructuringElement(cxcore.IplConvKernel.ByReference element[]);
	/**
	 * erodes input image (applies minimum filter) one or more times.<br>
	 * If element pointer is NULL, 3x3 rectangular element is used<br>
	 * Original signature : <code>void cvErode(const CvArr*, CvArr*, IplConvKernel*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:307</i>
	 */
	void cvErode(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.IplConvKernel element, int iterations);
	/**
	 * dilates input image (applies maximum filter) one or more times.<br>
	 * If element pointer is NULL, 3x3 rectangular element is used<br>
	 * Original signature : <code>void cvDilate(const CvArr*, CvArr*, IplConvKernel*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:313</i>
	 */
	void cvDilate(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.IplConvKernel element, int iterations);
	/**
	 * Performs complex morphological transformation<br>
	 * Original signature : <code>void cvMorphologyEx(const CvArr*, CvArr*, CvArr*, IplConvKernel*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:324</i>
	 */
	void cvMorphologyEx(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr temp, cxcore.IplConvKernel element, int operation, int iterations);
	/**
	 * Calculates all spatial and central moments up to the 3rd order<br>
	 * Original signature : <code>void cvMoments(const CvArr*, CvMoments*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:329</i>
	 */
	void cvMoments(highgui.HighguiLibrary.CvArr arr, cv.CvMoments moments, int binary);
	/**
	 * Retrieve particular spatial, central or normalized central moments<br>
	 * Original signature : <code>double cvGetSpatialMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:332</i>
	 */
	double cvGetSpatialMoment(cv.CvMoments moments, int x_order, int y_order);
	/**
	 * Original signature : <code>double cvGetCentralMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:333</i>
	 */
	double cvGetCentralMoment(cv.CvMoments moments, int x_order, int y_order);
	/**
	 * Original signature : <code>double cvGetNormalizedCentralMoment(CvMoments*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:334</i>
	 */
	double cvGetNormalizedCentralMoment(cv.CvMoments moments, int x_order, int y_order);
	/**
	 * Calculates 7 Hu's invariants from precalculated spatial and central moments<br>
	 * Original signature : <code>void cvGetHuMoments(CvMoments*, CvHuMoments*)</code><br>
	 * <i>native declaration : cv\include\cv.h:338</i>
	 */
	void cvGetHuMoments(cv.CvMoments moments, cv.CvHuMoments hu_moments);
	/**
	 * Fetches pixels that belong to the specified line segment and stores them to the buffer.<br>
	 * Returns the number of retrieved points.<br>
	 * Original signature : <code>int cvSampleLine(const CvArr*, CvPoint, CvPoint, void*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:344</i>
	 */
	int cvSampleLine(highgui.HighguiLibrary.CvArr image, cxcore.CvPoint.ByValue pt1, cxcore.CvPoint.ByValue pt2, com.sun.jna.Pointer buffer, int connectivity);
	/**
	 * Retrieves the rectangular image region with specified center from the input array.<br>
	 * dst(x,y) <- src(x + center.x - dst_width/2, y + center.y - dst_height/2).<br>
	 * Values of pixels with fractional coordinates are retrieved using bilinear interpolation<br>
	 * Original signature : <code>void cvGetRectSubPix(const CvArr*, CvArr*, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv\include\cv.h:350</i>
	 */
	void cvGetRectSubPix(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvPoint2D32f.ByValue center);
	/**
	 * Retrieves quadrangle from the input array.<br>
	 * matrixarr = ( a11  a12 | b1 )   dst(x,y) <- src(A[x y]' + b)<br>
	 * ( a21  a22 | b2 )   (bilinear interpolation is used to retrieve pixels<br>
	 * with fractional coordinates)<br>
	 * Original signature : <code>void cvGetQuadrangleSubPix(const CvArr*, CvArr*, const CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:358</i>
	 */
	void cvGetQuadrangleSubPix(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat map_matrix);
	/**
	 * Measures similarity between template and overlapped windows in the source image<br>
	 * and fills the resultant image with the measurements<br>
	 * Original signature : <code>void cvMatchTemplate(const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:371</i>
	 */
	void cvMatchTemplate(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr templ, highgui.HighguiLibrary.CvArr result, int method);
	/**
	 * <i>native declaration : cv\include\cv.h:376</i><br>
	 * Conversion Error : CvDistanceFunction
	 */
	/**
	 * Retrieves outer and optionally inner boundaries of white (non-zero) connected<br>
	 * components in the black (zero) background<br>
	 * Original signature : <code>int cvFindContours(CvArr*, CvMemStorage*, CvSeq**, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : cv\include\cv.h:391</i>
	 */
	int cvFindContours(highgui.HighguiLibrary.CvArr image, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference first_contour[], int header_size, int mode, int method, cxcore.CvPoint.ByValue offset);
	/**
	 * Initalizes contour retrieving process.<br>
	 * Calls cvStartFindContours.<br>
	 * Calls cvFindNextContour until null pointer is returned<br>
	 * or some other condition becomes true.<br>
	 * Calls cvEndFindContours at the end.<br>
	 * Original signature : <code>CvContourScanner cvStartFindContours(CvArr*, CvMemStorage*, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : cv\include\cv.h:403</i>
	 */
	cv.CvLibrary._CvContourScanner cvStartFindContours(highgui.HighguiLibrary.CvArr image, cxcore.CvMemStorage storage, int header_size, int mode, int method, cxcore.CvPoint.ByValue offset);
	/**
	 * Retrieves next contour<br>
	 * Original signature : <code>CvSeq* cvFindNextContour(CvContourScanner)</code><br>
	 * <i>native declaration : cv\include\cv.h:410</i>
	 */
	cxcore.CvSeq cvFindNextContour(cv.CvLibrary._CvContourScanner scanner);
	/**
	 * Substitutes the last retrieved contour with the new one<br>
	 * (if the substitutor is null, the last retrieved contour is removed from the tree)<br>
	 * Original signature : <code>void cvSubstituteContour(CvContourScanner, CvSeq*)</code><br>
	 * <i>native declaration : cv\include\cv.h:415</i>
	 */
	void cvSubstituteContour(cv.CvLibrary._CvContourScanner scanner, cxcore.CvSeq new_contour);
	/**
	 * Releases contour scanner and returns pointer to the first outer contour<br>
	 * Original signature : <code>CvSeq* cvEndFindContours(CvContourScanner*)</code><br>
	 * <i>native declaration : cv\include\cv.h:419</i>
	 */
	cxcore.CvSeq cvEndFindContours(com.sun.jna.ptr.PointerByReference scanner);
	/**
	 * Approximates a single Freeman chain or a tree of chains to polygonal curves<br>
	 * Original signature : <code>CvSeq* cvApproxChains(CvSeq*, CvMemStorage*, int, double, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:422</i>
	 */
	cxcore.CvSeq cvApproxChains(cxcore.CvSeq src_seq, cxcore.CvMemStorage storage, int method, double parameter, int minimal_perimeter, int recursive);
	/**
	 * Initalizes Freeman chain reader.<br>
	 * The reader is used to iteratively get coordinates of all the chain points.<br>
	 * If the Freeman codes should be read as is, a simple sequence reader should be used<br>
	 * Original signature : <code>void cvStartReadChainPoints(CvChain*, CvChainPtReader*)</code><br>
	 * <i>native declaration : cv\include\cv.h:432</i>
	 */
	void cvStartReadChainPoints(cxcore.CvChain chain, cv.CvChainPtReader reader);
	/**
	 * Retrieves the next chain point<br>
	 * Original signature : <code>CvPoint cvReadChainPoint(CvChainPtReader*)</code><br>
	 * <i>native declaration : cv\include\cv.h:435</i>
	 */
	cxcore.CvPoint.ByValue cvReadChainPoint(cv.CvChainPtReader reader);
	/**
	 * Calculates optical flow for 2 images using classical Lucas & Kanade algorithm<br>
	 * Original signature : <code>void cvCalcOpticalFlowLK(const CvArr*, const CvArr*, CvSize, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:445</i>
	 */
	void cvCalcOpticalFlowLK(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, cxcore.CvSize.ByValue win_size, highgui.HighguiLibrary.CvArr velx, highgui.HighguiLibrary.CvArr vely);
	/**
	 * Calculates optical flow for 2 images using block matching algorithm<br>
	 * Original signature : <code>void cvCalcOpticalFlowBM(const CvArr*, const CvArr*, CvSize, CvSize, CvSize, int, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:449</i>
	 */
	void cvCalcOpticalFlowBM(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, cxcore.CvSize.ByValue block_size, cxcore.CvSize.ByValue shift_size, cxcore.CvSize.ByValue max_range, int use_previous, highgui.HighguiLibrary.CvArr velx, highgui.HighguiLibrary.CvArr vely);
	/**
	 * Calculates Optical flow for 2 images using Horn & Schunck algorithm<br>
	 * Original signature : <code>void cvCalcOpticalFlowHS(const CvArr*, const CvArr*, int, CvArr*, CvArr*, double, CvTermCriteria)</code><br>
	 * <i>native declaration : cv\include\cv.h:455</i>
	 */
	void cvCalcOpticalFlowHS(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, int use_previous, highgui.HighguiLibrary.CvArr velx, highgui.HighguiLibrary.CvArr vely, double lambda, cxcore.CvTermCriteria.ByValue criteria);
	/**
	 * It is Lucas & Kanade method, modified to use pyramids.<br>
	 * Also it does several iterations to get optical flow for<br>
	 * every point at every pyramid level.<br>
	 * Calculates optical flow between two images for certain set of points (i.e.<br>
	 * it is a "sparse" optical flow, which is opposite to the previous 3 methods)<br>
	 * Original signature : <code>void cvCalcOpticalFlowPyrLK(const CvArr*, const CvArr*, CvArr*, CvArr*, const CvPoint2D32f*, CvPoint2D32f*, int, CvSize, int, char*, float*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:469</i><br>
	 * @deprecated use the safer method {@link #cvCalcOpticalFlowPyrLK(highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, cxcore.CvPoint2D32f, cxcore.CvPoint2D32f, int, cxcore.CvSize.ByValue, int, java.nio.ByteBuffer, java.nio.FloatBuffer, cxcore.CvTermCriteria.ByValue, int)} instead
	 */
	@java.lang.Deprecated
	void cvCalcOpticalFlowPyrLK(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, highgui.HighguiLibrary.CvArr prev_pyr, highgui.HighguiLibrary.CvArr curr_pyr, cxcore.CvPoint2D32f prev_features, cxcore.CvPoint2D32f curr_features, int count, cxcore.CvSize.ByValue win_size, int level, com.sun.jna.ptr.ByteByReference status, com.sun.jna.ptr.FloatByReference track_error, cxcore.CvTermCriteria.ByValue criteria, int flags);
	/**
	 * It is Lucas & Kanade method, modified to use pyramids.<br>
	 * Also it does several iterations to get optical flow for<br>
	 * every point at every pyramid level.<br>
	 * Calculates optical flow between two images for certain set of points (i.e.<br>
	 * it is a "sparse" optical flow, which is opposite to the previous 3 methods)<br>
	 * Original signature : <code>void cvCalcOpticalFlowPyrLK(const CvArr*, const CvArr*, CvArr*, CvArr*, const CvPoint2D32f*, CvPoint2D32f*, int, CvSize, int, char*, float*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:469</i>
	 */
	void cvCalcOpticalFlowPyrLK(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, highgui.HighguiLibrary.CvArr prev_pyr, highgui.HighguiLibrary.CvArr curr_pyr, cxcore.CvPoint2D32f prev_features, cxcore.CvPoint2D32f curr_features, int count, cxcore.CvSize.ByValue win_size, int level, java.nio.ByteBuffer status, java.nio.FloatBuffer track_error, cxcore.CvTermCriteria.ByValue criteria, int flags);
	/**
	 * Modification of a previous sparse optical flow algorithm to calculate<br>
	 * affine flow<br>
	 * Original signature : <code>void cvCalcAffineFlowPyrLK(const CvArr*, const CvArr*, CvArr*, CvArr*, const CvPoint2D32f*, CvPoint2D32f*, float*, int, CvSize, int, char*, float*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:484</i><br>
	 * @deprecated use the safer method {@link #cvCalcAffineFlowPyrLK(highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, cxcore.CvPoint2D32f, cxcore.CvPoint2D32f, java.nio.FloatBuffer, int, cxcore.CvSize.ByValue, int, java.nio.ByteBuffer, java.nio.FloatBuffer, cxcore.CvTermCriteria.ByValue, int)} instead
	 */
	@java.lang.Deprecated
	void cvCalcAffineFlowPyrLK(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, highgui.HighguiLibrary.CvArr prev_pyr, highgui.HighguiLibrary.CvArr curr_pyr, cxcore.CvPoint2D32f prev_features, cxcore.CvPoint2D32f curr_features, com.sun.jna.ptr.FloatByReference matrices, int count, cxcore.CvSize.ByValue win_size, int level, com.sun.jna.ptr.ByteByReference status, com.sun.jna.ptr.FloatByReference track_error, cxcore.CvTermCriteria.ByValue criteria, int flags);
	/**
	 * Modification of a previous sparse optical flow algorithm to calculate<br>
	 * affine flow<br>
	 * Original signature : <code>void cvCalcAffineFlowPyrLK(const CvArr*, const CvArr*, CvArr*, CvArr*, const CvPoint2D32f*, CvPoint2D32f*, float*, int, CvSize, int, char*, float*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:484</i>
	 */
	void cvCalcAffineFlowPyrLK(highgui.HighguiLibrary.CvArr prev, highgui.HighguiLibrary.CvArr curr, highgui.HighguiLibrary.CvArr prev_pyr, highgui.HighguiLibrary.CvArr curr_pyr, cxcore.CvPoint2D32f prev_features, cxcore.CvPoint2D32f curr_features, java.nio.FloatBuffer matrices, int count, cxcore.CvSize.ByValue win_size, int level, java.nio.ByteBuffer status, java.nio.FloatBuffer track_error, cxcore.CvTermCriteria.ByValue criteria, int flags);
	/**
	 * Estimate rigid transformation between 2 images or 2 point sets<br>
	 * Original signature : <code>int cvEstimateRigidTransform(const CvArr*, const CvArr*, CvMat*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:494</i>
	 */
	int cvEstimateRigidTransform(highgui.HighguiLibrary.CvArr A, highgui.HighguiLibrary.CvArr B, cxcore.CvMat M, int full_affine);
	/**
	 * Updates motion history image given motion silhouette<br>
	 * Original signature : <code>void cvUpdateMotionHistory(const CvArr*, CvArr*, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:510</i>
	 */
	void cvUpdateMotionHistory(highgui.HighguiLibrary.CvArr silhouette, highgui.HighguiLibrary.CvArr mhi, double timestamp, double duration);
	/**
	 * Calculates gradient of the motion history image and fills<br>
	 * a mask indicating where the gradient is valid<br>
	 * Original signature : <code>void cvCalcMotionGradient(const CvArr*, CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:515</i>
	 */
	void cvCalcMotionGradient(highgui.HighguiLibrary.CvArr mhi, highgui.HighguiLibrary.CvArr mask, highgui.HighguiLibrary.CvArr orientation, double delta1, double delta2, int aperture_size);
	/**
	 * Calculates average motion direction within a selected motion region <br>
	 * (region can be selected by setting ROIs and/or by composing a valid gradient mask<br>
	 * with the region mask)<br>
	 * Original signature : <code>double cvCalcGlobalOrientation(const CvArr*, const CvArr*, const CvArr*, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:522</i>
	 */
	double cvCalcGlobalOrientation(highgui.HighguiLibrary.CvArr orientation, highgui.HighguiLibrary.CvArr mask, highgui.HighguiLibrary.CvArr mhi, double timestamp, double duration);
	/**
	 * Splits a motion history image into a few parts corresponding to separate independent motions<br>
	 * (e.g. left hand, right hand)<br>
	 * Original signature : <code>CvSeq* cvSegmentMotion(const CvArr*, CvArr*, CvMemStorage*, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:528</i>
	 */
	cxcore.CvSeq cvSegmentMotion(highgui.HighguiLibrary.CvArr mhi, highgui.HighguiLibrary.CvArr seg_mask, cxcore.CvMemStorage storage, double timestamp, double seg_thresh);
	/**
	 * Adds image to accumulator<br>
	 * Original signature : <code>void cvAcc(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:535</i>
	 */
	void cvAcc(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr sum, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Adds squared image to accumulator<br>
	 * Original signature : <code>void cvSquareAcc(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:539</i>
	 */
	void cvSquareAcc(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr sqsum, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Adds a product of two images to accumulator<br>
	 * Original signature : <code>void cvMultiplyAcc(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:543</i>
	 */
	void cvMultiplyAcc(highgui.HighguiLibrary.CvArr image1, highgui.HighguiLibrary.CvArr image2, highgui.HighguiLibrary.CvArr acc, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Adds image to accumulator with weights: acc = acc*(1-alpha) + image*alpha<br>
	 * Original signature : <code>void cvRunningAvg(const CvArr*, CvArr*, double, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:547</i>
	 */
	void cvRunningAvg(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr acc, double alpha, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Implements CAMSHIFT algorithm - determines object position, size and orientation<br>
	 * from the object histogram back project (extension of meanshift)<br>
	 * Original signature : <code>int cvCamShift(const CvArr*, CvRect, CvTermCriteria, CvConnectedComp*, CvBox2D*)</code><br>
	 * <i>native declaration : cv\include\cv.h:557</i>
	 */
	int cvCamShift(highgui.HighguiLibrary.CvArr prob_image, cxcore.CvRect.ByValue window, cxcore.CvTermCriteria.ByValue criteria, cv.CvConnectedComp comp, cxcore.CvBox2D box);
	/**
	 * Implements MeanShift algorithm - determines object position<br>
	 * from the object histogram back project<br>
	 * Original signature : <code>int cvMeanShift(const CvArr*, CvRect, CvTermCriteria, CvConnectedComp*)</code><br>
	 * <i>native declaration : cv\include\cv.h:563</i>
	 */
	int cvMeanShift(highgui.HighguiLibrary.CvArr prob_image, cxcore.CvRect.ByValue window, cxcore.CvTermCriteria.ByValue criteria, cv.CvConnectedComp comp);
	/**
	 * Creates ConDensation filter state<br>
	 * Original signature : <code>CvConDensation* cvCreateConDensation(int, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:567</i>
	 */
	cv.CvLibrary.CvConDensation cvCreateConDensation(int dynam_params, int measure_params, int sample_count);
	/**
	 * Releases ConDensation filter state<br>
	 * Original signature : <code>void cvReleaseConDensation(CvConDensation**)</code><br>
	 * <i>native declaration : cv\include\cv.h:572</i>
	 */
	void cvReleaseConDensation(com.sun.jna.ptr.PointerByReference condens);
	/**
	 * Updates ConDensation filter by time (predict future state of the system)<br>
	 * Original signature : <code>void cvConDensUpdateByTime(CvConDensation*)</code><br>
	 * <i>native declaration : cv\include\cv.h:575</i>
	 */
	void cvConDensUpdateByTime(cv.CvLibrary.CvConDensation condens);
	/**
	 * Initializes ConDensation filter samples<br>
	 * Original signature : <code>void cvConDensInitSampleSet(CvConDensation*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:578</i>
	 */
	void cvConDensInitSampleSet(cv.CvLibrary.CvConDensation condens, cxcore.CvMat lower_bound, cxcore.CvMat upper_bound);
	/**
	 * Creates Kalman filter and sets A, B, Q, R and state to some initial values<br>
	 * Original signature : <code>CvKalman* cvCreateKalman(int, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:581</i>
	 */
	cv.CvLibrary.CvKalman cvCreateKalman(int dynam_params, int measure_params, int control_params);
	/**
	 * Releases Kalman filter state<br>
	 * Original signature : <code>void cvReleaseKalman(CvKalman**)</code><br>
	 * <i>native declaration : cv\include\cv.h:585</i>
	 */
	void cvReleaseKalman(com.sun.jna.ptr.PointerByReference kalman);
	/**
	 * Updates Kalman filter by time (predicts future state of the system)<br>
	 * Original signature : <code>CvMat* cvKalmanPredict(CvKalman*, const CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:588</i>
	 */
	cxcore.CvMat cvKalmanPredict(cv.CvLibrary.CvKalman kalman, cxcore.CvMat control);
	/**
	 * Updates Kalman filter by measurement<br>
	 * (corrects state of the system and internal matrices)<br>
	 * Original signature : <code>CvMat* cvKalmanCorrect(CvKalman*, const CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:593</i>
	 */
	cxcore.CvMat cvKalmanCorrect(cv.CvLibrary.CvKalman kalman, cxcore.CvMat measurement);
	/**
	 * Initializes Delaunay triangulation<br>
	 * Original signature : <code>void cvInitSubdivDelaunay2D(CvSubdiv2D*, CvRect)</code><br>
	 * <i>native declaration : cv\include\cv.h:600</i>
	 */
	void cvInitSubdivDelaunay2D(cv.CvLibrary.CvSubdiv2D subdiv, cxcore.CvRect.ByValue rect);
	/**
	 * Creates new subdivision<br>
	 * Original signature : <code>CvSubdiv2D* cvCreateSubdiv2D(int, int, int, int, CvMemStorage*)</code><br>
	 * <i>native declaration : cv\include\cv.h:603</i>
	 */
	cv.CvLibrary.CvSubdiv2D cvCreateSubdiv2D(int subdiv_type, int header_size, int vtx_size, int quadedge_size, cxcore.CvMemStorage storage);
	/**
	 * Simplified Delaunay diagram creation<br>
	 * Original signature : <code>CvSubdiv2D* cvCreateSubdivDelaunay2D(CvRect, CvMemStorage*)</code><br>
	 * <i>native declaration : cv\include\cv.h:610</i>
	 */
	cv.CvLibrary.CvSubdiv2D cvCreateSubdivDelaunay2D(cxcore.CvRect.ByValue rect, cxcore.CvMemStorage storage);
	/**
	 * Inserts new point to the Delaunay triangulation<br>
	 * Original signature : <code>CvSubdiv2DPoint* cvSubdivDelaunay2DInsert(CvSubdiv2D*, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv\include\cv.h:621</i>
	 */
	cv.CvLibrary.CvSubdiv2DPoint cvSubdivDelaunay2DInsert(cv.CvLibrary.CvSubdiv2D subdiv, cxcore.CvPoint2D32f.ByValue pt);
	/**
	 * <i>native declaration : cv\include\cv.h:626</i><br>
	 * Conversion Error : CvSubdiv2DPointLocation
	 */
	/**
	 * Calculates Voronoi tesselation (i.e. coordinates of Voronoi points)<br>
	 * Original signature : <code>void cvCalcSubdivVoronoi2D(CvSubdiv2D*)</code><br>
	 * <i>native declaration : cv\include\cv.h:632</i>
	 */
	void cvCalcSubdivVoronoi2D(cv.CvLibrary.CvSubdiv2D subdiv);
	/**
	 * Removes all Voronoi points from the tesselation<br>
	 * Original signature : <code>void cvClearSubdivVoronoi2D(CvSubdiv2D*)</code><br>
	 * <i>native declaration : cv\include\cv.h:636</i>
	 */
	void cvClearSubdivVoronoi2D(cv.CvLibrary.CvSubdiv2D subdiv);
	/**
	 * Finds the nearest to the given point vertex in subdivision.<br>
	 * Original signature : <code>CvSubdiv2DPoint* cvFindNearestPoint2D(CvSubdiv2D*, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv\include\cv.h:640</i>
	 */
	cv.CvLibrary.CvSubdiv2DPoint cvFindNearestPoint2D(cv.CvLibrary.CvSubdiv2D subdiv, cxcore.CvPoint2D32f.ByValue pt);
	/**
	 * <i>native declaration : cv\include\cv.h:645</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv\include\cv.h:651</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv\include\cv.h:656</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv\include\cv.h:661</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv\include\cv.h:669</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * <i>native declaration : cv\include\cv.h:676</i><br>
	 * Conversion Error : CvSubdiv2DEdge
	 */
	/**
	 * Original signature : <code>double cvTriangleArea(CvPoint2D32f, CvPoint2D32f, CvPoint2D32f)</code><br>
	 * <i>native declaration : cv\include\cv.h:683</i>
	 */
	double cvTriangleArea(cxcore.CvPoint2D32f.ByValue a, cxcore.CvPoint2D32f.ByValue b, cxcore.CvPoint2D32f.ByValue c);
	/**
	 * Approximates a single polygonal curve (contour) or<br>
	 * a tree of polygonal curves (contours)<br>
	 * Original signature : <code>CvSeq* cvApproxPoly(const void*, int, CvMemStorage*, int, double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:697</i>
	 */
	cxcore.CvSeq cvApproxPoly(com.sun.jna.Pointer src_seq, int header_size, cxcore.CvMemStorage storage, int method, double parameter, int parameter2);
	/**
	 * Finds high-curvature points of the contour<br>
	 * Original signature : <code>CvSeq* cvFindDominantPoints(CvSeq*, CvMemStorage*, int, double, double, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:705</i>
	 */
	cxcore.CvSeq cvFindDominantPoints(cxcore.CvSeq contour, cxcore.CvMemStorage storage, int method, double parameter1, double parameter2, double parameter3, double parameter4);
	/**
	 * Calculates perimeter of a contour or length of a part of contour<br>
	 * Original signature : <code>double cvArcLength(const void*, CvSlice, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:713</i>
	 */
	double cvArcLength(com.sun.jna.Pointer curve, cxcore.CvSlice.ByValue slice, int is_closed);
	/**
	 * Calculates contour boundning rectangle (update=1) or<br>
	 * just retrieves pre-calculated rectangle (update=0)<br>
	 * Original signature : <code>CvRect cvBoundingRect(CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:720</i>
	 */
	cxcore.CvRect.ByValue cvBoundingRect(highgui.HighguiLibrary.CvArr points, int update);
	/**
	 * Calculates area of a contour or contour segment<br>
	 * Original signature : <code>double cvContourArea(const CvArr*, CvSlice)</code><br>
	 * <i>native declaration : cv\include\cv.h:723</i>
	 */
	double cvContourArea(highgui.HighguiLibrary.CvArr contour, cxcore.CvSlice.ByValue slice);
	/**
	 * Finds minimum area rotated rectangle bounding a set of points<br>
	 * Original signature : <code>CvBox2D cvMinAreaRect2(const CvArr*, CvMemStorage*)</code><br>
	 * <i>native declaration : cv\include\cv.h:727</i>
	 */
	cxcore.CvBox2D.ByValue cvMinAreaRect2(highgui.HighguiLibrary.CvArr points, cxcore.CvMemStorage storage);
	/**
	 * Finds minimum enclosing circle for a set of points<br>
	 * Original signature : <code>int cvMinEnclosingCircle(const CvArr*, CvPoint2D32f*, float*)</code><br>
	 * <i>native declaration : cv\include\cv.h:731</i><br>
	 * @deprecated use the safer method {@link #cvMinEnclosingCircle(highgui.HighguiLibrary.CvArr, cxcore.CvPoint2D32f, java.nio.FloatBuffer)} instead
	 */
	@java.lang.Deprecated
	int cvMinEnclosingCircle(highgui.HighguiLibrary.CvArr points, cxcore.CvPoint2D32f center, com.sun.jna.ptr.FloatByReference radius);
	/**
	 * Finds minimum enclosing circle for a set of points<br>
	 * Original signature : <code>int cvMinEnclosingCircle(const CvArr*, CvPoint2D32f*, float*)</code><br>
	 * <i>native declaration : cv\include\cv.h:731</i>
	 */
	int cvMinEnclosingCircle(highgui.HighguiLibrary.CvArr points, cxcore.CvPoint2D32f center, java.nio.FloatBuffer radius);
	/**
	 * Compares two contours by matching their moments<br>
	 * Original signature : <code>double cvMatchShapes(const void*, const void*, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:739</i>
	 */
	double cvMatchShapes(com.sun.jna.Pointer object1, com.sun.jna.Pointer object2, int method, double parameter);
	/**
	 * Builds hierarhical representation of a contour<br>
	 * Original signature : <code>CvContourTree* cvCreateContourTree(const CvSeq*, CvMemStorage*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:743</i>
	 */
	cv.CvLibrary.CvContourTree cvCreateContourTree(cxcore.CvSeq contour, cxcore.CvMemStorage storage, double threshold);
	/**
	 * Reconstruct (completelly or partially) contour a from contour tree<br>
	 * Original signature : <code>CvSeq* cvContourFromContourTree(const CvContourTree*, CvMemStorage*, CvTermCriteria)</code><br>
	 * <i>native declaration : cv\include\cv.h:748</i>
	 */
	cxcore.CvSeq cvContourFromContourTree(cv.CvLibrary.CvContourTree tree, cxcore.CvMemStorage storage, cxcore.CvTermCriteria.ByValue criteria);
	/**
	 * Original signature : <code>double cvMatchContourTrees(const CvContourTree*, const CvContourTree*, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:755</i>
	 */
	double cvMatchContourTrees(cv.CvLibrary.CvContourTree tree1, cv.CvLibrary.CvContourTree tree2, int method, double threshold);
	/**
	 * Calculates histogram of a contour<br>
	 * Original signature : <code>void cvCalcPGH(const CvSeq*, CvHistogram*)</code><br>
	 * <i>native declaration : cv\include\cv.h:760</i>
	 */
	void cvCalcPGH(cxcore.CvSeq contour, cxcore.CvHistogram hist);
	/**
	 * Calculates exact convex hull of 2d point set<br>
	 * Original signature : <code>CvSeq* cvConvexHull2(const CvArr*, void*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:766</i>
	 */
	cxcore.CvSeq cvConvexHull2(highgui.HighguiLibrary.CvArr input, com.sun.jna.Pointer hull_storage, int orientation, int return_points);
	/**
	 * Checks whether the contour is convex or not (returns 1 if convex, 0 if not)<br>
	 * Original signature : <code>int cvCheckContourConvexity(const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:772</i>
	 */
	int cvCheckContourConvexity(highgui.HighguiLibrary.CvArr contour);
	/**
	 * Finds convexity defects for the contour<br>
	 * Original signature : <code>CvSeq* cvConvexityDefects(const CvArr*, const CvArr*, CvMemStorage*)</code><br>
	 * <i>native declaration : cv\include\cv.h:775</i>
	 */
	cxcore.CvSeq cvConvexityDefects(highgui.HighguiLibrary.CvArr contour, highgui.HighguiLibrary.CvArr convexhull, cxcore.CvMemStorage storage);
	/**
	 * Fits ellipse into a set of 2d points<br>
	 * Original signature : <code>CvBox2D cvFitEllipse2(const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:779</i>
	 */
	cxcore.CvBox2D.ByValue cvFitEllipse2(highgui.HighguiLibrary.CvArr points);
	/**
	 * Finds minimum rectangle containing two given rectangles<br>
	 * Original signature : <code>CvRect cvMaxRect(const CvRect*, const CvRect*)</code><br>
	 * <i>native declaration : cv\include\cv.h:782</i>
	 */
	cxcore.CvRect.ByValue cvMaxRect(cxcore.CvRect rect1, cxcore.CvRect rect2);
	/**
	 * Finds coordinates of the box vertices<br>
	 * Original signature : <code>void cvBoxPoints(CvBox2D, CvPoint2D32f[4])</code><br>
	 * <i>native declaration : cv\include\cv.h:785</i><br>
	 * @deprecated use the safer method {@link #cvBoxPoints(cxcore.CvBox2D.ByValue, cxcore.CvPoint2D32f[])} instead
	 */
	@java.lang.Deprecated
	void cvBoxPoints(cxcore.CvBox2D.ByValue box, com.sun.jna.Pointer pt);
	/**
	 * Finds coordinates of the box vertices<br>
	 * Original signature : <code>void cvBoxPoints(CvBox2D, CvPoint2D32f[4])</code><br>
	 * <i>native declaration : cv\include\cv.h:785</i>
	 */
	void cvBoxPoints(cxcore.CvBox2D.ByValue box, cxcore.CvPoint2D32f pt[]);
	/**
	 * Initializes sequence header for a matrix (column or row vector) of points -<br>
	 * a wrapper for cvMakeSeqHeaderForArray (it does not initialize bounding rectangle!!!)<br>
	 * Original signature : <code>CvSeq* cvPointSeqFromMat(int, const CvArr*, CvContour*, CvSeqBlock*)</code><br>
	 * <i>native declaration : cv\include\cv.h:789</i>
	 */
	cxcore.CvSeq cvPointSeqFromMat(int seq_kind, highgui.HighguiLibrary.CvArr mat, cxcore.CvContour contour_header, cxcore.CvSeqBlock block);
	/**
	 * Checks whether the point is inside polygon, outside, on an edge (at a vertex).<br>
	 * Returns positive, negative or zero value, correspondingly.<br>
	 * Optionally, measures a signed distance between<br>
	 * the point and the nearest polygon edge (measure_dist=1)<br>
	 * Original signature : <code>double cvPointPolygonTest(const CvArr*, CvPoint2D32f, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:797</i>
	 */
	double cvPointPolygonTest(highgui.HighguiLibrary.CvArr contour, cxcore.CvPoint2D32f.ByValue pt, int measure_dist);
	/**
	 * Creates new histogram<br>
	 * Original signature : <code>CvHistogram* cvCreateHist(int, int*, int, float**, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:805</i><br>
	 * @deprecated use the safer method {@link #cvCreateHist(int, java.nio.IntBuffer, int, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvHistogram cvCreateHist(int dims, com.sun.jna.ptr.IntByReference sizes, int type, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Creates new histogram<br>
	 * Original signature : <code>CvHistogram* cvCreateHist(int, int*, int, float**, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:805</i>
	 */
	cxcore.CvHistogram cvCreateHist(int dims, java.nio.IntBuffer sizes, int type, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Assignes histogram bin ranges<br>
	 * Original signature : <code>void cvSetHistBinRanges(CvHistogram*, float**, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:810</i>
	 */
	void cvSetHistBinRanges(cxcore.CvHistogram hist, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Creates histogram header for array<br>
	 * Original signature : <code>CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:814</i><br>
	 * @deprecated use the safer method {@link #cvMakeHistHeaderForArray(int, java.nio.IntBuffer, cxcore.CvHistogram, java.nio.FloatBuffer, com.sun.jna.ptr.PointerByReference, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvHistogram cvMakeHistHeaderForArray(int dims, com.sun.jna.ptr.IntByReference sizes, cxcore.CvHistogram hist, com.sun.jna.ptr.FloatByReference data, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Creates histogram header for array<br>
	 * Original signature : <code>CvHistogram* cvMakeHistHeaderForArray(int, int*, CvHistogram*, float*, float**, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:814</i>
	 */
	cxcore.CvHistogram cvMakeHistHeaderForArray(int dims, java.nio.IntBuffer sizes, cxcore.CvHistogram hist, java.nio.FloatBuffer data, com.sun.jna.ptr.PointerByReference ranges, int uniform);
	/**
	 * Releases histogram<br>
	 * Original signature : <code>void cvReleaseHist(CvHistogram**)</code><br>
	 * <i>native declaration : cv\include\cv.h:820</i>
	 */
	void cvReleaseHist(cxcore.CvHistogram.ByReference hist[]);
	/**
	 * Clears all the histogram bins<br>
	 * Original signature : <code>void cvClearHist(CvHistogram*)</code><br>
	 * <i>native declaration : cv\include\cv.h:823</i>
	 */
	void cvClearHist(cxcore.CvHistogram hist);
	/**
	 * Finds indices and values of minimum and maximum histogram bins<br>
	 * Original signature : <code>void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)</code><br>
	 * <i>native declaration : cv\include\cv.h:826</i><br>
	 * @deprecated use the safer method {@link #cvGetMinMaxHistValue(cxcore.CvHistogram, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvGetMinMaxHistValue(cxcore.CvHistogram hist, com.sun.jna.ptr.FloatByReference min_value, com.sun.jna.ptr.FloatByReference max_value, com.sun.jna.ptr.IntByReference min_idx, com.sun.jna.ptr.IntByReference max_idx);
	/**
	 * Finds indices and values of minimum and maximum histogram bins<br>
	 * Original signature : <code>void cvGetMinMaxHistValue(const CvHistogram*, float*, float*, int*, int*)</code><br>
	 * <i>native declaration : cv\include\cv.h:826</i>
	 */
	void cvGetMinMaxHistValue(cxcore.CvHistogram hist, java.nio.FloatBuffer min_value, java.nio.FloatBuffer max_value, java.nio.IntBuffer min_idx, java.nio.IntBuffer max_idx);
	/**
	 * Normalizes histogram by dividing all bins by sum of the bins, multiplied by <factor>.<br>
	 * After that sum of histogram bins is equal to <factor><br>
	 * Original signature : <code>void cvNormalizeHist(CvHistogram*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:834</i>
	 */
	void cvNormalizeHist(cxcore.CvHistogram hist, double factor);
	/**
	 * Clear all histogram bins that are below the threshold<br>
	 * Original signature : <code>void cvThreshHist(CvHistogram*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:838</i>
	 */
	void cvThreshHist(cxcore.CvHistogram hist, double threshold);
	/**
	 * Compares two histogram<br>
	 * Original signature : <code>double cvCompareHist(const CvHistogram*, const CvHistogram*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:846</i>
	 */
	double cvCompareHist(cxcore.CvHistogram hist1, cxcore.CvHistogram hist2, int method);
	/**
	 * Copies one histogram to another. Destination histogram is created if<br>
	 * the destination pointer is NULL<br>
	 * Original signature : <code>void cvCopyHist(const CvHistogram*, CvHistogram**)</code><br>
	 * <i>native declaration : cv\include\cv.h:852</i>
	 */
	void cvCopyHist(cxcore.CvHistogram src, cxcore.CvHistogram.ByReference dst[]);
	/**
	 * Calculates bayesian probabilistic histograms<br>
	 * (each or src and dst is an array of <number> histograms<br>
	 * Original signature : <code>void cvCalcBayesianProb(CvHistogram**, int, CvHistogram**)</code><br>
	 * <i>native declaration : cv\include\cv.h:857</i>
	 */
	void cvCalcBayesianProb(cxcore.CvHistogram.ByReference src[], int number, cxcore.CvHistogram.ByReference dst[]);
	/**
	 * Calculates array histogram<br>
	 * Original signature : <code>void cvCalcArrHist(CvArr**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:861</i>
	 */
	void cvCalcArrHist(com.sun.jna.ptr.PointerByReference arr, cxcore.CvHistogram hist, int accumulate, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvCalcHist(IplImage**, CvHistogram*, int, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:865</i>
	 */
	void cvCalcHist(cxcore.IplImage.ByReference image[], cxcore.CvHistogram hist, int accumulate, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Calculates back project<br>
	 * Original signature : <code>void cvCalcArrBackProject(CvArr**, CvArr*, const CvHistogram*)</code><br>
	 * <i>native declaration : cv\include\cv.h:873</i>
	 */
	void cvCalcArrBackProject(com.sun.jna.ptr.PointerByReference image, highgui.HighguiLibrary.CvArr dst, cxcore.CvHistogram hist);
	/**
	 * Does some sort of template matching but compares histograms of<br>
	 * template and each window location<br>
	 * Original signature : <code>void cvCalcArrBackProjectPatch(CvArr**, CvArr*, CvSize, CvHistogram*, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:880</i>
	 */
	void cvCalcArrBackProjectPatch(com.sun.jna.ptr.PointerByReference image, highgui.HighguiLibrary.CvArr dst, cxcore.CvSize.ByValue range, cxcore.CvHistogram hist, int method, double factor);
	/**
	 * calculates probabilistic density (divides one histogram by another)<br>
	 * Original signature : <code>void cvCalcProbDensity(const CvHistogram*, const CvHistogram*, CvHistogram*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:888</i>
	 */
	void cvCalcProbDensity(cxcore.CvHistogram hist1, cxcore.CvHistogram hist2, cxcore.CvHistogram dst_hist, double scale);
	/**
	 * equalizes histogram of 8-bit single-channel image<br>
	 * Original signature : <code>void cvEqualizeHist(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:892</i>
	 */
	void cvEqualizeHist(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Updates active contour in order to minimize its cummulative<br>
	 * (internal and external) energy.<br>
	 * Original signature : <code>void cvSnakeImage(const IplImage*, CvPoint*, int, float*, float*, float*, int, CvSize, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:899</i><br>
	 * @deprecated use the safer method {@link #cvSnakeImage(cxcore.IplImage, cxcore.CvPoint, int, java.nio.FloatBuffer, java.nio.FloatBuffer, java.nio.FloatBuffer, int, cxcore.CvSize.ByValue, cxcore.CvTermCriteria.ByValue, int)} instead
	 */
	@java.lang.Deprecated
	void cvSnakeImage(cxcore.IplImage image, cxcore.CvPoint points, int length, com.sun.jna.ptr.FloatByReference alpha, com.sun.jna.ptr.FloatByReference beta, com.sun.jna.ptr.FloatByReference gamma, int coeff_usage, cxcore.CvSize.ByValue win, cxcore.CvTermCriteria.ByValue criteria, int calc_gradient);
	/**
	 * Updates active contour in order to minimize its cummulative<br>
	 * (internal and external) energy.<br>
	 * Original signature : <code>void cvSnakeImage(const IplImage*, CvPoint*, int, float*, float*, float*, int, CvSize, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:899</i>
	 */
	void cvSnakeImage(cxcore.IplImage image, cxcore.CvPoint points, int length, java.nio.FloatBuffer alpha, java.nio.FloatBuffer beta, java.nio.FloatBuffer gamma, int coeff_usage, cxcore.CvSize.ByValue win, cxcore.CvTermCriteria.ByValue criteria, int calc_gradient);
	/**
	 * Calculates the cooficients of the homography matrix<br>
	 * Original signature : <code>void cvCalcImageHomography(float*, CvPoint3D32f*, float*, float*)</code><br>
	 * <i>native declaration : cv\include\cv.h:906</i><br>
	 * @deprecated use the safer method {@link #cvCalcImageHomography(java.nio.FloatBuffer, cxcore.CvPoint3D32f, java.nio.FloatBuffer, java.nio.FloatBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvCalcImageHomography(com.sun.jna.ptr.FloatByReference line, cxcore.CvPoint3D32f center, com.sun.jna.ptr.FloatByReference intrinsic, com.sun.jna.ptr.FloatByReference homography);
	/**
	 * Calculates the cooficients of the homography matrix<br>
	 * Original signature : <code>void cvCalcImageHomography(float*, CvPoint3D32f*, float*, float*)</code><br>
	 * <i>native declaration : cv\include\cv.h:906</i>
	 */
	void cvCalcImageHomography(java.nio.FloatBuffer line, cxcore.CvPoint3D32f center, java.nio.FloatBuffer intrinsic, java.nio.FloatBuffer homography);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:914</i><br>
	 * @deprecated use the safer methods {@link #cvDistTransform(highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, int, int, float[], highgui.HighguiLibrary.CvArr)} and {@link #cvDistTransform(highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, int, int, java.nio.FloatBuffer, highgui.HighguiLibrary.CvArr)} instead
	 */
	@java.lang.Deprecated
	void cvDistTransform(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int distance_type, int mask_size, com.sun.jna.ptr.FloatByReference mask, highgui.HighguiLibrary.CvArr labels);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:914</i>
	 */
	void cvDistTransform(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int distance_type, int mask_size, float mask[], highgui.HighguiLibrary.CvArr labels);
	/**
	 * Applies distance transform to binary image<br>
	 * Original signature : <code>void cvDistTransform(const CvArr*, CvArr*, int, int, const float*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:914</i>
	 */
	void cvDistTransform(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int distance_type, int mask_size, java.nio.FloatBuffer mask, highgui.HighguiLibrary.CvArr labels);
	/**
	 * Applies fixed-level threshold to grayscale image.<br>
	 * This is a basic operation applied before retrieving contours<br>
	 * Original signature : <code>double cvThreshold(const CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:933</i>
	 */
	double cvThreshold(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double threshold, double max_value, int threshold_type);
	/**
	 * Applies adaptive threshold to grayscale image.<br>
	 * The two parameters for methods CV_ADAPTIVE_THRESH_MEAN_C and<br>
	 * CV_ADAPTIVE_THRESH_GAUSSIAN_C are:<br>
	 * neighborhood size (3, 5, 7 etc.),<br>
	 * and a constant subtracted from mean (...,-3,-2,-1,0,1,2,3,...)<br>
	 * Original signature : <code>void cvAdaptiveThreshold(const CvArr*, CvArr*, double, int, int, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:945</i>
	 */
	void cvAdaptiveThreshold(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double max_value, int adaptive_method, int threshold_type, int block_size, double param1);
	/**
	 * Fills the connected component until the color difference gets large enough<br>
	 * Original signature : <code>void cvFloodFill(CvArr*, CvPoint, CvScalar, CvScalar, CvScalar, CvConnectedComp*, int, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:955</i>
	 */
	void cvFloodFill(highgui.HighguiLibrary.CvArr image, cxcore.CvPoint.ByValue seed_point, cxcore.CvScalar.ByValue new_val, cxcore.CvScalar.ByValue lo_diff, cxcore.CvScalar.ByValue up_diff, cv.CvConnectedComp comp, int flags, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Runs canny edge detector<br>
	 * Original signature : <code>void cvCanny(const CvArr*, CvArr*, double, double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:969</i>
	 */
	void cvCanny(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr edges, double threshold1, double threshold2, int aperture_size);
	/**
	 * Calculates constraint image for corner detection<br>
	 * Dx^2 * Dyy + Dxx * Dy^2 - 2 * Dx * Dy * Dxy.<br>
	 * Applying threshold to the result gives coordinates of corners<br>
	 * Original signature : <code>void cvPreCornerDetect(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:975</i>
	 */
	void cvPreCornerDetect(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr corners, int aperture_size);
	/**
	 * Calculates eigen values and vectors of 2x2<br>
	 * gradient covariation matrix at every image pixel<br>
	 * Original signature : <code>void cvCornerEigenValsAndVecs(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:980</i>
	 */
	void cvCornerEigenValsAndVecs(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr eigenvv, int block_size, int aperture_size);
	/**
	 * Calculates minimal eigenvalue for 2x2 gradient covariation matrix at<br>
	 * every image pixel<br>
	 * Original signature : <code>void cvCornerMinEigenVal(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:985</i>
	 */
	void cvCornerMinEigenVal(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr eigenval, int block_size, int aperture_size);
	/**
	 * Harris corner detector:<br>
	 * Calculates det(M) - k*(trace(M)^2), where M is 2x2 gradient covariation matrix for each pixel<br>
	 * Original signature : <code>void cvCornerHarris(const CvArr*, CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:990</i>
	 */
	void cvCornerHarris(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr harris_responce, int block_size, int aperture_size, double k);
	/**
	 * Adjust corner position using some sort of gradient search<br>
	 * Original signature : <code>void cvFindCornerSubPix(const CvArr*, CvPoint2D32f*, int, CvSize, CvSize, CvTermCriteria)</code><br>
	 * <i>native declaration : cv\include\cv.h:995</i>
	 */
	void cvFindCornerSubPix(highgui.HighguiLibrary.CvArr image, cxcore.CvPoint2D32f corners, int count, cxcore.CvSize.ByValue win, cxcore.CvSize.ByValue zero_zone, cxcore.CvTermCriteria.ByValue criteria);
	/**
	 * Finds a sparse set of points within the selected region<br>
	 * that seem to be easy to track<br>
	 * Original signature : <code>void cvGoodFeaturesToTrack(const CvArr*, CvArr*, CvArr*, CvPoint2D32f*, int*, double, double, const CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1001</i><br>
	 * @deprecated use the safer method {@link #cvGoodFeaturesToTrack(highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr, cxcore.CvPoint2D32f, java.nio.IntBuffer, double, double, highgui.HighguiLibrary.CvArr, int, int, double)} instead
	 */
	@java.lang.Deprecated
	void cvGoodFeaturesToTrack(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr eig_image, highgui.HighguiLibrary.CvArr temp_image, cxcore.CvPoint2D32f corners, com.sun.jna.ptr.IntByReference corner_count, double quality_level, double min_distance, highgui.HighguiLibrary.CvArr mask, int block_size, int use_harris, double k);
	/**
	 * Finds a sparse set of points within the selected region<br>
	 * that seem to be easy to track<br>
	 * Original signature : <code>void cvGoodFeaturesToTrack(const CvArr*, CvArr*, CvArr*, CvPoint2D32f*, int*, double, double, const CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1001</i>
	 */
	void cvGoodFeaturesToTrack(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr eig_image, highgui.HighguiLibrary.CvArr temp_image, cxcore.CvPoint2D32f corners, java.nio.IntBuffer corner_count, double quality_level, double min_distance, highgui.HighguiLibrary.CvArr mask, int block_size, int use_harris, double k);
	/**
	 * Finds lines on binary image using one of several methods.<br>
	 * line_storage is either memory storage or 1 x <max number of lines> CvMat, its<br>
	 * number of columns is changed by the function.<br>
	 * method is one of CV_HOUGH_*;<br>
	 * rho, theta and threshold are used for each of those methods;<br>
	 * param1 ~ line length, param2 ~ line gap - for probabilistic,<br>
	 * param1 ~ srn, param2 ~ stn - for multi-scale<br>
	 * Original signature : <code>CvSeq* cvHoughLines2(CvArr*, void*, int, double, double, int, double, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1022</i>
	 */
	cxcore.CvSeq cvHoughLines2(highgui.HighguiLibrary.CvArr image, com.sun.jna.Pointer line_storage, int method, double rho, double theta, int threshold, double param1, double param2);
	/**
	 * Finds circles in the image<br>
	 * Original signature : <code>CvSeq* cvHoughCircles(CvArr*, void*, int, double, double, double, double, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1027</i>
	 */
	cxcore.CvSeq cvHoughCircles(highgui.HighguiLibrary.CvArr image, com.sun.jna.Pointer circle_storage, int method, double dp, double min_dist, double param1, double param2, int min_radius, int max_radius);
	/**
	 * Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)<br>
	 * Original signature : <code>void cvFitLine(const CvArr*, int, double, double, double, float*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1035</i><br>
	 * @deprecated use the safer method {@link #cvFitLine(highgui.HighguiLibrary.CvArr, int, double, double, double, java.nio.FloatBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvFitLine(highgui.HighguiLibrary.CvArr points, int dist_type, double param, double reps, double aeps, com.sun.jna.ptr.FloatByReference line);
	/**
	 * Fits a line into set of 2d or 3d points in a robust way (M-estimator technique)<br>
	 * Original signature : <code>void cvFitLine(const CvArr*, int, double, double, double, float*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1035</i>
	 */
	void cvFitLine(highgui.HighguiLibrary.CvArr points, int dist_type, double param, double reps, double aeps, java.nio.FloatBuffer line);
	/**
	 * Constructs kd-tree from set of feature descriptors<br>
	 * Original signature : <code>CvFeatureTree* cvCreateFeatureTree(CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1043</i>
	 */
	cv.CvLibrary.CvFeatureTree cvCreateFeatureTree(cxcore.CvMat desc);
	/**
	 * Release kd-tree<br>
	 * Original signature : <code>void cvReleaseFeatureTree(CvFeatureTree*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1046</i>
	 */
	void cvReleaseFeatureTree(cv.CvLibrary.CvFeatureTree tr);
	/**
	 * Searches kd-tree for k nearest neighbors of given reference points,<br>
	 * searching at most emax leaves.<br>
	 * Original signature : <code>void cvFindFeatures(CvFeatureTree*, CvMat*, CvMat*, CvMat*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1050</i>
	 */
	void cvFindFeatures(cv.CvLibrary.CvFeatureTree tr, cxcore.CvMat desc, cxcore.CvMat results, cxcore.CvMat dist, int k, int emax);
	/**
	 * Search kd-tree for all points that are inlier to given rect region.<br>
	 * Original signature : <code>int cvFindFeaturesBoxed(CvFeatureTree*, CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1054</i>
	 */
	int cvFindFeaturesBoxed(cv.CvLibrary.CvFeatureTree tr, cxcore.CvMat bounds_min, cxcore.CvMat bounds_max, cxcore.CvMat results);
	/**
	 * Original signature : <code>CvSURFPoint cvSURFPoint(CvPoint2D32f, int, int, float, float)</code><br>
	 * <i>native declaration : cv\include\cv.h:1067</i>
	 */
	cv.CvSURFPoint.ByValue cvSURFPoint(cxcore.CvPoint2D32f.ByValue pt, int laplacian, int size, float dir, float hessian);
	/**
	 * Original signature : <code>CvSURFParams cvSURFParams(double, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1090</i>
	 */
	cv.CvSURFParams.ByValue cvSURFParams(double hessianThreshold, int extended);
	/**
	 * Original signature : <code>void cvExtractSURF(const CvArr*, const CvArr*, CvSeq**, CvSeq**, CvMemStorage*, CvSURFParams)</code><br>
	 * <i>native declaration : cv\include\cv.h:1091</i>
	 */
	void cvExtractSURF(highgui.HighguiLibrary.CvArr img, highgui.HighguiLibrary.CvArr mask, cxcore.CvSeq.ByReference keypoints[], cxcore.CvSeq.ByReference descriptors[], cxcore.CvMemStorage storage, cv.CvSURFParams.ByValue params);
	/**
	 * Loads haar classifier cascade from a directory.<br>
	 * It is obsolete: convert your cascade to xml and use cvLoad instead<br>
	 * Original signature : <code>CvHaarClassifierCascade* cvLoadHaarClassifierCascade(const char*, CvSize)</code><br>
	 * <i>native declaration : cv\include\cv.h:1101</i><br>
	 * @deprecated use the safer method {@link #cvLoadHaarClassifierCascade(java.lang.String, cxcore.CvSize.ByValue)} instead
	 */
	@java.lang.Deprecated
	cv.CvLibrary.CvHaarClassifierCascade cvLoadHaarClassifierCascade(com.sun.jna.ptr.ByteByReference directory, cxcore.CvSize.ByValue orig_window_size);
	/**
	 * Loads haar classifier cascade from a directory.<br>
	 * It is obsolete: convert your cascade to xml and use cvLoad instead<br>
	 * Original signature : <code>CvHaarClassifierCascade* cvLoadHaarClassifierCascade(const char*, CvSize)</code><br>
	 * <i>native declaration : cv\include\cv.h:1101</i>
	 */
	cv.CvLibrary.CvHaarClassifierCascade cvLoadHaarClassifierCascade(java.lang.String directory, cxcore.CvSize.ByValue orig_window_size);
	/**
	 * Original signature : <code>void cvReleaseHaarClassifierCascade(CvHaarClassifierCascade**)</code><br>
	 * <i>native declaration : cv\include\cv.h:1104</i>
	 */
	void cvReleaseHaarClassifierCascade(com.sun.jna.ptr.PointerByReference cascade);
	/**
	 * Original signature : <code>CvSeq* cvHaarDetectObjects(const CvArr*, CvHaarClassifierCascade*, CvMemStorage*, double, int, int, CvSize)</code><br>
	 * <i>native declaration : cv\include\cv.h:1111</i>
	 */
	cxcore.CvSeq cvHaarDetectObjects(highgui.HighguiLibrary.CvArr image, cv.CvLibrary.CvHaarClassifierCascade cascade, cxcore.CvMemStorage storage, double scale_factor, int min_neighbors, int flags, cxcore.CvSize.ByValue min_size);
	/**
	 * sets images for haar classifier cascade<br>
	 * Original signature : <code>void cvSetImagesForHaarClassifierCascade(CvHaarClassifierCascade*, const CvArr*, const CvArr*, const CvArr*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1118</i>
	 */
	void cvSetImagesForHaarClassifierCascade(cv.CvLibrary.CvHaarClassifierCascade cascade, highgui.HighguiLibrary.CvArr sum, highgui.HighguiLibrary.CvArr sqsum, highgui.HighguiLibrary.CvArr tilted_sum, double scale);
	/**
	 * runs the cascade on the specified window<br>
	 * Original signature : <code>int cvRunHaarClassifierCascade(CvHaarClassifierCascade*, CvPoint, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1123</i>
	 */
	int cvRunHaarClassifierCascade(cv.CvLibrary.CvHaarClassifierCascade cascade, cxcore.CvPoint.ByValue pt, int start_stage);
	/**
	 * Transforms the input image to compensate lens distortion<br>
	 * Original signature : <code>void cvUndistort2(const CvArr*, CvArr*, const CvMat*, const CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1131</i>
	 */
	void cvUndistort2(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat camera_matrix, cxcore.CvMat distortion_coeffs);
	/**
	 * Computes transformation map from intrinsic camera parameters<br>
	 * that can used by cvRemap<br>
	 * Original signature : <code>void cvInitUndistortMap(const CvMat*, const CvMat*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1137</i>
	 */
	void cvInitUndistortMap(cxcore.CvMat camera_matrix, cxcore.CvMat distortion_coeffs, highgui.HighguiLibrary.CvArr mapx, highgui.HighguiLibrary.CvArr mapy);
	/**
	 * Computes undistortion+rectification map for a head of stereo camera<br>
	 * Original signature : <code>void cvInitUndistortRectifyMap(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1142</i>
	 */
	void cvInitUndistortRectifyMap(cxcore.CvMat camera_matrix, cxcore.CvMat dist_coeffs, cxcore.CvMat R, cxcore.CvMat new_camera_matrix, highgui.HighguiLibrary.CvArr mapx, highgui.HighguiLibrary.CvArr mapy);
	/**
	 * Computes the original (undistorted) feature coordinates<br>
	 * from the observed (distorted) coordinates<br>
	 * Original signature : <code>void cvUndistortPoints(const CvMat*, CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1149</i>
	 */
	void cvUndistortPoints(cxcore.CvMat src, cxcore.CvMat dst, cxcore.CvMat camera_matrix, cxcore.CvMat dist_coeffs, cxcore.CvMat R, cxcore.CvMat P);
	/**
	 * Converts rotation vector to rotation matrix or vice versa<br>
	 * Original signature : <code>int cvRodrigues2(const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1156</i>
	 */
	int cvRodrigues2(cxcore.CvMat src, cxcore.CvMat dst, cxcore.CvMat jacobian);
	/**
	 * Finds perspective transformation between the object plane and image (view) plane<br>
	 * Original signature : <code>int cvFindHomography(const CvMat*, const CvMat*, CvMat*, int, double, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1163</i>
	 */
	int cvFindHomography(cxcore.CvMat src_points, cxcore.CvMat dst_points, cxcore.CvMat homography, int method, double ransacReprojThreshold, cxcore.CvMat mask);
	/**
	 * Computes RQ decomposition for 3x3 matrices<br>
	 * Original signature : <code>void cvRQDecomp3x3(const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvPoint3D64f*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1171</i>
	 */
	void cvRQDecomp3x3(cxcore.CvMat matrixM, cxcore.CvMat matrixR, cxcore.CvMat matrixQ, cxcore.CvMat matrixQx, cxcore.CvMat matrixQy, cxcore.CvMat matrixQz, cxcore.CvPoint3D64f eulerAngles);
	/**
	 * Computes projection matrix decomposition<br>
	 * Original signature : <code>void cvDecomposeProjectionMatrix(const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvPoint3D64f*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1178</i>
	 */
	void cvDecomposeProjectionMatrix(cxcore.CvMat projMatr, cxcore.CvMat calibMatr, cxcore.CvMat rotMatr, cxcore.CvMat posVect, cxcore.CvMat rotMatrX, cxcore.CvMat rotMatrY, cxcore.CvMat rotMatrZ, cxcore.CvPoint3D64f eulerAngles);
	/**
	 * Computes d(AB)/dA and d(AB)/dB<br>
	 * Original signature : <code>void cvCalcMatMulDeriv(const CvMat*, const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1186</i>
	 */
	void cvCalcMatMulDeriv(cxcore.CvMat A, cxcore.CvMat B, cxcore.CvMat dABdA, cxcore.CvMat dABdB);
	/**
	 * Computes r3 = rodrigues(rodrigues(r2)*rodrigues(r1)),<br>
	 * t3 = rodrigues(r2)*t1 + t2 and the respective derivatives<br>
	 * Original signature : <code>void cvComposeRT(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1190</i>
	 */
	void cvComposeRT(cxcore.CvMat _rvec1, cxcore.CvMat _tvec1, cxcore.CvMat _rvec2, cxcore.CvMat _tvec2, cxcore.CvMat _rvec3, cxcore.CvMat _tvec3, cxcore.CvMat dr3dr1, cxcore.CvMat dr3dt1, cxcore.CvMat dr3dr2, cxcore.CvMat dr3dt2, cxcore.CvMat dt3dr1, cxcore.CvMat dt3dt1, cxcore.CvMat dt3dr2, cxcore.CvMat dt3dt2);
	/**
	 * Projects object points to the view plane using<br>
	 * the specified extrinsic and intrinsic camera parameters<br>
	 * Original signature : <code>void cvProjectPoints2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1200</i>
	 */
	void cvProjectPoints2(cxcore.CvMat object_points, cxcore.CvMat rotation_vector, cxcore.CvMat translation_vector, cxcore.CvMat camera_matrix, cxcore.CvMat distortion_coeffs, cxcore.CvMat image_points, cxcore.CvMat dpdrot, cxcore.CvMat dpdt, cxcore.CvMat dpdf, cxcore.CvMat dpdc, cxcore.CvMat dpddist, double aspect_ratio);
	/**
	 * Finds extrinsic camera parameters from<br>
	 * a few known corresponding point pairs and intrinsic parameters<br>
	 * Original signature : <code>void cvFindExtrinsicCameraParams2(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1210</i>
	 */
	void cvFindExtrinsicCameraParams2(cxcore.CvMat object_points, cxcore.CvMat image_points, cxcore.CvMat camera_matrix, cxcore.CvMat distortion_coeffs, cxcore.CvMat rotation_vector, cxcore.CvMat translation_vector);
	/**
	 * Computes initial estimate of the intrinsic camera parameters<br>
	 * in case of planar calibration target (e.g. chessboard)<br>
	 * Original signature : <code>void cvInitIntrinsicParams2D(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1219</i>
	 */
	void cvInitIntrinsicParams2D(cxcore.CvMat object_points, cxcore.CvMat image_points, cxcore.CvMat npoints, cxcore.CvSize.ByValue image_size, cxcore.CvMat camera_matrix, double aspect_ratio);
	/**
	 * Detects corners on a chessboard calibration pattern<br>
	 * Original signature : <code>int cvFindChessboardCorners(const void*, CvSize, CvPoint2D32f*, int*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1230</i><br>
	 * @deprecated use the safer method {@link #cvFindChessboardCorners(com.sun.jna.Pointer, cxcore.CvSize.ByValue, cxcore.CvPoint2D32f, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	int cvFindChessboardCorners(com.sun.jna.Pointer image, cxcore.CvSize.ByValue pattern_size, cxcore.CvPoint2D32f corners, com.sun.jna.ptr.IntByReference corner_count, int flags);
	/**
	 * Detects corners on a chessboard calibration pattern<br>
	 * Original signature : <code>int cvFindChessboardCorners(const void*, CvSize, CvPoint2D32f*, int*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1230</i>
	 */
	int cvFindChessboardCorners(com.sun.jna.Pointer image, cxcore.CvSize.ByValue pattern_size, cxcore.CvPoint2D32f corners, java.nio.IntBuffer corner_count, int flags);
	/**
	 * Draws individual chessboard corners or the whole chessboard detected<br>
	 * Original signature : <code>void cvDrawChessboardCorners(CvArr*, CvSize, CvPoint2D32f*, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1237</i>
	 */
	void cvDrawChessboardCorners(highgui.HighguiLibrary.CvArr image, cxcore.CvSize.ByValue pattern_size, cxcore.CvPoint2D32f corners, int count, int pattern_was_found);
	/**
	 * Finds intrinsic and extrinsic camera parameters<br>
	 * from a few views of known calibration pattern<br>
	 * Original signature : <code>void cvCalibrateCamera2(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1252</i>
	 */
	void cvCalibrateCamera2(cxcore.CvMat object_points, cxcore.CvMat image_points, cxcore.CvMat point_counts, cxcore.CvSize.ByValue image_size, cxcore.CvMat camera_matrix, cxcore.CvMat distortion_coeffs, cxcore.CvMat rotation_vectors, cxcore.CvMat translation_vectors, int flags);
	/**
	 * Computes various useful characteristics of the camera from the data computed by<br>
	 * cvCalibrateCamera2<br>
	 * Original signature : <code>void cvCalibrationMatrixValues(const CvMat*, CvSize, double, double, double*, double*, double*, CvPoint2D64f*, double*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1264</i><br>
	 * @deprecated use the safer method {@link #cvCalibrationMatrixValues(cxcore.CvMat, cxcore.CvSize.ByValue, double, double, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, cxcore.CvPoint2D64f, java.nio.DoubleBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvCalibrationMatrixValues(cxcore.CvMat camera_matrix, cxcore.CvSize.ByValue image_size, double aperture_width, double aperture_height, com.sun.jna.ptr.DoubleByReference fovx, com.sun.jna.ptr.DoubleByReference fovy, com.sun.jna.ptr.DoubleByReference focal_length, cxcore.CvPoint2D64f principal_point, com.sun.jna.ptr.DoubleByReference pixel_aspect_ratio);
	/**
	 * Computes various useful characteristics of the camera from the data computed by<br>
	 * cvCalibrateCamera2<br>
	 * Original signature : <code>void cvCalibrationMatrixValues(const CvMat*, CvSize, double, double, double*, double*, double*, CvPoint2D64f*, double*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1264</i>
	 */
	void cvCalibrationMatrixValues(cxcore.CvMat camera_matrix, cxcore.CvSize.ByValue image_size, double aperture_width, double aperture_height, java.nio.DoubleBuffer fovx, java.nio.DoubleBuffer fovy, java.nio.DoubleBuffer focal_length, cxcore.CvPoint2D64f principal_point, java.nio.DoubleBuffer pixel_aspect_ratio);
	/**
	 * Computes the transformation from one camera coordinate system to another one<br>
	 * from a few correspondent views of the same calibration target. Optionally, calibrates<br>
	 * both cameras<br>
	 * Original signature : <code>void cvStereoCalibrate(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvSize, CvMat*, CvMat*, CvMat*, CvMat*, CvTermCriteria, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1280</i>
	 */
	void cvStereoCalibrate(cxcore.CvMat object_points, cxcore.CvMat image_points1, cxcore.CvMat image_points2, cxcore.CvMat npoints, cxcore.CvMat camera_matrix1, cxcore.CvMat dist_coeffs1, cxcore.CvMat camera_matrix2, cxcore.CvMat dist_coeffs2, cxcore.CvSize.ByValue image_size, cxcore.CvMat R, cxcore.CvMat T, cxcore.CvMat E, cxcore.CvMat F, cxcore.CvTermCriteria.ByValue term_crit, int flags);
	/**
	 * Computes 3D rotations (+ optional shift) for each camera coordinate system to make both<br>
	 * views parallel (=> to make all the epipolar lines horizontal or vertical)<br>
	 * Original signature : <code>void cvStereoRectify(const CvMat*, const CvMat*, const CvMat*, const CvMat*, CvSize, const CvMat*, const CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, CvMat*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1294</i>
	 */
	void cvStereoRectify(cxcore.CvMat camera_matrix1, cxcore.CvMat camera_matrix2, cxcore.CvMat dist_coeffs1, cxcore.CvMat dist_coeffs2, cxcore.CvSize.ByValue image_size, cxcore.CvMat R, cxcore.CvMat T, cxcore.CvMat R1, cxcore.CvMat R2, cxcore.CvMat P1, cxcore.CvMat P2, cxcore.CvMat Q, int flags);
	/**
	 * Computes rectification transformations for uncalibrated pair of images using a set<br>
	 * of point correspondences<br>
	 * Original signature : <code>int cvStereoRectifyUncalibrated(const CvMat*, const CvMat*, const CvMat*, CvSize, CvMat*, CvMat*, double)</code><br>
	 * <i>native declaration : cv\include\cv.h:1303</i>
	 */
	int cvStereoRectifyUncalibrated(cxcore.CvMat points1, cxcore.CvMat points2, cxcore.CvMat F, cxcore.CvSize.ByValue img_size, cxcore.CvMat H1, cxcore.CvMat H2, double threshold);
	/**
	 * Allocates and initializes CvPOSITObject structure before doing cvPOSIT<br>
	 * Original signature : <code>CvPOSITObject* cvCreatePOSITObject(CvPoint3D32f*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1311</i>
	 */
	cv.CvLibrary.CvPOSITObject cvCreatePOSITObject(cxcore.CvPoint3D32f points, int point_count);
	/**
	 * <i>native declaration : cv\include\cv.h:1316</i><br>
	 * Conversion Error : CvMatr32f
	 */
	/**
	 * Releases CvPOSITObject structure<br>
	 * Original signature : <code>void cvReleasePOSITObject(CvPOSITObject**)</code><br>
	 * <i>native declaration : cv\include\cv.h:1321</i>
	 */
	void cvReleasePOSITObject(com.sun.jna.ptr.PointerByReference posit_object);
	/**
	 * updates the number of RANSAC iterations<br>
	 * Original signature : <code>int cvRANSACUpdateNumIters(double, double, int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1324</i>
	 */
	int cvRANSACUpdateNumIters(double p, double err_prob, int model_points, int max_iters);
	/**
	 * Original signature : <code>void cvConvertPointsHomogeneous(const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1327</i>
	 */
	void cvConvertPointsHomogeneous(cxcore.CvMat src, cxcore.CvMat dst);
	/**
	 * Original signature : <code>int cvFindFundamentalMat(const CvMat*, const CvMat*, CvMat*, int, double, double, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1336</i>
	 */
	int cvFindFundamentalMat(cxcore.CvMat points1, cxcore.CvMat points2, cxcore.CvMat fundamental_matrix, int method, double param1, double param2, cxcore.CvMat status);
	/**
	 * For each input point on one of images<br>
	 * computes parameters of the corresponding<br>
	 * epipolar line on the other image<br>
	 * Original signature : <code>void cvComputeCorrespondEpilines(const CvMat*, int, const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1345</i>
	 */
	void cvComputeCorrespondEpilines(cxcore.CvMat points, int which_image, cxcore.CvMat fundamental_matrix, cxcore.CvMat correspondent_lines);
	/**
	 * Original signature : <code>CvStereoBMState* cvCreateStereoBMState(int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1387</i>
	 */
	cv.CvStereoBMState cvCreateStereoBMState(int preset, int numberOfDisparities);
	/**
	 * Original signature : <code>void cvReleaseStereoBMState(CvStereoBMState**)</code><br>
	 * <i>native declaration : cv\include\cv.h:1390</i>
	 */
	void cvReleaseStereoBMState(cv.CvStereoBMState.ByReference state[]);
	/**
	 * Original signature : <code>void cvFindStereoCorrespondenceBM(const CvArr*, const CvArr*, CvArr*, CvStereoBMState*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1392</i>
	 */
	void cvFindStereoCorrespondenceBM(highgui.HighguiLibrary.CvArr left, highgui.HighguiLibrary.CvArr right, highgui.HighguiLibrary.CvArr disparity, cv.CvStereoBMState state);
	/**
	 * Original signature : <code>CvStereoGCState* cvCreateStereoGCState(int, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1419</i>
	 */
	cv.CvStereoGCState cvCreateStereoGCState(int numberOfDisparities, int maxIters);
	/**
	 * Original signature : <code>void cvReleaseStereoGCState(CvStereoGCState**)</code><br>
	 * <i>native declaration : cv\include\cv.h:1420</i>
	 */
	void cvReleaseStereoGCState(cv.CvStereoGCState.ByReference state[]);
	/**
	 * Original signature : <code>void cvFindStereoCorrespondenceGC(const CvArr*, const CvArr*, CvArr*, CvArr*, CvStereoGCState*, int)</code><br>
	 * <i>native declaration : cv\include\cv.h:1422</i>
	 */
	void cvFindStereoCorrespondenceGC(highgui.HighguiLibrary.CvArr left, highgui.HighguiLibrary.CvArr right, highgui.HighguiLibrary.CvArr disparityLeft, highgui.HighguiLibrary.CvArr disparityRight, cv.CvStereoGCState state, int useDisparityGuess);
	/**
	 * Reprojects the computed disparity image to the 3D space using the specified 4x4 matrix<br>
	 * Original signature : <code>void cvReprojectImageTo3D(const CvArr*, CvArr*, const CvMat*)</code><br>
	 * <i>native declaration : cv\include\cv.h:1428</i>
	 */
	void cvReprojectImageTo3D(highgui.HighguiLibrary.CvArr disparityImage, highgui.HighguiLibrary.CvArr _3dImage, cxcore.CvMat Q);
	/**
	 * Original signature : <code>CvMat cvMatArray(int, int, int, int, void*)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:103</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z10cvMatArrayiiiiPv", "?cvMatArray@@YAUCvMat@@HHHHPAX@Z"})
	cxcore.CvMat.ByValue cvMatArray(int rows, int cols, int type, int count, com.sun.jna.Pointer data);
	/**
	 * Original signature : <code>double cvMean(const CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:119</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z6cvMeanPKvPKv", "?cvMean@@YANPAXPAX@Z"})
	double cvMean(highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>double cvSumPixels(const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:126</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z11cvSumPixelsPKv", "?cvSumPixels@@YANPAX@Z"})
	double cvSumPixels(highgui.HighguiLibrary.CvArr image);
	/**
	 * Original signature : <code>void cvMean_StdDev(const CvArr*, double*, double*, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:132</i><br>
	 * @deprecated use the safer method {@link #cvMean_StdDev(highgui.HighguiLibrary.CvArr, java.nio.DoubleBuffer, java.nio.DoubleBuffer, highgui.HighguiLibrary.CvArr)} instead
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z13cvMean_StdDevPKvPdPdPKv", "?cvMean_StdDev@@YAXPAXPANPANPAX@Z"})
	@java.lang.Deprecated
	void cvMean_StdDev(highgui.HighguiLibrary.CvArr image, com.sun.jna.ptr.DoubleByReference mean, com.sun.jna.ptr.DoubleByReference sdv, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvMean_StdDev(const CvArr*, double*, double*, const CvArr*)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:132</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z13cvMean_StdDevPKvPdPdPKv", "?cvMean_StdDev@@YAXPAXPANPANPAX@Z"})
	void cvMean_StdDev(highgui.HighguiLibrary.CvArr image, java.nio.DoubleBuffer mean, java.nio.DoubleBuffer sdv, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvmPerspectiveProject(const CvMat*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:146</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z21cvmPerspectiveProjectPK5CvMatPKvPv", "?cvmPerspectiveProject@@YAXPAUCvMat@@PAXPAX@Z"})
	void cvmPerspectiveProject(cxcore.CvMat mat, highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Original signature : <code>void cvFillImage(CvArr*, double)</code><br>
	 * <i>native declaration : cv\include\cvcompat.h:157</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z11cvFillImagePvd", "?cvFillImage@@YAXPAXN@Z"})
	void cvFillImage(highgui.HighguiLibrary.CvArr mat, double color);
	/// Pointer to unknown (opaque) type
	public static class CvFeatureTree extends com.sun.jna.PointerType {
		public CvFeatureTree(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvFeatureTree() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvConDensation extends com.sun.jna.PointerType {
		public CvConDensation(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvConDensation() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class _CvContourScanner extends com.sun.jna.PointerType {
		public _CvContourScanner(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public _CvContourScanner() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvHaarClassifierCascade extends com.sun.jna.PointerType {
		public CvHaarClassifierCascade(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvHaarClassifierCascade() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvPOSITObject extends com.sun.jna.PointerType {
		public CvPOSITObject(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvPOSITObject() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvSubdiv2D extends com.sun.jna.PointerType {
		public CvSubdiv2D(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvSubdiv2D() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvSubdiv2DPoint extends com.sun.jna.PointerType {
		public CvSubdiv2DPoint(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvSubdiv2DPoint() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvContourTree extends com.sun.jna.PointerType {
		public CvContourTree(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvContourTree() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvKalman extends com.sun.jna.PointerType {
		public CvKalman(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvKalman() {
			super();
		}
	}
}
