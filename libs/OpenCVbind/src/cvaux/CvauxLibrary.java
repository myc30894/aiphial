package cvaux;
/**
 * JNA Wrapper for library <b>cvaux</b><br>
 * @see OpenCV.cvaux<br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a>, <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface CvauxLibrary extends com.sun.jna.Library {
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:291</i><br>
	 * enum values
	 */
	public static interface CvGraphWeightType {
		public static final int CV_NOT_WEIGHTED = 0;
		public static final int CV_WEIGHTED_VTX = 1;
		public static final int CV_WEIGHTED_EDGE = 2;
		public static final int CV_WEIGHTED_ALL = 3;
	}
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:817</i><br>
	 * enum values
	 */
	public static interface CV_FACE_ELEMENTS {
		public static final int CV_FACE_MOUTH = 0;
		public static final int CV_FACE_LEFT_EYE = 1;
		public static final int CV_FACE_RIGHT_EYE = 2;
	}
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:916</i><br>
	 * enum values
	 */
	public static interface CvLeeParameters {
		public static final int CV_LEE_INT = 0;
		public static final int CV_LEE_FLOAT = 1;
		public static final int CV_LEE_DOUBLE = 2;
		public static final int CV_LEE_AUTO = -1;
		public static final int CV_LEE_ERODE = 0;
		public static final int CV_LEE_ZOOM = 1;
		public static final int CV_LEE_NON = 2;
	}
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:1428</i><br>
	 * enum values
	 */
	public static interface CvCalibEtalonType {
		public static final int CV_CALIB_ETALON_USER = -1;
		public static final int CV_CALIB_ETALON_CHESSBOARD = 0;
		public static final int CV_CALIB_ETALON_CHECKERBOARD = cvaux.CvauxLibrary.CvCalibEtalonType.CV_CALIB_ETALON_CHESSBOARD;
	}
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_N1CC = 25;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_MOG_WINDOW_SIZE = 200;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BG_MODEL_MOG = 1;
	/**
	 * define<br>
	 * Conversion Error : null<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * null * node[2]
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_MOG_SIGMA_INIT = 30;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_CONTRAST = 3;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final double CV_BGFG_MOG_WEIGHT_INIT = 0.05;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_OPTIMIZATION_ALLOWDOUBLENEST = 10;
	/**
	 * define<br>
	 * Conversion Error : CV_GRAPH_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * CV_GRAPH_FIELDS()
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCM_OPTIMIZATION_NONE = -2;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_MOG_NCOLORS = 3;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_CLUSTERTENDENCY = 4;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_EIGOBJ_INPUT_CALLBACK = 1;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_IDP_BIRCHFIELD_PARAM1 = 25;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_IDP_BIRCHFIELD_PARAM5 = 25;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_IDP_BIRCHFIELD_PARAM4 = 15;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_IDP_BIRCHFIELD_PARAM3 = 12;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_IDP_BIRCHFIELD_PARAM2 = 5;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_OPTIMIZATION_ALLOWTRIPLENEST = 11;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCM_OPTIMIZATION_HISTOGRAM = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final double CV_BGFG_MOG_STD_THRESHOLD = 2.5;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_UNDEF_SC_PARAM = 12345;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_ENERGY = 1;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_N1C = 15;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_MOG_MINAREA = 15.0F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_N2C = 25;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_LC = 128;
	/**
	 * define<br>
	 * Conversion Error : CV_GRAPH_EDGE_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * CV_GRAPH_EDGE_FIELDS()
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CLIQUE_END = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_CORRELATION = 6;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CLIQUE_FOUND = 1;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_EIGOBJ_BOTH_CALLBACK = 3;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final double CV_BGFG_MOG_BACKGROUND_THRESHOLD = 0.7;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_EIGOBJ_OUTPUT_CALLBACK = 2;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_CLUSTERSHADE = 5;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_NUM_FACE_ELEMENTS = 3;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BG_MODEL_FGD = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_DELTA = 2;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BG_MODEL_FGD_SIMPLE = 2;
	/**
	 * define<br>
	 * Conversion Error : null<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * null * node[2]
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_EIGOBJ_NO_CALLBACK = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_MOG_NGAUSSIANS = 5;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_ENTROPY = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_N2CC = 40;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_OPTIMIZATION_HISTOGRAM = 4;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_WARP_TO_CAMERA = 2;
	/**
	 * define<br>
	 * Conversion Error : CV_SET_ELEM_FIELDS(CvVoronoiNode2D)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * CV_SET_ELEM_FIELDS(CvVoronoiNode2D)
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_FGD_ALPHA_1 = 0.1F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_FGD_ALPHA_3 = 0.1F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_FGD_ALPHA_2 = 0.0050F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_CAMERA_TO_WARP = 1;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_MAXIMUMPROBABILITY = 9;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_FGD_T = 0.9F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_HOMOGENITY = 2;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CLIQUE_TIME_OFF = 2;
	/**
	 * define<br>
	 * Conversion Error : CV_GRAPH_VERTEX_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * CV_GRAPH_VERTEX_FIELDS()
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_FGD_MINAREA = 15.0F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_DISPARITY_BIRCHFIELD = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCM_DESC = 2;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_CORRELATIONINFO2 = 8;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCMDESC_CORRELATIONINFO1 = 7;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cvaux\include\cvaux.h</i><br>
	 * int
	 */
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_MOG_MAX_NGAUSSIANS = 500;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final float CV_BGFG_FGD_BG_UPDATE_TRESH = 0.5F;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCM_GLCM = 1;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCM_OPTIMIZATION_LUT = -1;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_GLCM_ALL = 0;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public static final int CV_BGFG_FGD_LCC = 64;
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public interface CvCallback extends com.sun.jna.Callback {
		int invoke(int index, com.sun.jna.Pointer buffer, com.sun.jna.Pointer user_data);
	}
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public interface CvReleaseBGStatModel extends com.sun.jna.Callback {
		void invoke(cvaux.CvBGStatModel.ByReference bg_model[]);
	}
	/// <i>native declaration : cvaux\include\cvaux.h</i>
	public interface CvUpdateBGStatModel extends com.sun.jna.Callback {
		int invoke(cxcore.IplImage curr_frame, cvaux.CvBGStatModel bg_model);
	}
	/**
	 * Original signature : <code>CvSeq* cvSegmentImage(const CvArr*, CvArr*, double, double, CvMemStorage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:46</i>
	 */
	cxcore.CvSeq cvSegmentImage(highgui.HighguiLibrary.CvArr srcarr, highgui.HighguiLibrary.CvArr dstarr, double canny_threshold, double ffill_threshold, cxcore.CvMemStorage storage);
	/**
	 * Calculates covariation matrix of a set of arrays<br>
	 * Original signature : <code>void cvCalcCovarMatrixEx(int, void*, int, int, uchar*, void*, IplImage*, float*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:69</i><br>
	 * @deprecated use the safer method {@link #cvCalcCovarMatrixEx(int, com.sun.jna.Pointer, int, int, java.nio.ByteBuffer, com.sun.jna.Pointer, cxcore.IplImage, java.nio.FloatBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvCalcCovarMatrixEx(int nObjects, com.sun.jna.Pointer input, int ioFlags, int ioBufSize, com.sun.jna.ptr.ByteByReference buffer, com.sun.jna.Pointer userData, cxcore.IplImage avg, com.sun.jna.ptr.FloatByReference covarMatrix);
	/**
	 * Calculates covariation matrix of a set of arrays<br>
	 * Original signature : <code>void cvCalcCovarMatrixEx(int, void*, int, int, uchar*, void*, IplImage*, float*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:69</i>
	 */
	void cvCalcCovarMatrixEx(int nObjects, com.sun.jna.Pointer input, int ioFlags, int ioBufSize, java.nio.ByteBuffer buffer, com.sun.jna.Pointer userData, cxcore.IplImage avg, java.nio.FloatBuffer covarMatrix);
	/**
	 * Calculates eigen values and vectors of covariation matrix of a set of<br>
	 * arrays<br>
	 * Original signature : <code>void cvCalcEigenObjects(int, void*, void*, int, int, void*, CvTermCriteria*, IplImage*, float*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:75</i><br>
	 * @deprecated use the safer method {@link #cvCalcEigenObjects(int, com.sun.jna.Pointer, com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, cxcore.CvTermCriteria, cxcore.IplImage, java.nio.FloatBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvCalcEigenObjects(int nObjects, com.sun.jna.Pointer input, com.sun.jna.Pointer output, int ioFlags, int ioBufSize, com.sun.jna.Pointer userData, cxcore.CvTermCriteria calcLimit, cxcore.IplImage avg, com.sun.jna.ptr.FloatByReference eigVals);
	/**
	 * Calculates eigen values and vectors of covariation matrix of a set of<br>
	 * arrays<br>
	 * Original signature : <code>void cvCalcEigenObjects(int, void*, void*, int, int, void*, CvTermCriteria*, IplImage*, float*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:75</i>
	 */
	void cvCalcEigenObjects(int nObjects, com.sun.jna.Pointer input, com.sun.jna.Pointer output, int ioFlags, int ioBufSize, com.sun.jna.Pointer userData, cxcore.CvTermCriteria calcLimit, cxcore.IplImage avg, java.nio.FloatBuffer eigVals);
	/**
	 * Calculates dot product (obj - avg) * eigObj (i.e. projects image to eigen vector)<br>
	 * Original signature : <code>double cvCalcDecompCoeff(IplImage*, IplImage*, IplImage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:81</i>
	 */
	double cvCalcDecompCoeff(cxcore.IplImage obj, cxcore.IplImage eigObj, cxcore.IplImage avg);
	/**
	 * Projects image to eigen space (finds all decomposion coefficients<br>
	 * Original signature : <code>void cvEigenDecomposite(IplImage*, int, void*, int, void*, IplImage*, float*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:84</i><br>
	 * @deprecated use the safer method {@link #cvEigenDecomposite(cxcore.IplImage, int, com.sun.jna.Pointer, int, com.sun.jna.Pointer, cxcore.IplImage, java.nio.FloatBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvEigenDecomposite(cxcore.IplImage obj, int nEigObjs, com.sun.jna.Pointer eigInput, int ioFlags, com.sun.jna.Pointer userData, cxcore.IplImage avg, com.sun.jna.ptr.FloatByReference coeffs);
	/**
	 * Projects image to eigen space (finds all decomposion coefficients<br>
	 * Original signature : <code>void cvEigenDecomposite(IplImage*, int, void*, int, void*, IplImage*, float*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:84</i>
	 */
	void cvEigenDecomposite(cxcore.IplImage obj, int nEigObjs, com.sun.jna.Pointer eigInput, int ioFlags, com.sun.jna.Pointer userData, cxcore.IplImage avg, java.nio.FloatBuffer coeffs);
	/**
	 * Projects original objects used to calculate eigen space basis to that space<br>
	 * Original signature : <code>void cvEigenProjection(void*, int, int, void*, float*, IplImage*, IplImage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:89</i><br>
	 * @deprecated use the safer method {@link #cvEigenProjection(com.sun.jna.Pointer, int, int, com.sun.jna.Pointer, java.nio.FloatBuffer, cxcore.IplImage, cxcore.IplImage)} instead
	 */
	@java.lang.Deprecated
	void cvEigenProjection(com.sun.jna.Pointer eigInput, int nEigObjs, int ioFlags, com.sun.jna.Pointer userData, com.sun.jna.ptr.FloatByReference coeffs, cxcore.IplImage avg, cxcore.IplImage proj);
	/**
	 * Projects original objects used to calculate eigen space basis to that space<br>
	 * Original signature : <code>void cvEigenProjection(void*, int, int, void*, float*, IplImage*, IplImage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:89</i>
	 */
	void cvEigenProjection(com.sun.jna.Pointer eigInput, int nEigObjs, int ioFlags, com.sun.jna.Pointer userData, java.nio.FloatBuffer coeffs, cxcore.IplImage avg, cxcore.IplImage proj);
	/**
	 * Creates 2D HMM<br>
	 * Original signature : <code>CvEHMM* cvCreate2DHMM(int*, int*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:164</i><br>
	 * @deprecated use the safer method {@link #cvCreate2DHMM(java.nio.IntBuffer, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	cvaux.CvEHMM cvCreate2DHMM(com.sun.jna.ptr.IntByReference stateNumber, com.sun.jna.ptr.IntByReference numMix, int obsSize);
	/**
	 * Creates 2D HMM<br>
	 * Original signature : <code>CvEHMM* cvCreate2DHMM(int*, int*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:164</i>
	 */
	cvaux.CvEHMM cvCreate2DHMM(java.nio.IntBuffer stateNumber, java.nio.IntBuffer numMix, int obsSize);
	/**
	 * Releases HMM<br>
	 * Original signature : <code>void cvRelease2DHMM(CvEHMM**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:167</i>
	 */
	void cvRelease2DHMM(cvaux.CvEHMM.ByReference hmm[]);
	/**
	 * Creates storage for observation vectors<br>
	 * Original signature : <code>CvImgObsInfo* cvCreateObsInfo(CvSize, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:176</i>
	 */
	cvaux.CvImgObsInfo cvCreateObsInfo(cxcore.CvSize.ByValue numObs, int obsSize);
	/**
	 * Releases storage for observation vectors<br>
	 * Original signature : <code>void cvReleaseObsInfo(CvImgObsInfo**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:179</i>
	 */
	void cvReleaseObsInfo(cvaux.CvImgObsInfo.ByReference obs_info[]);
	/**
	 * The function takes an image on input and and returns the sequnce of observations<br>
	 * to be used with an embedded HMM; Each observation is top-left block of DCT<br>
	 * coefficient matrix<br>
	 * Original signature : <code>void cvImgToObs_DCT(const CvArr*, float*, CvSize, CvSize, CvSize)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:185</i><br>
	 * @deprecated use the safer method {@link #cvImgToObs_DCT(highgui.HighguiLibrary.CvArr, java.nio.FloatBuffer, cxcore.CvSize.ByValue, cxcore.CvSize.ByValue, cxcore.CvSize.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvImgToObs_DCT(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.FloatByReference obs, cxcore.CvSize.ByValue dctSize, cxcore.CvSize.ByValue obsSize, cxcore.CvSize.ByValue delta);
	/**
	 * The function takes an image on input and and returns the sequnce of observations<br>
	 * to be used with an embedded HMM; Each observation is top-left block of DCT<br>
	 * coefficient matrix<br>
	 * Original signature : <code>void cvImgToObs_DCT(const CvArr*, float*, CvSize, CvSize, CvSize)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:185</i>
	 */
	void cvImgToObs_DCT(highgui.HighguiLibrary.CvArr arr, java.nio.FloatBuffer obs, cxcore.CvSize.ByValue dctSize, cxcore.CvSize.ByValue obsSize, cxcore.CvSize.ByValue delta);
	/**
	 * Uniformly segments all observation vectors extracted from image<br>
	 * Original signature : <code>void cvUniformImgSegm(CvImgObsInfo*, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:190</i>
	 */
	void cvUniformImgSegm(cvaux.CvImgObsInfo obs_info, cvaux.CvEHMM ehmm);
	/**
	 * Does mixture segmentation of the states of embedded HMM<br>
	 * Original signature : <code>void cvInitMixSegm(CvImgObsInfo**, int, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:193</i>
	 */
	void cvInitMixSegm(cvaux.CvImgObsInfo.ByReference obs_info_array[], int num_img, cvaux.CvEHMM hmm);
	/**
	 * Function calculates means, variances, weights of every Gaussian mixture<br>
	 * of every low-level state of embedded HMM<br>
	 * Original signature : <code>void cvEstimateHMMStateParams(CvImgObsInfo**, int, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:198</i>
	 */
	void cvEstimateHMMStateParams(cvaux.CvImgObsInfo.ByReference obs_info_array[], int num_img, cvaux.CvEHMM hmm);
	/**
	 * Function computes transition probability matrices of embedded HMM<br>
	 * given observations segmentation<br>
	 * Original signature : <code>void cvEstimateTransProb(CvImgObsInfo**, int, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:203</i>
	 */
	void cvEstimateTransProb(cvaux.CvImgObsInfo.ByReference obs_info_array[], int num_img, cvaux.CvEHMM hmm);
	/**
	 * Function computes probabilities of appearing observations at any state<br>
	 * (i.e. computes P(obs|state) for every pair(obs,state))<br>
	 * Original signature : <code>void cvEstimateObsProb(CvImgObsInfo*, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:208</i>
	 */
	void cvEstimateObsProb(cvaux.CvImgObsInfo obs_info, cvaux.CvEHMM hmm);
	/**
	 * Runs Viterbi algorithm for embedded HMM<br>
	 * Original signature : <code>float cvEViterbi(CvImgObsInfo*, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:212</i>
	 */
	float cvEViterbi(cvaux.CvImgObsInfo obs_info, cvaux.CvEHMM hmm);
	/**
	 * Function clusters observation vectors from several images<br>
	 * given observations segmentation.<br>
	 * Euclidean distance used for clustering vectors.<br>
	 * Centers of clusters are given means of every mixture<br>
	 * Original signature : <code>void cvMixSegmL2(CvImgObsInfo**, int, CvEHMM*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:219</i>
	 */
	void cvMixSegmL2(cvaux.CvImgObsInfo.ByReference obs_info_array[], int num_img, cvaux.CvEHMM hmm);
	/**
	 * Creates hand mask image given several points on the hand<br>
	 * Original signature : <code>void cvCreateHandMask(CvSeq*, IplImage*, CvRect*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:227</i>
	 */
	void cvCreateHandMask(cxcore.CvSeq hand_points, cxcore.IplImage img_mask, cxcore.CvRect roi);
	/**
	 * Finds hand region in range image data<br>
	 * Original signature : <code>void cvFindHandRegion(CvPoint3D32f*, int, CvSeq*, float*, CvSize2D32f, int, CvPoint3D32f*, CvMemStorage*, CvSeq**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:231</i><br>
	 * @deprecated use the safer method {@link #cvFindHandRegion(cxcore.CvPoint3D32f, int, cxcore.CvSeq, java.nio.FloatBuffer, cxcore.CvSize2D32f.ByValue, int, cxcore.CvPoint3D32f, cxcore.CvMemStorage, cxcore.CvSeq.ByReference[])} instead
	 */
	@java.lang.Deprecated
	void cvFindHandRegion(cxcore.CvPoint3D32f points, int count, cxcore.CvSeq indexs, com.sun.jna.ptr.FloatByReference line, cxcore.CvSize2D32f.ByValue size, int flag, cxcore.CvPoint3D32f center, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference numbers[]);
	/**
	 * Finds hand region in range image data<br>
	 * Original signature : <code>void cvFindHandRegion(CvPoint3D32f*, int, CvSeq*, float*, CvSize2D32f, int, CvPoint3D32f*, CvMemStorage*, CvSeq**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:231</i>
	 */
	void cvFindHandRegion(cxcore.CvPoint3D32f points, int count, cxcore.CvSeq indexs, java.nio.FloatBuffer line, cxcore.CvSize2D32f.ByValue size, int flag, cxcore.CvPoint3D32f center, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference numbers[]);
	/**
	 * Finds hand region in range image data (advanced version)<br>
	 * Original signature : <code>void cvFindHandRegionA(CvPoint3D32f*, int, CvSeq*, float*, CvSize2D32f, int, CvPoint3D32f*, CvMemStorage*, CvSeq**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:238</i><br>
	 * @deprecated use the safer method {@link #cvFindHandRegionA(cxcore.CvPoint3D32f, int, cxcore.CvSeq, java.nio.FloatBuffer, cxcore.CvSize2D32f.ByValue, int, cxcore.CvPoint3D32f, cxcore.CvMemStorage, cxcore.CvSeq.ByReference[])} instead
	 */
	@java.lang.Deprecated
	void cvFindHandRegionA(cxcore.CvPoint3D32f points, int count, cxcore.CvSeq indexs, com.sun.jna.ptr.FloatByReference line, cxcore.CvSize2D32f.ByValue size, int jc, cxcore.CvPoint3D32f center, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference numbers[]);
	/**
	 * Finds hand region in range image data (advanced version)<br>
	 * Original signature : <code>void cvFindHandRegionA(CvPoint3D32f*, int, CvSeq*, float*, CvSize2D32f, int, CvPoint3D32f*, CvMemStorage*, CvSeq**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:238</i>
	 */
	void cvFindHandRegionA(cxcore.CvPoint3D32f points, int count, cxcore.CvSeq indexs, java.nio.FloatBuffer line, cxcore.CvSize2D32f.ByValue size, int jc, cxcore.CvPoint3D32f center, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference numbers[]);
	/**
	 * paints voronoi diagram: just demo function<br>
	 * Original signature : <code>void icvDrawMosaic(CvSubdiv2D*, IplImage*, IplImage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:249</i>
	 */
	void icvDrawMosaic(cv.CvLibrary.CvSubdiv2D subdiv, cxcore.IplImage src, cxcore.IplImage dst);
	/**
	 * but it verifies some relations between quad-edges<br>
	 * Original signature : <code>int icvSubdiv2DCheck(CvSubdiv2D*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:253</i>
	 */
	int icvSubdiv2DCheck(cv.CvLibrary.CvSubdiv2D subdiv);
	/**
	 * returns squared distance between two 2D points with floating-point coordinates.<br>
	 * Original signature : <code>double icvSqDist2D32f(CvPoint2D32f, CvPoint2D32f)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:256</i>
	 */
	double icvSqDist2D32f(cxcore.CvPoint2D32f.ByValue pt1, cxcore.CvPoint2D32f.ByValue pt2);
	/**
	 * F///////////////////////////////////////////////////////////////////////////<br>
	 * //<br>
	 * //    Name:    cvFindStereoCorrespondence<br>
	 * //    Purpose: find stereo correspondence on stereo-pair<br>
	 * //    Context:<br>
	 * //    Parameters:<br>
	 * //      leftImage - left image of stereo-pair (format 8uC1).<br>
	 * //      rightImage - right image of stereo-pair (format 8uC1).<br>
	 * //   mode - mode of correspondence retrieval (now CV_DISPARITY_BIRCHFIELD only)<br>
	 * //      dispImage - destination disparity image<br>
	 * //      maxDisparity - maximal disparity <br>
	 * //      param1, param2, param3, param4, param5 - parameters of algorithm<br>
	 * //    Returns:<br>
	 * //    Notes:<br>
	 * //      Images must be rectified.<br>
	 * //      All images must have format 8uC1.<br>
	 * //F<br>
	 * Original signature : <code>void cvFindStereoCorrespondence(const CvArr*, const CvArr*, int, CvArr*, int, double, double, double, double, double)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:468</i>
	 */
	void cvFindStereoCorrespondence(highgui.HighguiLibrary.CvArr leftImage, highgui.HighguiLibrary.CvArr rightImage, int mode, highgui.HighguiLibrary.CvArr dispImage, int maxDisparity, double param1, double param2, double param3, double param4, double param5);
	/**
	 * Original signature : <code>int icvConvertWarpCoordinates(double[3][3], CvPoint2D32f*, CvPoint2D32f*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:548</i><br>
	 * @deprecated use the safer method {@link #icvConvertWarpCoordinates(java.nio.DoubleBuffer, cxcore.CvPoint2D32f, cxcore.CvPoint2D32f, int)} instead
	 */
	@java.lang.Deprecated
	int icvConvertWarpCoordinates(com.sun.jna.ptr.DoubleByReference coeffs, cxcore.CvPoint2D32f cameraPoint, cxcore.CvPoint2D32f warpPoint, int direction);
	/**
	 * Original signature : <code>int icvConvertWarpCoordinates(double[3][3], CvPoint2D32f*, CvPoint2D32f*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:548</i>
	 */
	int icvConvertWarpCoordinates(java.nio.DoubleBuffer coeffs, cxcore.CvPoint2D32f cameraPoint, cxcore.CvPoint2D32f warpPoint, int direction);
	/**
	 * Original signature : <code>int icvGetSymPoint3D(CvPoint3D64f, CvPoint3D64f, CvPoint3D64f, CvPoint3D64f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:553</i>
	 */
	int icvGetSymPoint3D(cxcore.CvPoint3D64f.ByValue pointCorner, cxcore.CvPoint3D64f.ByValue point1, cxcore.CvPoint3D64f.ByValue point2, cxcore.CvPoint3D64f pointSym2);
	/**
	 * Original signature : <code>void icvGetPieceLength3D(CvPoint3D64f, CvPoint3D64f, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:558</i><br>
	 * @deprecated use the safer method {@link #icvGetPieceLength3D(cxcore.CvPoint3D64f.ByValue, cxcore.CvPoint3D64f.ByValue, java.nio.DoubleBuffer)} instead
	 */
	@java.lang.Deprecated
	void icvGetPieceLength3D(cxcore.CvPoint3D64f.ByValue point1, cxcore.CvPoint3D64f.ByValue point2, com.sun.jna.ptr.DoubleByReference dist);
	/**
	 * Original signature : <code>void icvGetPieceLength3D(CvPoint3D64f, CvPoint3D64f, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:558</i>
	 */
	void icvGetPieceLength3D(cxcore.CvPoint3D64f.ByValue point1, cxcore.CvPoint3D64f.ByValue point2, java.nio.DoubleBuffer dist);
	/**
	 * Original signature : <code>int icvCompute3DPoint(double, double, CvStereoLineCoeff*, CvPoint3D64f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:560</i>
	 */
	int icvCompute3DPoint(double alpha, double betta, cvaux.CvStereoLineCoeff coeffs, cxcore.CvPoint3D64f point);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:564</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:571</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * Original signature : <code>int icvComputeCoeffForStereo(CvStereoCamera*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:577</i>
	 */
	int icvComputeCoeffForStereo(cvaux.CvStereoCamera stereoCamera);
	/**
	 * Original signature : <code>int icvGetCrossPieceVector(CvPoint2D32f, CvPoint2D32f, CvPoint2D32f, CvPoint2D32f, CvPoint2D32f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:579</i>
	 */
	int icvGetCrossPieceVector(cxcore.CvPoint2D32f.ByValue p1_start, cxcore.CvPoint2D32f.ByValue p1_end, cxcore.CvPoint2D32f.ByValue v2_start, cxcore.CvPoint2D32f.ByValue v2_end, cxcore.CvPoint2D32f cross);
	/**
	 * Original signature : <code>int icvGetCrossLineDirect(CvPoint2D32f, CvPoint2D32f, float, float, float, CvPoint2D32f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:580</i>
	 */
	int icvGetCrossLineDirect(cxcore.CvPoint2D32f.ByValue p1, cxcore.CvPoint2D32f.ByValue p2, float a, float b, float c, cxcore.CvPoint2D32f cross);
	/**
	 * Original signature : <code>float icvDefinePointPosition(CvPoint2D32f, CvPoint2D32f, CvPoint2D32f)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:581</i>
	 */
	float icvDefinePointPosition(cxcore.CvPoint2D32f.ByValue point1, cxcore.CvPoint2D32f.ByValue point2, cxcore.CvPoint2D32f.ByValue point);
	/**
	 * Original signature : <code>int icvStereoCalibration(int, int*, CvSize, CvPoint2D32f*, CvPoint2D32f*, CvPoint3D32f*, CvStereoCamera*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:582</i><br>
	 * @deprecated use the safer method {@link #icvStereoCalibration(int, java.nio.IntBuffer, cxcore.CvSize.ByValue, cxcore.CvPoint2D32f, cxcore.CvPoint2D32f, cxcore.CvPoint3D32f, cvaux.CvStereoCamera)} instead
	 */
	@java.lang.Deprecated
	int icvStereoCalibration(int numImages, com.sun.jna.ptr.IntByReference nums, cxcore.CvSize.ByValue imageSize, cxcore.CvPoint2D32f imagePoints1, cxcore.CvPoint2D32f imagePoints2, cxcore.CvPoint3D32f objectPoints, cvaux.CvStereoCamera stereoparams);
	/**
	 * Original signature : <code>int icvStereoCalibration(int, int*, CvSize, CvPoint2D32f*, CvPoint2D32f*, CvPoint3D32f*, CvStereoCamera*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:582</i>
	 */
	int icvStereoCalibration(int numImages, java.nio.IntBuffer nums, cxcore.CvSize.ByValue imageSize, cxcore.CvPoint2D32f imagePoints1, cxcore.CvPoint2D32f imagePoints2, cxcore.CvPoint3D32f objectPoints, cvaux.CvStereoCamera stereoparams);
	/**
	 * Original signature : <code>int icvComputeRestStereoParams(CvStereoCamera*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:592</i>
	 */
	int icvComputeRestStereoParams(cvaux.CvStereoCamera stereoparams);
	/**
	 * Original signature : <code>void cvComputePerspectiveMap(const double[3][3], CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:594</i><br>
	 * @deprecated use the safer methods {@link #cvComputePerspectiveMap(double[], highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr)} and {@link #cvComputePerspectiveMap(java.nio.DoubleBuffer, highgui.HighguiLibrary.CvArr, highgui.HighguiLibrary.CvArr)} instead
	 */
	@java.lang.Deprecated
	void cvComputePerspectiveMap(com.sun.jna.ptr.DoubleByReference coeffs, highgui.HighguiLibrary.CvArr rectMapX, highgui.HighguiLibrary.CvArr rectMapY);
	/**
	 * Original signature : <code>void cvComputePerspectiveMap(const double[3][3], CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:594</i>
	 */
	void cvComputePerspectiveMap(double coeffs[], highgui.HighguiLibrary.CvArr rectMapX, highgui.HighguiLibrary.CvArr rectMapY);
	/**
	 * Original signature : <code>void cvComputePerspectiveMap(const double[3][3], CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:594</i>
	 */
	void cvComputePerspectiveMap(java.nio.DoubleBuffer coeffs, highgui.HighguiLibrary.CvArr rectMapX, highgui.HighguiLibrary.CvArr rectMapY);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:596</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:609</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * Original signature : <code>int icvGetCrossLines(CvPoint3D64f, CvPoint3D64f, CvPoint3D64f, CvPoint3D64f, CvPoint3D64f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:613</i>
	 */
	int icvGetCrossLines(cxcore.CvPoint3D64f.ByValue point11, cxcore.CvPoint3D64f.ByValue point12, cxcore.CvPoint3D64f.ByValue point21, cxcore.CvPoint3D64f.ByValue point22, cxcore.CvPoint3D64f midPoint);
	/**
	 * Original signature : <code>int icvComputeStereoLineCoeffs(CvPoint3D64f, CvPoint3D64f, CvPoint3D64f, double, CvStereoLineCoeff*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:617</i>
	 */
	int icvComputeStereoLineCoeffs(cxcore.CvPoint3D64f.ByValue pointA, cxcore.CvPoint3D64f.ByValue pointB, cxcore.CvPoint3D64f.ByValue pointCam1, double gamma, cvaux.CvStereoLineCoeff coeffs);
	/**
	 * Original signature : <code>int icvGetAngleLine(CvPoint2D64f, CvSize, CvPoint2D64f*, CvPoint2D64f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:633</i>
	 */
	int icvGetAngleLine(cxcore.CvPoint2D64f.ByValue startPoint, cxcore.CvSize.ByValue imageSize, cxcore.CvPoint2D64f point1, cxcore.CvPoint2D64f point2);
	/**
	 * Original signature : <code>void icvGetCoefForPiece(CvPoint2D64f, CvPoint2D64f, double*, double*, double*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:635</i><br>
	 * @deprecated use the safer method {@link #icvGetCoefForPiece(cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f.ByValue, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.DoubleBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void icvGetCoefForPiece(cxcore.CvPoint2D64f.ByValue p_start, cxcore.CvPoint2D64f.ByValue p_end, com.sun.jna.ptr.DoubleByReference a, com.sun.jna.ptr.DoubleByReference b, com.sun.jna.ptr.DoubleByReference c, com.sun.jna.ptr.IntByReference result);
	/**
	 * Original signature : <code>void icvGetCoefForPiece(CvPoint2D64f, CvPoint2D64f, double*, double*, double*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:635</i>
	 */
	void icvGetCoefForPiece(cxcore.CvPoint2D64f.ByValue p_start, cxcore.CvPoint2D64f.ByValue p_end, java.nio.DoubleBuffer a, java.nio.DoubleBuffer b, java.nio.DoubleBuffer c, java.nio.IntBuffer result);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:646</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:652</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:658</i><br>
	 * Conversion Error : CvVect64d
	 */
	/**
	 * Original signature : <code>void icvGetCrossPieceDirect(CvPoint2D64f, CvPoint2D64f, double, double, double, CvPoint2D64f*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:661</i><br>
	 * @deprecated use the safer method {@link #icvGetCrossPieceDirect(cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f.ByValue, double, double, double, cxcore.CvPoint2D64f, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void icvGetCrossPieceDirect(cxcore.CvPoint2D64f.ByValue p_start, cxcore.CvPoint2D64f.ByValue p_end, double a, double b, double c, cxcore.CvPoint2D64f cross, com.sun.jna.ptr.IntByReference result);
	/**
	 * Original signature : <code>void icvGetCrossPieceDirect(CvPoint2D64f, CvPoint2D64f, double, double, double, CvPoint2D64f*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:661</i>
	 */
	void icvGetCrossPieceDirect(cxcore.CvPoint2D64f.ByValue p_start, cxcore.CvPoint2D64f.ByValue p_end, double a, double b, double c, cxcore.CvPoint2D64f cross, java.nio.IntBuffer result);
	/**
	 * Original signature : <code>void icvGetCrossPiecePiece(CvPoint2D64f, CvPoint2D64f, CvPoint2D64f, CvPoint2D64f, CvPoint2D64f*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:665</i><br>
	 * @deprecated use the safer method {@link #icvGetCrossPiecePiece(cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void icvGetCrossPiecePiece(cxcore.CvPoint2D64f.ByValue p1_start, cxcore.CvPoint2D64f.ByValue p1_end, cxcore.CvPoint2D64f.ByValue p2_start, cxcore.CvPoint2D64f.ByValue p2_end, cxcore.CvPoint2D64f cross, com.sun.jna.ptr.IntByReference result);
	/**
	 * Original signature : <code>void icvGetCrossPiecePiece(CvPoint2D64f, CvPoint2D64f, CvPoint2D64f, CvPoint2D64f, CvPoint2D64f*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:665</i>
	 */
	void icvGetCrossPiecePiece(cxcore.CvPoint2D64f.ByValue p1_start, cxcore.CvPoint2D64f.ByValue p1_end, cxcore.CvPoint2D64f.ByValue p2_start, cxcore.CvPoint2D64f.ByValue p2_end, cxcore.CvPoint2D64f cross, java.nio.IntBuffer result);
	/**
	 * Original signature : <code>void icvGetPieceLength(CvPoint2D64f, CvPoint2D64f, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:670</i><br>
	 * @deprecated use the safer method {@link #icvGetPieceLength(cxcore.CvPoint2D64f.ByValue, cxcore.CvPoint2D64f.ByValue, java.nio.DoubleBuffer)} instead
	 */
	@java.lang.Deprecated
	void icvGetPieceLength(cxcore.CvPoint2D64f.ByValue point1, cxcore.CvPoint2D64f.ByValue point2, com.sun.jna.ptr.DoubleByReference dist);
	/**
	 * Original signature : <code>void icvGetPieceLength(CvPoint2D64f, CvPoint2D64f, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:670</i>
	 */
	void icvGetPieceLength(cxcore.CvPoint2D64f.ByValue point1, cxcore.CvPoint2D64f.ByValue point2, java.nio.DoubleBuffer dist);
	/**
	 * Original signature : <code>void icvGetCrossRectDirect(CvSize, double, double, double, CvPoint2D64f*, CvPoint2D64f*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:672</i><br>
	 * @deprecated use the safer method {@link #icvGetCrossRectDirect(cxcore.CvSize.ByValue, double, double, double, cxcore.CvPoint2D64f, cxcore.CvPoint2D64f, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void icvGetCrossRectDirect(cxcore.CvSize.ByValue imageSize, double a, double b, double c, cxcore.CvPoint2D64f start, cxcore.CvPoint2D64f end, com.sun.jna.ptr.IntByReference result);
	/**
	 * Original signature : <code>void icvGetCrossRectDirect(CvSize, double, double, double, CvPoint2D64f*, CvPoint2D64f*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:672</i>
	 */
	void icvGetCrossRectDirect(cxcore.CvSize.ByValue imageSize, double a, double b, double c, cxcore.CvPoint2D64f start, cxcore.CvPoint2D64f end, java.nio.IntBuffer result);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:677</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:681</i><br>
	 * Conversion Error : CvMatr64d
	 */
	/**
	 * Original signature : <code>void icvGetQuadsTransformStruct(CvStereoCamera*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:696</i>
	 */
	void icvGetQuadsTransformStruct(cvaux.CvStereoCamera stereoCamera);
	/**
	 * Original signature : <code>void icvComputeStereoParamsForCameras(CvStereoCamera*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:698</i>
	 */
	void icvComputeStereoParamsForCameras(cvaux.CvStereoCamera stereoCamera);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:700</i><br>
	 * Conversion Error : CvVect64d
	 */
	/**
	 * Original signature : <code>void icvGetMiddleAnglePoint(CvPoint2D64f, CvPoint2D64f, CvPoint2D64f, CvPoint2D64f*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:707</i>
	 */
	void icvGetMiddleAnglePoint(cxcore.CvPoint2D64f.ByValue basePoint, cxcore.CvPoint2D64f.ByValue point1, cxcore.CvPoint2D64f.ByValue point2, cxcore.CvPoint2D64f midPoint);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:711</i><br>
	 * Conversion Error : CvVect64d
	 */
	/**
	 * Original signature : <code>double icvGetVect(CvPoint2D64f, CvPoint2D64f, CvPoint2D64f)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:713</i>
	 */
	double icvGetVect(cxcore.CvPoint2D64f.ByValue basePoint, cxcore.CvPoint2D64f.ByValue point1, cxcore.CvPoint2D64f.ByValue point2);
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:715</i><br>
	 * Conversion Error : CvVect64d
	 */
	/**
	 * <i>native declaration : cvaux\include\cvaux.h:718</i><br>
	 * Conversion Error : CvVect64d
	 */
	/**
	 * Original signature : <code>IplImage* icvCreateIsometricImage(IplImage*, IplImage*, int, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:720</i>
	 */
	cxcore.IplImage icvCreateIsometricImage(cxcore.IplImage src, cxcore.IplImage dst, int desired_depth, int desired_num_channels);
	/**
	 * Original signature : <code>void cvDeInterlace(const CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:723</i>
	 */
	void cvDeInterlace(highgui.HighguiLibrary.CvArr frame, highgui.HighguiLibrary.CvArr fieldEven, highgui.HighguiLibrary.CvArr fieldOdd);
	/**
	 * finds correspondence between two contours<br>
	 * Original signature : <code>CvSeq* cvCalcContoursCorrespondence(const CvSeq*, const CvSeq*, CvMemStorage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:751</i>
	 */
	cxcore.CvSeq cvCalcContoursCorrespondence(cxcore.CvSeq contour1, cxcore.CvSeq contour2, cxcore.CvMemStorage storage);
	/**
	 * morphs contours using the pre-calculated correspondence:<br>
	 * alpha=0 ~ contour1, alpha=1 ~ contour2<br>
	 * Original signature : <code>CvSeq* cvMorphContours(const CvSeq*, const CvSeq*, CvSeq*, double, CvMemStorage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:757</i>
	 */
	cxcore.CvSeq cvMorphContours(cxcore.CvSeq contour1, cxcore.CvSeq contour2, cxcore.CvSeq corr, double alpha, cxcore.CvMemStorage storage);
	/**
	 * Original signature : <code>CvGLCM* cvCreateGLCM(const IplImage*, int, const int*, int, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:790</i><br>
	 * @deprecated use the safer methods {@link #cvCreateGLCM(cxcore.IplImage, int, int[], int, int)} and {@link #cvCreateGLCM(cxcore.IplImage, int, java.nio.IntBuffer, int, int)} instead
	 */
	@java.lang.Deprecated
	cvaux.CvauxLibrary.CvGLCM cvCreateGLCM(cxcore.IplImage srcImage, int stepMagnitude, com.sun.jna.ptr.IntByReference stepDirections, int numStepDirections, int optimizationType);
	/**
	 * Original signature : <code>CvGLCM* cvCreateGLCM(const IplImage*, int, const int*, int, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:790</i>
	 */
	cvaux.CvauxLibrary.CvGLCM cvCreateGLCM(cxcore.IplImage srcImage, int stepMagnitude, int stepDirections[], int numStepDirections, int optimizationType);
	/**
	 * Original signature : <code>CvGLCM* cvCreateGLCM(const IplImage*, int, const int*, int, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:790</i>
	 */
	cvaux.CvauxLibrary.CvGLCM cvCreateGLCM(cxcore.IplImage srcImage, int stepMagnitude, java.nio.IntBuffer stepDirections, int numStepDirections, int optimizationType);
	/**
	 * Original signature : <code>void cvReleaseGLCM(CvGLCM**, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:796</i>
	 */
	void cvReleaseGLCM(com.sun.jna.ptr.PointerByReference GLCM, int flag);
	/**
	 * Original signature : <code>void cvCreateGLCMDescriptors(CvGLCM*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:798</i>
	 */
	void cvCreateGLCMDescriptors(cvaux.CvauxLibrary.CvGLCM destGLCM, int descriptorOptimizationType);
	/**
	 * Original signature : <code>double cvGetGLCMDescriptor(CvGLCM*, int, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:802</i>
	 */
	double cvGetGLCMDescriptor(cvaux.CvauxLibrary.CvGLCM GLCM, int step, int descriptor);
	/**
	 * Original signature : <code>void cvGetGLCMDescriptorStatistics(CvGLCM*, int, double*, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:804</i><br>
	 * @deprecated use the safer method {@link #cvGetGLCMDescriptorStatistics(cvaux.CvauxLibrary.CvGLCM, int, java.nio.DoubleBuffer, java.nio.DoubleBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvGetGLCMDescriptorStatistics(cvaux.CvauxLibrary.CvGLCM GLCM, int descriptor, com.sun.jna.ptr.DoubleByReference average, com.sun.jna.ptr.DoubleByReference standardDeviation);
	/**
	 * Original signature : <code>void cvGetGLCMDescriptorStatistics(CvGLCM*, int, double*, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:804</i>
	 */
	void cvGetGLCMDescriptorStatistics(cvaux.CvauxLibrary.CvGLCM GLCM, int descriptor, java.nio.DoubleBuffer average, java.nio.DoubleBuffer standardDeviation);
	/**
	 * Original signature : <code>IplImage* cvCreateGLCMImage(CvGLCM*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:807</i>
	 */
	cxcore.IplImage cvCreateGLCMImage(cvaux.CvauxLibrary.CvGLCM GLCM, int step);
	/**
	 * Original signature : <code>CvFaceTracker* cvInitFaceTracker(CvFaceTracker*, const IplImage*, CvRect*, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:824</i>
	 */
	cvaux.CvauxLibrary.CvFaceTracker cvInitFaceTracker(cvaux.CvauxLibrary.CvFaceTracker pFaceTracking, cxcore.IplImage imgGray, cxcore.CvRect pRects, int nRects);
	/**
	 * Original signature : <code>int cvTrackFace(CvFaceTracker*, IplImage*, CvRect*, int, CvPoint*, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:826</i><br>
	 * @deprecated use the safer method {@link #cvTrackFace(cvaux.CvauxLibrary.CvFaceTracker, cxcore.IplImage, cxcore.CvRect, int, cxcore.CvPoint, java.nio.DoubleBuffer)} instead
	 */
	@java.lang.Deprecated
	int cvTrackFace(cvaux.CvauxLibrary.CvFaceTracker pFaceTracker, cxcore.IplImage imgGray, cxcore.CvRect pRects, int nRects, cxcore.CvPoint ptRotate, com.sun.jna.ptr.DoubleByReference dbAngleRotate);
	/**
	 * Original signature : <code>int cvTrackFace(CvFaceTracker*, IplImage*, CvRect*, int, CvPoint*, double*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:826</i>
	 */
	int cvTrackFace(cvaux.CvauxLibrary.CvFaceTracker pFaceTracker, cxcore.IplImage imgGray, cxcore.CvRect pRects, int nRects, cxcore.CvPoint ptRotate, java.nio.DoubleBuffer dbAngleRotate);
	/**
	 * Original signature : <code>void cvReleaseFaceTracker(CvFaceTracker**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:829</i>
	 */
	void cvReleaseFaceTracker(com.sun.jna.ptr.PointerByReference ppFaceTracker);
	/**
	 * Original signature : <code>CvSeq* cvFindFace(IplImage*, CvMemStorage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:839</i>
	 */
	cxcore.CvSeq cvFindFace(cxcore.IplImage Image, cxcore.CvMemStorage storage);
	/**
	 * Original signature : <code>CvSeq* cvPostBoostingFindFace(IplImage*, CvMemStorage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:840</i>
	 */
	cxcore.CvSeq cvPostBoostingFindFace(cxcore.IplImage Image, cxcore.CvMemStorage storage);
	/**
	 * Original signature : <code>Cv3dTracker2dTrackedObject cv3dTracker2dTrackedObject(int, CvPoint2D32f)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:855</i>
	 */
	cvaux.Cv3dTracker2dTrackedObject.ByValue cv3dTracker2dTrackedObject(int id, cxcore.CvPoint2D32f.ByValue p);
	/**
	 * Original signature : <code>Cv3dTrackerTrackedObject cv3dTrackerTrackedObject(int, CvPoint3D32f)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:869</i>
	 */
	cvaux.Cv3dTrackerTrackedObject.ByValue cv3dTrackerTrackedObject(int id, cxcore.CvPoint3D32f.ByValue p);
	/**
	 * Original signature : <code>CvBool cv3dTrackerCalibrateCameras(int, const Cv3dTrackerCameraIntrinsics[], CvSize, float, IplImage*[], Cv3dTrackerCameraInfo[])</code><br>
	 * @param camera_intrinsics size is num_cameras<br>
	 * @param samples size is num_cameras<br>
	 * @param camera_info size is num_cameras<br>
	 * <i>native declaration : cvaux\include\cvaux.h:892</i>
	 */
	byte cv3dTrackerCalibrateCameras(int num_cameras, com.sun.jna.Pointer camera_intrinsics, cxcore.CvSize.ByValue etalon_size, float square_size, cxcore.IplImage.ByReference samples[], com.sun.jna.Pointer camera_info);
	/**
	 * Original signature : <code>int cv3dTrackerLocateObjects(int, int, const Cv3dTrackerCameraInfo[], const Cv3dTracker2dTrackedObject[], Cv3dTrackerTrackedObject[])</code><br>
	 * @param camera_info size is num_cameras<br>
	 * @param tracking_info size is num_objects*num_cameras<br>
	 * @param tracked_objects size is num_objects<br>
	 * <i>native declaration : cvaux\include\cvaux.h:899</i>
	 */
	int cv3dTrackerLocateObjects(int num_cameras, int num_objects, com.sun.jna.Pointer camera_info, com.sun.jna.Pointer tracking_info, com.sun.jna.Pointer tracked_objects);
	/**
	 * Computes Voronoi Diagram for given polygons with holes<br>
	 * Original signature : <code>int cvVoronoiDiagramFromContour(CvSeq*, CvVoronoiDiagram2D**, CvMemStorage*, CvLeeParameters, int, int)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:977</i><br>
	 * @param contour_type @see CvLeeParameters
	 */
	int cvVoronoiDiagramFromContour(cxcore.CvSeq ContourSeq, cvaux.CvVoronoiDiagram2D.ByReference VoronoiDiagram[], cxcore.CvMemStorage VoronoiStorage, int contour_type, int contour_orientation, int attempt_number);
	/**
	 * Computes Voronoi Diagram for domains in given image<br>
	 * Original signature : <code>int cvVoronoiDiagramFromImage(IplImage*, CvSeq**, CvVoronoiDiagram2D**, CvMemStorage*, CvLeeParameters, float)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:985</i><br>
	 * @param regularization_method @see CvLeeParameters
	 */
	int cvVoronoiDiagramFromImage(cxcore.IplImage pImage, cxcore.CvSeq.ByReference ContourSeq[], cvaux.CvVoronoiDiagram2D.ByReference VoronoiDiagram[], cxcore.CvMemStorage VoronoiStorage, int regularization_method, float approx_precision);
	/**
	 * Deallocates the storage<br>
	 * Original signature : <code>void cvReleaseVoronoiStorage(CvVoronoiDiagram2D*, CvMemStorage**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:993</i>
	 */
	void cvReleaseVoronoiStorage(cvaux.CvVoronoiDiagram2D VoronoiDiagram, cxcore.CvMemStorage.ByReference pVoronoiStorage[]);
	/**
	 * Computes hybrid model from Voronoi Diagram<br>
	 * Original signature : <code>CvGraph* cvLinearContorModelFromVoronoiDiagram(CvVoronoiDiagram2D*, float)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1018</i>
	 */
	cxcore.CvGraph cvLinearContorModelFromVoronoiDiagram(cvaux.CvVoronoiDiagram2D VoronoiDiagram, float maxWidth);
	/**
	 * Releases hybrid model storage<br>
	 * Original signature : <code>int cvReleaseLinearContorModelStorage(CvGraph**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1022</i>
	 */
	int cvReleaseLinearContorModelStorage(cxcore.CvGraph.ByReference Graph[]);
	/**
	 * Original signature : <code>void cvInitPerspectiveTransform(CvSize, const CvPoint2D32f[4], double[3][3], CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1027</i><br>
	 * @deprecated use the safer method {@link #cvInitPerspectiveTransform(cxcore.CvSize.ByValue, cxcore.CvPoint2D32f[], java.nio.DoubleBuffer, highgui.HighguiLibrary.CvArr)} instead
	 */
	@java.lang.Deprecated
	void cvInitPerspectiveTransform(cxcore.CvSize.ByValue size, com.sun.jna.Pointer vertex, com.sun.jna.ptr.DoubleByReference matrix, highgui.HighguiLibrary.CvArr rectMap);
	/**
	 * Original signature : <code>void cvInitPerspectiveTransform(CvSize, const CvPoint2D32f[4], double[3][3], CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1027</i>
	 */
	void cvInitPerspectiveTransform(cxcore.CvSize.ByValue size, cxcore.CvPoint2D32f vertex[], java.nio.DoubleBuffer matrix, highgui.HighguiLibrary.CvArr rectMap);
	/**
	 * Finds ending points of scanlines on left and right images of stereo-pair<br>
	 * Original signature : <code>void cvMakeScanlines(const CvMatrix3*, CvSize, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1040</i><br>
	 * @deprecated use the safer method {@link #cvMakeScanlines(cvaux.CvauxLibrary.CvMatrix3, cxcore.CvSize.ByValue, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvMakeScanlines(cvaux.CvauxLibrary.CvMatrix3 matrix, cxcore.CvSize.ByValue img_size, com.sun.jna.ptr.IntByReference scanlines1, com.sun.jna.ptr.IntByReference scanlines2, com.sun.jna.ptr.IntByReference lengths1, com.sun.jna.ptr.IntByReference lengths2, com.sun.jna.ptr.IntByReference line_count);
	/**
	 * Finds ending points of scanlines on left and right images of stereo-pair<br>
	 * Original signature : <code>void cvMakeScanlines(const CvMatrix3*, CvSize, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1040</i>
	 */
	void cvMakeScanlines(cvaux.CvauxLibrary.CvMatrix3 matrix, cxcore.CvSize.ByValue img_size, java.nio.IntBuffer scanlines1, java.nio.IntBuffer scanlines2, java.nio.IntBuffer lengths1, java.nio.IntBuffer lengths2, java.nio.IntBuffer line_count);
	/**
	 * Grab pixel values from scanlines and stores them sequentially<br>
	 * (some sort of perspective image transform)<br>
	 * Original signature : <code>void cvPreWarpImage(int, IplImage*, uchar*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1047</i><br>
	 * @deprecated use the safer method {@link #cvPreWarpImage(int, cxcore.IplImage, java.nio.ByteBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvPreWarpImage(int line_count, cxcore.IplImage img, com.sun.jna.ptr.ByteByReference dst, com.sun.jna.ptr.IntByReference dst_nums, com.sun.jna.ptr.IntByReference scanlines);
	/**
	 * Grab pixel values from scanlines and stores them sequentially<br>
	 * (some sort of perspective image transform)<br>
	 * Original signature : <code>void cvPreWarpImage(int, IplImage*, uchar*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1047</i>
	 */
	void cvPreWarpImage(int line_count, cxcore.IplImage img, java.nio.ByteBuffer dst, java.nio.IntBuffer dst_nums, java.nio.IntBuffer scanlines);
	/**
	 * Approximate each grabbed scanline by a sequence of runs<br>
	 * (lossy run-length compression)<br>
	 * Original signature : <code>void cvFindRuns(int, uchar*, uchar*, int*, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1055</i><br>
	 * @deprecated use the safer method {@link #cvFindRuns(int, java.nio.ByteBuffer, java.nio.ByteBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvFindRuns(int line_count, com.sun.jna.ptr.ByteByReference prewarp1, com.sun.jna.ptr.ByteByReference prewarp2, com.sun.jna.ptr.IntByReference line_lengths1, com.sun.jna.ptr.IntByReference line_lengths2, com.sun.jna.ptr.IntByReference runs1, com.sun.jna.ptr.IntByReference runs2, com.sun.jna.ptr.IntByReference num_runs1, com.sun.jna.ptr.IntByReference num_runs2);
	/**
	 * Approximate each grabbed scanline by a sequence of runs<br>
	 * (lossy run-length compression)<br>
	 * Original signature : <code>void cvFindRuns(int, uchar*, uchar*, int*, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1055</i>
	 */
	void cvFindRuns(int line_count, java.nio.ByteBuffer prewarp1, java.nio.ByteBuffer prewarp2, java.nio.IntBuffer line_lengths1, java.nio.IntBuffer line_lengths2, java.nio.IntBuffer runs1, java.nio.IntBuffer runs2, java.nio.IntBuffer num_runs1, java.nio.IntBuffer num_runs2);
	/**
	 * Compares two sets of compressed scanlines<br>
	 * Original signature : <code>void cvDynamicCorrespondMulti(int, int*, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1066</i><br>
	 * @deprecated use the safer method {@link #cvDynamicCorrespondMulti(int, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvDynamicCorrespondMulti(int line_count, com.sun.jna.ptr.IntByReference first, com.sun.jna.ptr.IntByReference first_runs, com.sun.jna.ptr.IntByReference second, com.sun.jna.ptr.IntByReference second_runs, com.sun.jna.ptr.IntByReference first_corr, com.sun.jna.ptr.IntByReference second_corr);
	/**
	 * Compares two sets of compressed scanlines<br>
	 * Original signature : <code>void cvDynamicCorrespondMulti(int, int*, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1066</i>
	 */
	void cvDynamicCorrespondMulti(int line_count, java.nio.IntBuffer first, java.nio.IntBuffer first_runs, java.nio.IntBuffer second, java.nio.IntBuffer second_runs, java.nio.IntBuffer first_corr, java.nio.IntBuffer second_corr);
	/**
	 * Finds scanline ending coordinates for some intermediate "virtual" camera position<br>
	 * Original signature : <code>void cvMakeAlphaScanlines(int*, int*, int*, int*, int, float)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1075</i><br>
	 * @deprecated use the safer method {@link #cvMakeAlphaScanlines(java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, int, float)} instead
	 */
	@java.lang.Deprecated
	void cvMakeAlphaScanlines(com.sun.jna.ptr.IntByReference scanlines1, com.sun.jna.ptr.IntByReference scanlines2, com.sun.jna.ptr.IntByReference scanlinesA, com.sun.jna.ptr.IntByReference lengths, int line_count, float alpha);
	/**
	 * Finds scanline ending coordinates for some intermediate "virtual" camera position<br>
	 * Original signature : <code>void cvMakeAlphaScanlines(int*, int*, int*, int*, int, float)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1075</i>
	 */
	void cvMakeAlphaScanlines(java.nio.IntBuffer scanlines1, java.nio.IntBuffer scanlines2, java.nio.IntBuffer scanlinesA, java.nio.IntBuffer lengths, int line_count, float alpha);
	/**
	 * Blends data of the left and right image scanlines to get<br>
	 * pixel values of "virtual" image scanlines<br>
	 * Original signature : <code>void cvMorphEpilinesMulti(int, uchar*, int*, uchar*, int*, uchar*, int*, float, int*, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1084</i><br>
	 * @deprecated use the safer method {@link #cvMorphEpilinesMulti(int, java.nio.ByteBuffer, java.nio.IntBuffer, java.nio.ByteBuffer, java.nio.IntBuffer, java.nio.ByteBuffer, java.nio.IntBuffer, float, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvMorphEpilinesMulti(int line_count, com.sun.jna.ptr.ByteByReference first_pix, com.sun.jna.ptr.IntByReference first_num, com.sun.jna.ptr.ByteByReference second_pix, com.sun.jna.ptr.IntByReference second_num, com.sun.jna.ptr.ByteByReference dst_pix, com.sun.jna.ptr.IntByReference dst_num, float alpha, com.sun.jna.ptr.IntByReference first, com.sun.jna.ptr.IntByReference first_runs, com.sun.jna.ptr.IntByReference second, com.sun.jna.ptr.IntByReference second_runs, com.sun.jna.ptr.IntByReference first_corr, com.sun.jna.ptr.IntByReference second_corr);
	/**
	 * Blends data of the left and right image scanlines to get<br>
	 * pixel values of "virtual" image scanlines<br>
	 * Original signature : <code>void cvMorphEpilinesMulti(int, uchar*, int*, uchar*, int*, uchar*, int*, float, int*, int*, int*, int*, int*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1084</i>
	 */
	void cvMorphEpilinesMulti(int line_count, java.nio.ByteBuffer first_pix, java.nio.IntBuffer first_num, java.nio.ByteBuffer second_pix, java.nio.IntBuffer second_num, java.nio.ByteBuffer dst_pix, java.nio.IntBuffer dst_num, float alpha, java.nio.IntBuffer first, java.nio.IntBuffer first_runs, java.nio.IntBuffer second, java.nio.IntBuffer second_runs, java.nio.IntBuffer first_corr, java.nio.IntBuffer second_corr);
	/**
	 * Does reverse warping of the morphing result to make<br>
	 * it fill the destination image rectangle<br>
	 * Original signature : <code>void cvPostWarpImage(int, uchar*, int*, IplImage*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1101</i><br>
	 * @deprecated use the safer method {@link #cvPostWarpImage(int, java.nio.ByteBuffer, java.nio.IntBuffer, cxcore.IplImage, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvPostWarpImage(int line_count, com.sun.jna.ptr.ByteByReference src, com.sun.jna.ptr.IntByReference src_nums, cxcore.IplImage img, com.sun.jna.ptr.IntByReference scanlines);
	/**
	 * Does reverse warping of the morphing result to make<br>
	 * it fill the destination image rectangle<br>
	 * Original signature : <code>void cvPostWarpImage(int, uchar*, int*, IplImage*, int*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1101</i>
	 */
	void cvPostWarpImage(int line_count, java.nio.ByteBuffer src, java.nio.IntBuffer src_nums, cxcore.IplImage img, java.nio.IntBuffer scanlines);
	/**
	 * Deletes Moire (missed pixels that appear due to discretization)<br>
	 * Original signature : <code>void cvDeleteMoire(IplImage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1108</i>
	 */
	void cvDeleteMoire(cxcore.IplImage img);
	/**
	 * Releases memory used by BGStatModel<br>
	 * Original signature : <code>void cvReleaseBGStatModel(CvBGStatModel**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1174</i>
	 */
	void cvReleaseBGStatModel(cvaux.CvBGStatModel.ByReference bg_model[]);
	/**
	 * Updates statistical model and returns number of found foreground regions<br>
	 * Original signature : <code>int cvUpdateBGStatModel(IplImage*, CvBGStatModel*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1181</i>
	 */
	int cvUpdateBGStatModel(cxcore.IplImage current_frame, cvaux.CvBGStatModel bg_model);
	/**
	 * bg_model - pointer to CvBGStatModel structure<br>
	 * Original signature : <code>void cvRefineForegroundMaskBySegm(CvSeq*, CvBGStatModel*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1191</i>
	 */
	void cvRefineForegroundMaskBySegm(cxcore.CvSeq segments, cvaux.CvBGStatModel bg_model);
	/**
	 * Common use change detection function<br>
	 * Original signature : <code>int cvChangeDetection(IplImage*, IplImage*, IplImage*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1194</i>
	 */
	int cvChangeDetection(cxcore.IplImage prev_frame, cxcore.IplImage curr_frame, cxcore.IplImage change_mask);
	/**
	 * Creates FGD model<br>
	 * Original signature : <code>CvBGStatModel* cvCreateFGDStatModel(IplImage*, CvFGDStatModelParams*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1307</i>
	 */
	cvaux.CvBGStatModel cvCreateFGDStatModel(cxcore.IplImage first_frame, cvaux.CvFGDStatModelParams parameters);
	/**
	 * Creates Gaussian mixture background model<br>
	 * Original signature : <code>CvBGStatModel* cvCreateGaussianBGModel(IplImage*, CvGaussBGStatModelParams*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1370</i>
	 */
	cvaux.CvBGStatModel cvCreateGaussianBGModel(cxcore.IplImage first_frame, cvaux.CvGaussBGStatModelParams parameters);
	/**
	 * Original signature : <code>CvBGCodeBookModel* cvCreateBGCodeBookModel()</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1399</i>
	 */
	cvaux.CvBGCodeBookModel cvCreateBGCodeBookModel();
	/**
	 * Original signature : <code>void cvReleaseBGCodeBookModel(CvBGCodeBookModel**)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1400</i>
	 */
	void cvReleaseBGCodeBookModel(cvaux.CvBGCodeBookModel.ByReference model[]);
	/**
	 * Original signature : <code>void cvBGCodeBookUpdate(CvBGCodeBookModel*, const CvArr*, CvRect, const CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1402</i>
	 */
	void cvBGCodeBookUpdate(cvaux.CvBGCodeBookModel model, highgui.HighguiLibrary.CvArr image, cxcore.CvRect.ByValue roi, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>int cvBGCodeBookDiff(const CvBGCodeBookModel*, const CvArr*, CvArr*, CvRect)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1406</i>
	 */
	int cvBGCodeBookDiff(cvaux.CvBGCodeBookModel model, highgui.HighguiLibrary.CvArr image, highgui.HighguiLibrary.CvArr fgmask, cxcore.CvRect.ByValue roi);
	/**
	 * Original signature : <code>void cvBGCodeBookClearStale(CvBGCodeBookModel*, int, CvRect, const CvArr*)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1409</i>
	 */
	void cvBGCodeBookClearStale(cvaux.CvBGCodeBookModel model, int staleThresh, cxcore.CvRect.ByValue roi, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>CvSeq* cvSegmentFGMask(CvArr*, int, float, CvMemStorage*, CvPoint)</code><br>
	 * <i>native declaration : cvaux\include\cvaux.h:1413</i>
	 */
	cxcore.CvSeq cvSegmentFGMask(highgui.HighguiLibrary.CvArr fgmask, int poly1Hull0, float perimScale, cxcore.CvMemStorage storage, cxcore.CvPoint.ByValue offset);
	/// Pointer to unknown (opaque) type
	public static class CvMatrix3 extends com.sun.jna.PointerType {
		public CvMatrix3(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvMatrix3() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvFaceTracker extends com.sun.jna.PointerType {
		public CvFaceTracker(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvFaceTracker() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvGLCM extends com.sun.jna.PointerType {
		public CvGLCM(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvGLCM() {
			super();
		}
	}
}
