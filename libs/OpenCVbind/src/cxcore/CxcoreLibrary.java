package cxcore;
/**
 * JNA Wrapper for library <b>cxcore</b><br>
 * @see OpenCV.cxcore<br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.free.fr/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a>, <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface CxcoreLibrary extends com.sun.jna.Library {
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (1 << CV_SEQ_ELTYPE_BITS)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SVD_MODIFY_A = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SVD_SYM = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_USER = 16;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsAutoTrace = -8;
	/// <i>native declaration : cxcore\include\cvver.h</i>
	public static final java.lang.String CV_VERSION = "1.1.0";
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_DEPTH_MAX * CV_CN_MAX - 1)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (0 << CV_SEQ_ELTYPE_BITS)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvFindGraphEdgeByPtr
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SVD_U_T = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_ALIGN_8BYTES = 8;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MAGIC_MASK = -65536;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_ORIGIN_TL = 0;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_DXT_INVERSE = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DEPTH_1U = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DATA_ORDER_PIXEL = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxerror.h</i><br>
	 * goto
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_32S = 4;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_SPARSE_MAT = "opencv-sparse-matrix";
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_COVAR_SCALE = 4;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_TYPE_MASK = 7;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadMemBlock = -214;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_STORAGE_WRITE
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FRONT = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_C = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_MAGIC_VAL = 1117323264;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadStep = -13;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GEMM_B_T = 2;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_BACK_EDGE = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_FLAG_CLOSED | CV_SEQ_POLYLINE)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_RELATIVE = 8;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_NODE_REAL
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvCircle
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_ErrModeParent = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_FORWARD_EDGE = 8;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_MAT = "opencv-matrix";
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DEPTH_8U = 8;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (IPL_DEPTH_SIGN | 8)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CHECK_QUIET = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvFindGraphEdge
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * int
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_CROSS_EDGE = 16;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (2 << CV_SEQ_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_SCRIPT_SIMPLEX = 6;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsFilterOffsetErr = -31;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_MAX_LOCAL_MAT_SIZE = 32;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvTransform
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_SPARSE_MAT_BLOCK = (1 << 12);
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_ORIGIN_BL = 1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadFunc = -6;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_INDEX)
	 */
	/**
	 * define<br>
	 * Conversion Error : null<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxerror.h</i><br>
	 * null < 0
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_CONNECTED_COMP)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_DIFF = 16;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_BORDER_REFLECT_101 = 4;
	/**
	 * define<br>
	 * Conversion Error : cvSetIPLAllocators(iplCreateImageHeader, iplAllocateImage, iplDeallocate, iplCreateROI, iplCloneImage)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvSetIPLAllocators(iplCreateImageHeader, iplAllocateImage, iplDeallocate, iplCreateROI, iplCloneImage)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_DXT_MUL_CONJ = 8;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_IPPCC = 6;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadAlphaChannel = -18;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_IPPCV = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_FLAG_SIMPLE | CV_SEQ_POLYGON)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvFlip
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_PCA_USE_AVG = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_CN_MAX = 64;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_STORAGE_WRITE
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_TREE_NODE_FIELDS(CvSeq)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_TREE_NODE_FIELDS(CvSeq)
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_POS_INF = 2139095040;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadArg = -5;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SVD_V_T = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_32SC2
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_COMPLEX_SMALL = 5;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsVecLengthErr = -28;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_BITS + CV_SEQ_ELTYPE_BITS)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * Conversion Error : cvSlice(0, CV_WHOLE_SEQ_END_INDEX)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * cvSlice(0, CV_WHOLE_SEQ_END_INDEX)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_SEQUENCE_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_SEQUENCE_FIELDS()
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_CURVE | CV_SEQ_ELTYPE_CODE)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsUnsupportedFormat = -210;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * IPL_ALIGN_8BYTES
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadOrigin = -20;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_ALL_ITEMS = -1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadDataPtr = -12;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_DEPTH_MAX - 1)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_TERMCRIT_ITER = 1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadNumChannel1U = -16;
	/**
	 * define<br>
	 * Conversion Error : cvSetImageIOFunctions(cvLoadImage, cvLoadImageM, cvSaveImage, cvShowImage)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvSetImageIOFunctions(cvLoadImage, cvLoadImageM, cvSaveImage, cvShowImage)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_NEW_TREE = 32;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadModelOrChSeq = -14;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_HIST_RANGES_FLAG = (1 << 11);
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_STORAGE_WRITE = 1;
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8U, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8U, 1)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8U, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8U, 4)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8U, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8U, 2)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8U, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8U, 3)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_NO_CN_CHECK = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_POINT3D)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadROISize = -25;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GEMM_C_T = 4;
	/// <i>native declaration : cxcore\include\cvver.h</i>
	public static final int CV_MINOR_VERSION = 1;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_ORIGIN_BL = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_HIST_ARRAY = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (4 << CV_SEQ_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_RAND_NORMAL = 1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsError = -2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DATA_ORDER_PLANE = 1;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_ORIGIN_TL = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_TERMCRIT_EPS = 2;
	/**
	 * define<br>
	 * Conversion Error : CV_SEQUENCE_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_SEQUENCE_FIELDS()
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SET_ELEM_IDX_MASK = ((1 << 26) - 1);
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_MAX_ARR = 10;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_TRIPLEX = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (8 << CV_SEQ_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_SPARSE_HASH_SIZE0 = (1 << 10);
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsDivByZero = -202;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * extern
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadDepth = -17;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_NO_DEPTH_CHECK = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvConvertScale
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_MINMAX = 32;
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16U, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16U, 2)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16U, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16U, 1)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16U, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16U, 4)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16U, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16U, 3)
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_MAX = 16;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsNullPtr = -27;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_GRAPH = "opencv-graph";
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_BIN_TREE | CV_SEQ_ELTYPE_TRIAN_ATR)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_HIST_UNIFORM_FLAG = (1 << 10);
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_64F, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_64F, 1)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_64F, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_64F, 2)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_HIST_SPARSE = 1;
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_64F, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_64F, 3)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_64F, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_64F, 4)
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_NEG_INF = -2139095041;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_DXT_FORWARD = 0;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_REDUCE_MIN = 3;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MAT_MAGIC_VAL = 1111621632;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_EMPTY = 32;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsFilterStructContentErr = -29;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_FORWARD_EDGE_FLAG = (1 << 28);
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_IS_MAT_CONT
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_STR = 3;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_MKL = 8;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvSetZero
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SPARSE_MAT_MAGIC_VAL = 1111752704;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_HIST_MAGIC_VAL = 1111818240;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvRectangle
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_ANY_EDGE = 30;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadImageSize = -10;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_SEQ_TREE = "opencv-sequence-tree";
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadNumChannels = -15;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_NO_SIZE_CHECK = 4;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_ErrModeLeaf = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DEPTH_32F = 32;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_REDUCE_MAX = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_AUTO_STEP = 2147483647;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_STORAGE_MAGIC_VAL = 1116274688;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (IPL_DEPTH_SIGN | 32)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_32F = 5;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_IMAGE_ROI = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_USRTYPE1
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_ELTYPE_CONNECTED_COMP = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MAT_CONT_FLAG_SHIFT = 14;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_MAP = 6;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_HIST_SPARSE
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadCOI = -24;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_AUTOSTEP = 2147483647;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * CV_FONT_HERSHEY_SIMPLEX
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (1 << CV_MAT_TEMP_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_LSQ = 8;
	/**
	 * define<br>
	 * Conversion Error : CV_SET_FIELDS()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_SET_FIELDS()
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (1 << CV_SEQ_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsInplaceNotSupported = -203;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_SEQ = "opencv-sequence";
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CMP_LE = 4;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadFlag = -206;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_HeaderIsNull = -9;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvEllipse
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvGetSubRect
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_DUPLEX = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_MATND = "opencv-nd-matrix";
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadTileSize = -23;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_ELTYPE_GRAPH_EDGE = 0;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_SEARCH_TREE_NODE_FLAG = (1 << 29);
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_MAX_STRLEN = 1024;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DEPTH_64F = 64;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * IPL_ALIGN_4BYTES
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final double CV_LOG2 = 0.6931471805599453;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxmisc.h</i><br>
	 * CV_DEF_INIT_FUNC_TAB_0D
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_CURVE | CV_SEQ_ELTYPE_POINT)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * inline
	 */
	/**
	 * define<br>
	 * Conversion Error : null<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxmisc.h</i><br>
	 * null * crashMe = 0
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_DXT_ROWS = 4;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SORT_ASCENDING = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final double CV_PI = 3.141592653589793;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CMP_NE = 5;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_NAMED = 64;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadOrder = -19;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FILLED = -1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CMP_LT = 3;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_MAX_THREADS = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_REDUCE_AVG = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_ALIGN_16BYTES = 16;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBackTrace = -1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_NORM_MASK = 7;
	/**
	 * define<br>
	 * Conversion Error : throw()<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxmisc.h</i><br>
	 * throw()
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_BORDER_REFLECT = 2;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_COVAR_COLS = 16;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_L1 = 2;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_L2 = 4;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_MAX_INLINE_MAT_OP_SIZE = 10;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxerror.h</i><br>
	 * goto
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_16S = 3;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_INT = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_16U = 2;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_LU = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvTranspose
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_REDUCE_SUM = 0;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_OVER = -1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_BACK = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MATND_MAGIC_VAL = 1111687168;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SET_MAGIC_VAL = 1117257728;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_STORAGE_BLOCK_SIZE = ((1 << 16) - 128);
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (1 << CV_MAT_CONT_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsUnmatchedSizes = -209;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_MaskIsTiled = -26;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_ALIGN_32BYTES = 32;
	/**
	 * define<br>
	 * Conversion Error : cvSlice(0, 0x3FFFFFFF)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * cvSlice(0, 0x3FFFFFFF)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadPoint = -207;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsUnmatchedFormats = -205;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_COMPLEX = 3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * CV_DXT_INV_SCALE
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_NODE_INT
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_BORDER_WRAP = 3;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_SIMPLEX = 0;
	/// <i>native declaration : cxcore\include\cvver.h</i>
	public static final int CV_SUBMINOR_VERSION = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_64F = 6;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (1 << CV_SEQ_FLAG_SHIFT)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_REF = 4;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadMask = -208;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_PCA_DATA_AS_ROW = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_IMAGE_HEADER = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_COVAR_USE_AVG = 2;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsKernelStructContentErr = -30;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DEPTH_SIGN = -2147483648;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_CN_SHIFT = 3;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_DXT_SCALE = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_32SC1
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvDFT
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_ELTYPE_GRAPH_VERTEX = 0;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_PLAIN = 1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsParseError = -212;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_ALIGN_4BYTES = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_SEQ_KIND_GRAPH
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_COVAR_NORMAL = 1;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_IMAGE_DATA = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvGEMM
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_NONE = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_DIFF | CV_L1)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_DIFF | CV_L2)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_KIND_BITS = 3;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_VERTEX = 1;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_SPARSE_HASH_RATIO = 3;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_SEQ_SIMPLE = 256;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvConvertScaleAbs
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_ELTYPE_GENERIC = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_STORAGE_APPEND = 2;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_8UC1
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvInvert
	 */
	/**
	 * define<br>
	 * Conversion Error : (cvSetErrStatus(CV_StsOk))<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxerror.h</i><br>
	 * (cvSetErrStatus(CV_StsOk))
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * ((1 << CV_SEQ_ELTYPE_BITS) - 1)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvPolyLine
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final java.lang.String cvUnsupportedFormat = "Unsupported format";
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_BACKTRACKING = 64;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_USRTYPE1 = 7;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_DIFF | CV_C)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsNoConv = -7;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_BORDER_REPLICATE = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (3 << CV_SEQ_ELTYPE_BITS)
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_MALLOC_ALIGN = 32;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_RELATIVE | CV_L1)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_RELATIVE | CV_L2)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SSE2 = 0;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_1F = 1065353216;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CHECK_RANGE = 1;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_IPPVM = 5;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * int
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (2 << CV_SEQ_ELTYPE_BITS)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8S, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8S, 4)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_32FC3
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_GRAPH | CV_GRAPH_FLAG_ORIENTED)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SORT_DESCENDING = 16;
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8S, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8S, 3)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GEMM_A_T = 1;
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8S, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8S, 2)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_NODE_STR
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_8S, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_8S, 1)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_RELATIVE | CV_C)
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsInternal = -3;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvLine
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SORT_EVERY_ROW = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MAT_TEMP_FLAG_SHIFT = 15;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_WHOLE_SEQ_END_INDEX = 1073741823;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_COVAR_SCRAMBLED = 0;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_STUB_STEP = (1 << 30);
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SORT_EVERY_COLUMN = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_TREE_EDGE = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_ELTYPE_BITS = 9;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxmisc.h</i><br>
	 * float
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (1 << CV_CN_SHIFT)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * (CV_DXT_INVERSE + CV_DXT_SCALE)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16S, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16S, 1)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16S, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16S, 2)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16S, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16S, 3)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_16S, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_16S, 4)
	 */
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_NONE = 0;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsOutOfRange = -211;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_BORDER_CONSTANT = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_SEQ_ELTYPE_PTR
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxmisc.h</i><br>
	 * CV_EXTERN_C
	 */
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsBadSize = -201;
	/// <i>native declaration : cxcore\include\cvver.h</i>
	public static final int CV_MAJOR_VERSION = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_SEQ_POLYGON
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvMahalanobis
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_REAL = 2;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_GRAPH_ITEM_VISITED_FLAG = (1 << 30);
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_DEFAULT_MAT_ROW_ALIGN = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_PCA_DATA_AS_COL = 1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadOffset = -11;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * ((CV_CN_MAX - 1) << CV_CN_SHIFT)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_FLAG_CLOSED | CV_SEQ_CHAIN)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32F, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32F, 4)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32F, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32F, 2)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32F, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32F, 3)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32F, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32F, 1)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MAX_DIM = 32;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_COVAR_ROWS = 8;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsNotImplemented = -213;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_HIST_UNIFORM = 1;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadAlign = -21;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_AA = 16;
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32S, 2)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32S, 2)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32S, 1)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32S, 1)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32S, 4)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32S, 4)
	 */
	/**
	 * define<br>
	 * Conversion Error : CV_MAKETYPE(CV_32S, 3)<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_MAKETYPE(CV_32S, 3)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_STORAGE_READ = 0;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_IPPS = 4;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_SEQ_ELTYPE_TRIAN_ATR = 0;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_OPTCV = 1;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_PLUGIN_IPPI = 3;
	/// <i>native declaration : cxcore\include\cxmisc.h</i>
	public static final int CV_DEFAULT_IMAGE_ROW_ALIGN = 4;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (4 << CV_SEQ_ELTYPE_BITS)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_ErrModeSilent = 2;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final java.lang.String CV_TYPE_NAME_IMAGE = "opencv-image";
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_BadCallBack = -22;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_HERSHEY_SCRIPT_COMPLEX = 7;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsOk = 0;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_MAX_DIM_HEAP = (1 << 16);
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_8S = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (CV_SEQ_KIND_GENERIC | CV_SEQ_ELTYPE_POINT)
	 */
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvCheckArr
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_8U = 0;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_RAND_UNI = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (IPL_DEPTH_SIGN | 16)
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int IPL_DEPTH_16U = 16;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_FLOW = 8;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * (((1 << CV_SEQ_KIND_BITS) - 1) << CV_SEQ_ELTYPE_BITS)
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CMP_EQ = 0;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxtypes.h</i><br>
	 * CV_TERMCRIT_ITER
	 */
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public static final int CV_NODE_SEQ = 5;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_SVD = 1;
	/**
	 * define<br>
	 * SKIPPED:<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i><br>
	 * cvConvertScale
	 */
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CMP_GT = 1;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_FONT_ITALIC = 16;
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public static final int CV_CMP_GE = 2;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsNoMem = -4;
	/// <i>native declaration : cxcore\include\cxerror.h</i>
	public static final int CV_StsObjectNotFound = -204;
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public interface CvIsInstanceFunc extends com.sun.jna.Callback {
		int invoke(com.sun.jna.Pointer struct_ptr);
	}
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public interface CvReleaseFunc extends com.sun.jna.Callback {
		void invoke(com.sun.jna.ptr.PointerByReference struct_dblptr);
	}
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public interface CvReadFunc extends com.sun.jna.Callback {
		com.sun.jna.Pointer invoke(cxcore.CxcoreLibrary.CvFileStorage storage, cxcore.CvFileNode node);
	}
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public interface CvWriteFunc extends com.sun.jna.Callback {
		void invoke(cxcore.CxcoreLibrary.CvFileStorage storage, com.sun.jna.ptr.ByteByReference name, com.sun.jna.Pointer struct_ptr, cxcore.CvAttrList.ByValue attributes);
	}
	/// <i>native declaration : cxcore\include\cxtypes.h</i>
	public interface CvCloneFunc extends com.sun.jna.Callback {
		com.sun.jna.Pointer invoke(com.sun.jna.Pointer struct_ptr);
	}
	/**
	 * a < b ? -1 : a > b ? 1 : 0<br>
	 * <i>native declaration : cxcore\include\cxcore.h</i>
	 */
	public interface CvCmpFunc extends com.sun.jna.Callback {
		int invoke(com.sun.jna.Pointer a, com.sun.jna.Pointer b, com.sun.jna.Pointer userdata);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvErrorCallback extends com.sun.jna.Callback {
		int invoke(int status, com.sun.jna.ptr.ByteByReference func_name, com.sun.jna.ptr.ByteByReference err_msg, com.sun.jna.ptr.ByteByReference file_name, int line, com.sun.jna.Pointer userdata);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvAllocFunc extends com.sun.jna.Callback {
		com.sun.jna.Pointer invoke(com.sun.jna.NativeLong size, com.sun.jna.Pointer userdata);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvFreeFunc extends com.sun.jna.Callback {
		int invoke(com.sun.jna.Pointer pptr, com.sun.jna.Pointer userdata);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface Cv_iplCreateImageHeader extends com.sun.jna.Callback {
		cxcore.IplImage invoke(int int1, int int2, int int3, com.sun.jna.ptr.ByteByReference charPtr1, com.sun.jna.ptr.ByteByReference charPtr2, int int4, int int5, int int6, int int7, int int8, cxcore.IplROI IplROIPtr1, cxcore.IplImage IplImagePtr1, com.sun.jna.Pointer voidPtr1, cxcore.CxcoreLibrary._IplTileInfo IplTileInfoPtr1);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface Cv_iplAllocateImageData extends com.sun.jna.Callback {
		void invoke(cxcore.IplImage IplImagePtr1, int int1, int int2);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface Cv_iplDeallocate extends com.sun.jna.Callback {
		void invoke(cxcore.IplImage IplImagePtr1, int int1);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface Cv_iplCreateROI extends com.sun.jna.Callback {
		cxcore.IplROI invoke(int int1, int int2, int int3, int int4, int int5);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface Cv_iplCloneImage extends com.sun.jna.Callback {
		cxcore.IplImage invoke(cxcore.IplImage IplImagePtr1);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvLoadImageFunc extends com.sun.jna.Callback {
		cxcore.IplImage invoke(com.sun.jna.ptr.ByteByReference filename, int colorness);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvLoadImageMFunc extends com.sun.jna.Callback {
		cxcore.CvMat invoke(com.sun.jna.ptr.ByteByReference filename, int colorness);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvSaveImageFunc extends com.sun.jna.Callback {
		int invoke(com.sun.jna.ptr.ByteByReference filename, highgui.HighguiLibrary.CvArr image);
	}
	/// <i>native declaration : cxcore\include\cxcore.h</i>
	public interface CvShowImageFunc extends com.sun.jna.Callback {
		void invoke(com.sun.jna.ptr.ByteByReference windowname, highgui.HighguiLibrary.CvArr image);
	}
	/**
	 * Original signature : <code>int cvRound(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:172</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvRoundd", "?cvRound@@YAHN@Z"})
	int cvRound(double value);
	/**
	 * Original signature : <code>int cvFloor(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:199</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvFloord", "?cvFloor@@YAHN@Z"})
	int cvFloor(double value);
	/**
	 * Original signature : <code>int cvCeil(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:214</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z6cvCeild", "?cvCeil@@YAHN@Z"})
	int cvCeil(double value);
	/**
	 * Original signature : <code>int cvIsNaN(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:231</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvIsNaNd", "?cvIsNaN@@YAHN@Z"})
	int cvIsNaN(double value);
	/**
	 * Original signature : <code>int cvIsInf(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:242</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvIsInfd", "?cvIsInf@@YAHN@Z"})
	int cvIsInf(double value);
	/**
	 * Original signature : <code>CvRNG cvRNG(int64)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:257</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z5cvRNG7__int64", "?cvRNG@@YA7__int647__int64@Z"})
	long cvRNG(long seed);
	/**
	 * Return random 32-bit unsigned integer:<br>
	 * Original signature : <code>cvRandInt(CvRNG*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:264</i><br>
	 * @deprecated use the safer method {@link #cvRandInt(java.nio.LongBuffer)} instead
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z9cvRandIntP7__int64", "?cvRandInt@@YAXPA7__int64@Z"})
	@java.lang.Deprecated
	int cvRandInt(com.sun.jna.ptr.LongByReference rng);
	/**
	 * Return random 32-bit unsigned integer:<br>
	 * Original signature : <code>cvRandInt(CvRNG*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:264</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z9cvRandIntP7__int64", "?cvRandInt@@YAXPA7__int64@Z"})
	int cvRandInt(java.nio.LongBuffer rng);
	/**
	 * Returns random floating-point number between 0 and 1:<br>
	 * Original signature : <code>double cvRandReal(CvRNG*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:273</i><br>
	 * @deprecated use the safer method {@link #cvRandReal(java.nio.LongBuffer)} instead
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z10cvRandRealP7__int64", "?cvRandReal@@YANPA7__int64@Z"})
	@java.lang.Deprecated
	double cvRandReal(com.sun.jna.ptr.LongByReference rng);
	/**
	 * Returns random floating-point number between 0 and 1:<br>
	 * Original signature : <code>double cvRandReal(CvRNG*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:273</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z10cvRandRealP7__int64", "?cvRandReal@@YANPA7__int64@Z"})
	double cvRandReal(java.nio.LongBuffer rng);
	/**
	 * Inline constructor. No data is allocated internally!!!<br>
	 * (Use together with cvCreateData, or use cvCreateMat instead to<br>
	 * get a matrix with allocated data):<br>
	 * Original signature : <code>CvMat cvMat(int, int, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:575</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z5cvMatiiiPv", "?cvMat@@YAUCvMat@@HHHPAX@Z"})
	cxcore.CvMat.ByValue cvMat(int rows, int cols, int type, com.sun.jna.Pointer data);
	/**
	 * Original signature : <code>double cvmGet(const CvMat*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:605</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z6cvmGetPK5CvMatii", "?cvmGet@@YANPAUCvMat@@HH@Z"})
	double cvmGet(cxcore.CvMat mat, int row, int col);
	/**
	 * Original signature : <code>void cvmSet(CvMat*, int, int, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:622</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z6cvmSetP5CvMatiid", "?cvmSet@@YAXPAUCvMat@@HHN@Z"})
	void cvmSet(cxcore.CvMat mat, int row, int col, double value);
	/**
	 * Original signature : <code>int cvCvToIplDepth(int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:638</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z14cvCvToIplDepthi", "?cvCvToIplDepth@@YAHH@Z"})
	int cvCvToIplDepth(int type);
	/**
	 * Original signature : <code>CvRect cvRect(int, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:800</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z6cvRectiiii", "?cvRect@@YAUCvRect@@HHHH@Z"})
	cxcore.CvRect.ByValue cvRect(int x, int y, int width, int height);
	/**
	 * Original signature : <code>IplROI cvRectToROI(CvRect, int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:813</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z11cvRectToROI6CvRecti", "?cvRectToROI@@YAU_IplROI@@UCvRect@@H@Z"})
	cxcore.IplROI.ByValue cvRectToROI(cxcore.CvRect.ByValue rect, int coi);
	/**
	 * Original signature : <code>CvRect cvROIToRect(IplROI)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:826</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z11cvROIToRect7_IplROI", "?cvROIToRect@@YAUCvRect@@U_IplROI@@@Z"})
	cxcore.CvRect.ByValue cvROIToRect(cxcore.IplROI.ByValue roi);
	/**
	 * Original signature : <code>CvTermCriteria cvTermCriteria(int, int, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:847</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z14cvTermCriteriaiid", "?cvTermCriteria@@YAUCvTermCriteria@@HHN@Z"})
	cxcore.CvTermCriteria.ByValue cvTermCriteria(int type, int max_iter, double epsilon);
	/**
	 * Original signature : <code>CvPoint cvPoint(int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:869</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvPointii", "?cvPoint@@YAUCvPoint@@HH@Z"})
	cxcore.CvPoint.ByValue cvPoint(int x, int y);
	/**
	 * Original signature : <code>CvPoint2D32f cvPoint2D32f(double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:888</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z12cvPoint2D32fdd", "?cvPoint2D32f@@YAUCvPoint2D32f@@NN@Z"})
	cxcore.CvPoint2D32f.ByValue cvPoint2D32f(double x, double y);
	/**
	 * Original signature : <code>CvPoint2D32f cvPointTo32f(CvPoint)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:899</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z12cvPointTo32f7CvPoint", "?cvPointTo32f@@YAUCvPoint2D32f@@UCvPoint@@@Z"})
	cxcore.CvPoint2D32f.ByValue cvPointTo32f(cxcore.CvPoint.ByValue point);
	/**
	 * Original signature : <code>CvPoint cvPointFrom32f(CvPoint2D32f)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:905</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z14cvPointFrom32f12CvPoint2D32f", "?cvPointFrom32f@@YAUCvPoint@@UCvPoint2D32f@@@Z"})
	cxcore.CvPoint.ByValue cvPointFrom32f(cxcore.CvPoint2D32f.ByValue point);
	/**
	 * Original signature : <code>CvPoint3D32f cvPoint3D32f(double, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:924</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z12cvPoint3D32fddd", "?cvPoint3D32f@@YAUCvPoint3D32f@@NNN@Z"})
	cxcore.CvPoint3D32f.ByValue cvPoint3D32f(double x, double y, double z);
	/**
	 * Original signature : <code>CvPoint2D64f cvPoint2D64f(double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:944</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z12cvPoint2D64fdd", "?cvPoint2D64f@@YAUCvPoint2D64f@@NN@Z"})
	cxcore.CvPoint2D64f.ByValue cvPoint2D64f(double x, double y);
	/**
	 * Original signature : <code>CvPoint3D64f cvPoint3D64f(double, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:964</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z12cvPoint3D64fddd", "?cvPoint3D64f@@YAUCvPoint3D64f@@NNN@Z"})
	cxcore.CvPoint3D64f.ByValue cvPoint3D64f(double x, double y, double z);
	/**
	 * Original signature : <code>CvSize cvSize(int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:985</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z6cvSizeii", "?cvSize@@YAUCvSize@@HH@Z"})
	cxcore.CvSize.ByValue cvSize(int width, int height);
	/**
	 * Original signature : <code>CvSize2D32f cvSize2D32f(double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1003</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z11cvSize2D32fdd", "?cvSize2D32f@@YAUCvSize2D32f@@NN@Z"})
	cxcore.CvSize2D32f.ByValue cvSize2D32f(double width, double height);
	/**
	 * Original signature : <code>CvSlice cvSlice(int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1048</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvSliceii", "?cvSlice@@YAUCvSlice@@HH@Z"})
	cxcore.CvSlice.ByValue cvSlice(int start, int end);
	/**
	 * Original signature : <code>CvScalar cvScalar(double, double, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1069</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z8cvScalardddd", "?cvScalar@@YAUCvScalar@@NNNN@Z"})
	cxcore.CvScalar.ByValue cvScalar(double val0, double val1, double val2, double val3);
	/**
	 * Original signature : <code>CvScalar cvRealScalar(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1079</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z12cvRealScalard", "?cvRealScalar@@YAUCvScalar@@N@Z"})
	cxcore.CvScalar.ByValue cvRealScalar(double val0);
	/**
	 * Original signature : <code>CvScalar cvScalarAll(double)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1087</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z11cvScalarAlld", "?cvScalarAll@@YAUCvScalar@@N@Z"})
	cxcore.CvScalar.ByValue cvScalarAll(double val0123);
	/**
	 * Original signature : <code>CvAttrList cvAttrList(const char**, CvAttrList*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1598</i><br>
	 * @deprecated use the safer method {@link #cvAttrList(java.lang.String[], cxcore.CvAttrList)} instead
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z10cvAttrListPPKcP10CvAttrList", "?cvAttrList@@YAUCvAttrList@@PAPADPAUCvAttrList@@@Z"})
	@java.lang.Deprecated
	cxcore.CvAttrList.ByValue cvAttrList(com.sun.jna.ptr.PointerByReference attr, cxcore.CvAttrList next);
	/**
	 * Original signature : <code>CvAttrList cvAttrList(const char**, CvAttrList*)</code><br>
	 * <i>native declaration : cxcore\include\cxtypes.h:1598</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z10cvAttrListPPKcP10CvAttrList", "?cvAttrList@@YAUCvAttrList@@PAPADPAUCvAttrList@@@Z"})
	cxcore.CvAttrList.ByValue cvAttrList(java.lang.String attr[], cxcore.CvAttrList next);
	/**
	 * <malloc> wrapper.<br>
	 * If there is no enough memory, the function<br>
	 * (as well as other OpenCV functions that call cvAlloc)<br>
	 * raises an error.<br>
	 * Original signature : <code>void* cvAlloc(size_t)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:54</i>
	 */
	com.sun.jna.Pointer cvAlloc(com.sun.jna.NativeLong size);
	/**
	 * <free> wrapper.<br>
	 * Here and further all the memory releasing functions<br>
	 * (that all call cvFree) take double pointer in order to<br>
	 * to clear pointer to the data after releasing it.<br>
	 * Passing pointer to NULL pointer is Ok: nothing happens in this case<br>
	 * Original signature : <code>void cvFree_(void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:62</i>
	 */
	void cvFree_(com.sun.jna.Pointer ptr);
	/**
	 * Allocates and initializes IplImage header<br>
	 * Original signature : <code>IplImage* cvCreateImageHeader(CvSize, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:66</i>
	 */
	cxcore.IplImage cvCreateImageHeader(cxcore.CvSize.ByValue size, int depth, int channels);
	/**
	 * Inializes IplImage header<br>
	 * Original signature : <code>IplImage* cvInitImageHeader(IplImage*, CvSize, int, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:69</i>
	 */
	cxcore.IplImage cvInitImageHeader(cxcore.IplImage image, cxcore.CvSize.ByValue size, int depth, int channels, int origin, int align);
	/**
	 * Creates IPL image (header and data)<br>
	 * Original signature : <code>IplImage* cvCreateImage(CvSize, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:74</i>
	 */
	cxcore.IplImage cvCreateImage(cxcore.CvSize.ByValue size, int depth, int channels);
	/**
	 * Releases (i.e. deallocates) IPL image header<br>
	 * Original signature : <code>void cvReleaseImageHeader(IplImage**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:77</i>
	 */
	void cvReleaseImageHeader(cxcore.IplImage.ByReference image[]);
	/**
	 * Releases IPL image header and data<br>
	 * Original signature : <code>void cvReleaseImage(IplImage**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:80</i>
	 */
	void cvReleaseImage(cxcore.IplImage.ByReference image[]);
	/**
	 * Creates a copy of IPL image (widthStep may differ)<br>
	 * Original signature : <code>IplImage* cvCloneImage(const IplImage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:83</i>
	 */
	cxcore.IplImage cvCloneImage(cxcore.IplImage image);
	/**
	 * Sets a Channel Of Interest (only a few functions support COI) -<br>
	 * use cvCopy to extract the selected channel and/or put it back<br>
	 * Original signature : <code>void cvSetImageCOI(IplImage*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:87</i>
	 */
	void cvSetImageCOI(cxcore.IplImage image, int coi);
	/**
	 * Retrieves image Channel Of Interest<br>
	 * Original signature : <code>int cvGetImageCOI(const IplImage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:90</i>
	 */
	int cvGetImageCOI(cxcore.IplImage image);
	/**
	 * Sets image ROI (region of interest) (COI is not changed)<br>
	 * Original signature : <code>void cvSetImageROI(IplImage*, CvRect)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:93</i>
	 */
	void cvSetImageROI(cxcore.IplImage image, cxcore.CvRect.ByValue rect);
	/**
	 * Resets image ROI and COI<br>
	 * Original signature : <code>void cvResetImageROI(IplImage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:96</i>
	 */
	void cvResetImageROI(cxcore.IplImage image);
	/**
	 * Retrieves image ROI<br>
	 * Original signature : <code>CvRect cvGetImageROI(const IplImage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:99</i>
	 */
	cxcore.CvRect.ByValue cvGetImageROI(cxcore.IplImage image);
	/**
	 * Allocates and initalizes CvMat header<br>
	 * Original signature : <code>CvMat* cvCreateMatHeader(int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:102</i>
	 */
	cxcore.CvMat cvCreateMatHeader(int rows, int cols, int type);
	/**
	 * Initializes CvMat header<br>
	 * Original signature : <code>CvMat* cvInitMatHeader(CvMat*, int, int, int, void*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:107</i>
	 */
	cxcore.CvMat cvInitMatHeader(cxcore.CvMat mat, int rows, int cols, int type, com.sun.jna.Pointer data, int step);
	/**
	 * Allocates and initializes CvMat header and allocates data<br>
	 * Original signature : <code>CvMat* cvCreateMat(int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:112</i>
	 */
	cxcore.CvMat cvCreateMat(int rows, int cols, int type);
	/**
	 * Releases CvMat header and deallocates matrix data<br>
	 * (reference counting is used for data)<br>
	 * Original signature : <code>void cvReleaseMat(CvMat**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:116</i>
	 */
	void cvReleaseMat(cxcore.CvMat.ByReference mat[]);
	/**
	 * Decrements CvMat data reference counter and deallocates the data if<br>
	 * it reaches 0<br>
	 * Original signature : <code>void cvDecRefData(CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:120</i>
	 */
	void cvDecRefData(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Increments CvMat data reference counter<br>
	 * Original signature : <code>int cvIncRefData(CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:141</i>
	 */
	int cvIncRefData(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Creates an exact copy of the input matrix (except, may be, step value)<br>
	 * Original signature : <code>CvMat* cvCloneMat(const CvMat*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:161</i>
	 */
	cxcore.CvMat cvCloneMat(cxcore.CvMat mat);
	/**
	 * Makes a new matrix from <rect> subrectangle of input array.<br>
	 * No data is copied<br>
	 * Original signature : <code>CvMat* cvGetSubRect(const CvArr*, CvMat*, CvRect)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:166</i>
	 */
	cxcore.CvMat cvGetSubRect(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat submat, cxcore.CvRect.ByValue rect);
	/**
	 * Selects row span of the input array: arr(start_row:delta_row:end_row,:)<br>
	 * (end_row is not included into the span).<br>
	 * Original signature : <code>CvMat* cvGetRows(const CvArr*, CvMat*, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:171</i>
	 */
	cxcore.CvMat cvGetRows(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat submat, int start_row, int end_row, int delta_row);
	/**
	 * Original signature : <code>CvMat* cvGetRow(const CvArr*, CvMat*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:175</i>
	 */
	cxcore.CvMat cvGetRow(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat submat, int row);
	/**
	 * Selects column span of the input array: arr(:,start_col:end_col)<br>
	 * (end_col is not included into the span)<br>
	 * Original signature : <code>CvMat* cvGetCols(const CvArr*, CvMat*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:183</i>
	 */
	cxcore.CvMat cvGetCols(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat submat, int start_col, int end_col);
	/**
	 * Original signature : <code>CvMat* cvGetCol(const CvArr*, CvMat*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:186</i>
	 */
	cxcore.CvMat cvGetCol(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat submat, int col);
	/**
	 * Select a diagonal of the input array.<br>
	 * (diag = 0 means the main diagonal, >0 means a diagonal above the main one,<br>
	 * <0 - below the main one).<br>
	 * The diagonal will be represented as a column (nx1 matrix).<br>
	 * Original signature : <code>CvMat* cvGetDiag(const CvArr*, CvMat*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:195</i>
	 */
	cxcore.CvMat cvGetDiag(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat submat, int diag);
	/**
	 * low-level scalar <-> raw data conversion functions<br>
	 * Original signature : <code>void cvScalarToRawData(const CvScalar*, void*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:199</i>
	 */
	void cvScalarToRawData(cxcore.CvScalar scalar, com.sun.jna.Pointer data, int type, int extend_to_12);
	/**
	 * Original signature : <code>void cvRawDataToScalar(const void*, int, CvScalar*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:202</i>
	 */
	void cvRawDataToScalar(com.sun.jna.Pointer data, int type, cxcore.CvScalar scalar);
	/**
	 * Allocates and initializes CvMatND header<br>
	 * Original signature : <code>CvMatND* cvCreateMatNDHeader(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:205</i><br>
	 * @deprecated use the safer methods {@link #cvCreateMatNDHeader(int, int[], int)} and {@link #cvCreateMatNDHeader(int, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvMatND cvCreateMatNDHeader(int dims, com.sun.jna.ptr.IntByReference sizes, int type);
	/**
	 * Allocates and initializes CvMatND header<br>
	 * Original signature : <code>CvMatND* cvCreateMatNDHeader(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:205</i>
	 */
	cxcore.CvMatND cvCreateMatNDHeader(int dims, int sizes[], int type);
	/**
	 * Allocates and initializes CvMatND header<br>
	 * Original signature : <code>CvMatND* cvCreateMatNDHeader(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:205</i>
	 */
	cxcore.CvMatND cvCreateMatNDHeader(int dims, java.nio.IntBuffer sizes, int type);
	/**
	 * Allocates and initializes CvMatND header and allocates data<br>
	 * Original signature : <code>CvMatND* cvCreateMatND(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:208</i><br>
	 * @deprecated use the safer methods {@link #cvCreateMatND(int, int[], int)} and {@link #cvCreateMatND(int, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvMatND cvCreateMatND(int dims, com.sun.jna.ptr.IntByReference sizes, int type);
	/**
	 * Allocates and initializes CvMatND header and allocates data<br>
	 * Original signature : <code>CvMatND* cvCreateMatND(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:208</i>
	 */
	cxcore.CvMatND cvCreateMatND(int dims, int sizes[], int type);
	/**
	 * Allocates and initializes CvMatND header and allocates data<br>
	 * Original signature : <code>CvMatND* cvCreateMatND(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:208</i>
	 */
	cxcore.CvMatND cvCreateMatND(int dims, java.nio.IntBuffer sizes, int type);
	/**
	 * Initializes preallocated CvMatND header<br>
	 * Original signature : <code>CvMatND* cvInitMatNDHeader(CvMatND*, int, const int*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:211</i><br>
	 * @deprecated use the safer methods {@link #cvInitMatNDHeader(cxcore.CvMatND, int, int[], int, com.sun.jna.Pointer)} and {@link #cvInitMatNDHeader(cxcore.CvMatND, int, java.nio.IntBuffer, int, com.sun.jna.Pointer)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvMatND cvInitMatNDHeader(cxcore.CvMatND mat, int dims, com.sun.jna.ptr.IntByReference sizes, int type, com.sun.jna.Pointer data);
	/**
	 * Initializes preallocated CvMatND header<br>
	 * Original signature : <code>CvMatND* cvInitMatNDHeader(CvMatND*, int, const int*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:211</i>
	 */
	cxcore.CvMatND cvInitMatNDHeader(cxcore.CvMatND mat, int dims, int sizes[], int type, com.sun.jna.Pointer data);
	/**
	 * Initializes preallocated CvMatND header<br>
	 * Original signature : <code>CvMatND* cvInitMatNDHeader(CvMatND*, int, const int*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:211</i>
	 */
	cxcore.CvMatND cvInitMatNDHeader(cxcore.CvMatND mat, int dims, java.nio.IntBuffer sizes, int type, com.sun.jna.Pointer data);
	/**
	 * Releases CvMatND<br>
	 * Original signature : <code>void cvReleaseMatND(CvMatND**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:215</i>
	 */
	void cvReleaseMatND(cxcore.CvMatND.ByReference mat[]);
	/**
	 * Creates a copy of CvMatND (except, may be, steps)<br>
	 * Original signature : <code>CvMatND* cvCloneMatND(const CvMatND*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:221</i>
	 */
	cxcore.CvMatND cvCloneMatND(cxcore.CvMatND mat);
	/**
	 * Allocates and initializes CvSparseMat header and allocates data<br>
	 * Original signature : <code>CvSparseMat* cvCreateSparseMat(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:224</i><br>
	 * @deprecated use the safer methods {@link #cvCreateSparseMat(int, int[], int)} and {@link #cvCreateSparseMat(int, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvSparseMat cvCreateSparseMat(int dims, com.sun.jna.ptr.IntByReference sizes, int type);
	/**
	 * Allocates and initializes CvSparseMat header and allocates data<br>
	 * Original signature : <code>CvSparseMat* cvCreateSparseMat(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:224</i>
	 */
	cxcore.CvSparseMat cvCreateSparseMat(int dims, int sizes[], int type);
	/**
	 * Allocates and initializes CvSparseMat header and allocates data<br>
	 * Original signature : <code>CvSparseMat* cvCreateSparseMat(int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:224</i>
	 */
	cxcore.CvSparseMat cvCreateSparseMat(int dims, java.nio.IntBuffer sizes, int type);
	/**
	 * Releases CvSparseMat<br>
	 * Original signature : <code>void cvReleaseSparseMat(CvSparseMat**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:227</i>
	 */
	void cvReleaseSparseMat(cxcore.CvSparseMat.ByReference mat[]);
	/**
	 * Creates a copy of CvSparseMat (except, may be, zero items)<br>
	 * Original signature : <code>CvSparseMat* cvCloneSparseMat(const CvSparseMat*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:230</i>
	 */
	cxcore.CvSparseMat cvCloneSparseMat(cxcore.CvSparseMat mat);
	/**
	 * Initializes sparse array iterator<br>
	 * (returns the first node or NULL if the array is empty)<br>
	 * Original signature : <code>CvSparseNode* cvInitSparseMatIterator(const CvSparseMat*, CvSparseMatIterator*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:234</i>
	 */
	cxcore.CvSparseNode cvInitSparseMatIterator(cxcore.CvSparseMat mat, cxcore.CvSparseMatIterator mat_iterator);
	/**
	 * returns next sparse array node (or NULL if there is no more nodes)<br>
	 * Original signature : <code>CvSparseNode* cvGetNextSparseNode(CvSparseMatIterator*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:238</i>
	 */
	cxcore.CvSparseNode cvGetNextSparseNode(cxcore.CvSparseMatIterator mat_iterator);
	/**
	 * initializes iterator that traverses through several arrays simulteneously<br>
	 * (the function together with cvNextArraySlice is used for<br>
	 * N-ari element-wise operations)<br>
	 * Original signature : <code>int cvInitNArrayIterator(int, CvArr**, const CvArr*, CvMatND*, CvNArrayIterator*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:281</i>
	 */
	int cvInitNArrayIterator(int count, com.sun.jna.ptr.PointerByReference arrs, highgui.HighguiLibrary.CvArr mask, cxcore.CvMatND stubs, cxcore.CvNArrayIterator array_iterator, int flags);
	/**
	 * returns zero value if iteration is finished, non-zero (slice length) otherwise<br>
	 * Original signature : <code>int cvNextNArraySlice(CvNArrayIterator*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:287</i>
	 */
	int cvNextNArraySlice(cxcore.CvNArrayIterator array_iterator);
	/**
	 * Returns type of array elements:<br>
	 * CV_8UC1 ... CV_64FC4 ...<br>
	 * Original signature : <code>int cvGetElemType(const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:292</i>
	 */
	int cvGetElemType(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Retrieves number of an array dimensions and<br>
	 * optionally sizes of the dimensions<br>
	 * Original signature : <code>int cvGetDims(const CvArr*, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:296</i><br>
	 * @deprecated use the safer method {@link #cvGetDims(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	int cvGetDims(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference sizes);
	/**
	 * Retrieves number of an array dimensions and<br>
	 * optionally sizes of the dimensions<br>
	 * Original signature : <code>int cvGetDims(const CvArr*, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:296</i>
	 */
	int cvGetDims(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer sizes);
	/**
	 * Retrieves size of a particular array dimension.<br>
	 * For 2d arrays cvGetDimSize(arr,0) returns number of rows (image height)<br>
	 * and cvGetDimSize(arr,1) returns number of columns (image width)<br>
	 * Original signature : <code>int cvGetDimSize(const CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:302</i>
	 */
	int cvGetDimSize(highgui.HighguiLibrary.CvArr arr, int index);
	/**
	 * ptr = &arr(idx0,idx1,...). All indexes are zero-based,<br>
	 * the major dimensions go first (e.g. (y,x) for 2D, (z,y,x) for 3D<br>
	 * Original signature : <code>uchar* cvPtr1D(const CvArr*, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:307</i><br>
	 * @deprecated use the safer method {@link #cvPtr1D(highgui.HighguiLibrary.CvArr, int, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvPtr1D(highgui.HighguiLibrary.CvArr arr, int idx0, com.sun.jna.ptr.IntByReference type);
	/**
	 * ptr = &arr(idx0,idx1,...). All indexes are zero-based,<br>
	 * the major dimensions go first (e.g. (y,x) for 2D, (z,y,x) for 3D<br>
	 * Original signature : <code>uchar* cvPtr1D(const CvArr*, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:307</i>
	 */
	com.sun.jna.ptr.ByteByReference cvPtr1D(highgui.HighguiLibrary.CvArr arr, int idx0, java.nio.IntBuffer type);
	/**
	 * Original signature : <code>uchar* cvPtr2D(const CvArr*, int, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:308</i><br>
	 * @deprecated use the safer method {@link #cvPtr2D(highgui.HighguiLibrary.CvArr, int, int, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvPtr2D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, com.sun.jna.ptr.IntByReference type);
	/**
	 * Original signature : <code>uchar* cvPtr2D(const CvArr*, int, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:308</i>
	 */
	com.sun.jna.ptr.ByteByReference cvPtr2D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, java.nio.IntBuffer type);
	/**
	 * Original signature : <code>uchar* cvPtr3D(const CvArr*, int, int, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:309</i><br>
	 * @deprecated use the safer method {@link #cvPtr3D(highgui.HighguiLibrary.CvArr, int, int, int, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvPtr3D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, int idx2, com.sun.jna.ptr.IntByReference type);
	/**
	 * Original signature : <code>uchar* cvPtr3D(const CvArr*, int, int, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:309</i>
	 */
	com.sun.jna.ptr.ByteByReference cvPtr3D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, int idx2, java.nio.IntBuffer type);
	/**
	 * For CvMat or IplImage number of indices should be 2<br>
	 * (row index (y) goes first, column index (x) goes next).<br>
	 * For CvMatND or CvSparseMat number of infices should match number of <dims> and<br>
	 * indices order should match the array dimension order.<br>
	 * Original signature : <code>uchar* cvPtrND(const CvArr*, const int*, int*, int, unsigned*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:316</i><br>
	 * @deprecated use the safer methods {@link #cvPtrND(highgui.HighguiLibrary.CvArr, int[], java.nio.IntBuffer, int, java.nio.IntBuffer)} and {@link #cvPtrND(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer, java.nio.IntBuffer, int, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvPtrND(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference idx, com.sun.jna.ptr.IntByReference type, int create_node, com.sun.jna.ptr.IntByReference precalc_hashval);
	/**
	 * For CvMat or IplImage number of indices should be 2<br>
	 * (row index (y) goes first, column index (x) goes next).<br>
	 * For CvMatND or CvSparseMat number of infices should match number of <dims> and<br>
	 * indices order should match the array dimension order.<br>
	 * Original signature : <code>uchar* cvPtrND(const CvArr*, const int*, int*, int, unsigned*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:316</i>
	 */
	com.sun.jna.ptr.ByteByReference cvPtrND(highgui.HighguiLibrary.CvArr arr, int idx[], java.nio.IntBuffer type, int create_node, java.nio.IntBuffer precalc_hashval);
	/**
	 * For CvMat or IplImage number of indices should be 2<br>
	 * (row index (y) goes first, column index (x) goes next).<br>
	 * For CvMatND or CvSparseMat number of infices should match number of <dims> and<br>
	 * indices order should match the array dimension order.<br>
	 * Original signature : <code>uchar* cvPtrND(const CvArr*, const int*, int*, int, unsigned*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:316</i>
	 */
	com.sun.jna.ptr.ByteByReference cvPtrND(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer idx, java.nio.IntBuffer type, int create_node, java.nio.IntBuffer precalc_hashval);
	/**
	 * value = arr(idx0,idx1,...)<br>
	 * Original signature : <code>CvScalar cvGet1D(const CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:321</i>
	 */
	cxcore.CvScalar.ByValue cvGet1D(highgui.HighguiLibrary.CvArr arr, int idx0);
	/**
	 * Original signature : <code>CvScalar cvGet2D(const CvArr*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:322</i>
	 */
	cxcore.CvScalar.ByValue cvGet2D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1);
	/**
	 * Original signature : <code>CvScalar cvGet3D(const CvArr*, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:323</i>
	 */
	cxcore.CvScalar.ByValue cvGet3D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, int idx2);
	/**
	 * Original signature : <code>CvScalar cvGetND(const CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:324</i><br>
	 * @deprecated use the safer methods {@link #cvGetND(highgui.HighguiLibrary.CvArr, int[])} and {@link #cvGetND(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvScalar.ByValue cvGetND(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference idx);
	/**
	 * Original signature : <code>CvScalar cvGetND(const CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:324</i>
	 */
	cxcore.CvScalar.ByValue cvGetND(highgui.HighguiLibrary.CvArr arr, int idx[]);
	/**
	 * Original signature : <code>CvScalar cvGetND(const CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:324</i>
	 */
	cxcore.CvScalar.ByValue cvGetND(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer idx);
	/**
	 * for 1-channel arrays<br>
	 * Original signature : <code>double cvGetReal1D(const CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:327</i>
	 */
	double cvGetReal1D(highgui.HighguiLibrary.CvArr arr, int idx0);
	/**
	 * Original signature : <code>double cvGetReal2D(const CvArr*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:328</i>
	 */
	double cvGetReal2D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1);
	/**
	 * Original signature : <code>double cvGetReal3D(const CvArr*, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:329</i>
	 */
	double cvGetReal3D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, int idx2);
	/**
	 * Original signature : <code>double cvGetRealND(const CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:330</i><br>
	 * @deprecated use the safer methods {@link #cvGetRealND(highgui.HighguiLibrary.CvArr, int[])} and {@link #cvGetRealND(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	double cvGetRealND(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference idx);
	/**
	 * Original signature : <code>double cvGetRealND(const CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:330</i>
	 */
	double cvGetRealND(highgui.HighguiLibrary.CvArr arr, int idx[]);
	/**
	 * Original signature : <code>double cvGetRealND(const CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:330</i>
	 */
	double cvGetRealND(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer idx);
	/**
	 * arr(idx0,idx1,...) = value<br>
	 * Original signature : <code>void cvSet1D(CvArr*, int, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:333</i>
	 */
	void cvSet1D(highgui.HighguiLibrary.CvArr arr, int idx0, cxcore.CvScalar.ByValue value);
	/**
	 * Original signature : <code>void cvSet2D(CvArr*, int, int, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:334</i>
	 */
	void cvSet2D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, cxcore.CvScalar.ByValue value);
	/**
	 * Original signature : <code>void cvSet3D(CvArr*, int, int, int, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:335</i>
	 */
	void cvSet3D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, int idx2, cxcore.CvScalar.ByValue value);
	/**
	 * Original signature : <code>void cvSetND(CvArr*, const int*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:336</i><br>
	 * @deprecated use the safer methods {@link #cvSetND(highgui.HighguiLibrary.CvArr, int[], cxcore.CvScalar.ByValue)} and {@link #cvSetND(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer, cxcore.CvScalar.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvSetND(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference idx, cxcore.CvScalar.ByValue value);
	/**
	 * Original signature : <code>void cvSetND(CvArr*, const int*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:336</i>
	 */
	void cvSetND(highgui.HighguiLibrary.CvArr arr, int idx[], cxcore.CvScalar.ByValue value);
	/**
	 * Original signature : <code>void cvSetND(CvArr*, const int*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:336</i>
	 */
	void cvSetND(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer idx, cxcore.CvScalar.ByValue value);
	/**
	 * for 1-channel arrays<br>
	 * Original signature : <code>void cvSetReal1D(CvArr*, int, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:339</i>
	 */
	void cvSetReal1D(highgui.HighguiLibrary.CvArr arr, int idx0, double value);
	/**
	 * Original signature : <code>void cvSetReal2D(CvArr*, int, int, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:340</i>
	 */
	void cvSetReal2D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, double value);
	/**
	 * Original signature : <code>void cvSetReal3D(CvArr*, int, int, int, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:341</i>
	 */
	void cvSetReal3D(highgui.HighguiLibrary.CvArr arr, int idx0, int idx1, int idx2, double value);
	/**
	 * Original signature : <code>void cvSetRealND(CvArr*, const int*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:343</i><br>
	 * @deprecated use the safer methods {@link #cvSetRealND(highgui.HighguiLibrary.CvArr, int[], double)} and {@link #cvSetRealND(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer, double)} instead
	 */
	@java.lang.Deprecated
	void cvSetRealND(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference idx, double value);
	/**
	 * Original signature : <code>void cvSetRealND(CvArr*, const int*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:343</i>
	 */
	void cvSetRealND(highgui.HighguiLibrary.CvArr arr, int idx[], double value);
	/**
	 * Original signature : <code>void cvSetRealND(CvArr*, const int*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:343</i>
	 */
	void cvSetRealND(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer idx, double value);
	/**
	 * clears element of ND dense array,<br>
	 * in case of sparse arrays it deletes the specified node<br>
	 * Original signature : <code>void cvClearND(CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:347</i><br>
	 * @deprecated use the safer methods {@link #cvClearND(highgui.HighguiLibrary.CvArr, int[])} and {@link #cvClearND(highgui.HighguiLibrary.CvArr, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvClearND(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.IntByReference idx);
	/**
	 * clears element of ND dense array,<br>
	 * in case of sparse arrays it deletes the specified node<br>
	 * Original signature : <code>void cvClearND(CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:347</i>
	 */
	void cvClearND(highgui.HighguiLibrary.CvArr arr, int idx[]);
	/**
	 * clears element of ND dense array,<br>
	 * in case of sparse arrays it deletes the specified node<br>
	 * Original signature : <code>void cvClearND(CvArr*, const int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:347</i>
	 */
	void cvClearND(highgui.HighguiLibrary.CvArr arr, java.nio.IntBuffer idx);
	/**
	 * Converts CvArr (IplImage or CvMat,...) to CvMat.<br>
	 * If the last parameter is non-zero, function can<br>
	 * convert multi(>2)-dimensional array to CvMat as long as<br>
	 * the last array's dimension is continous. The resultant<br>
	 * matrix will be have appropriate (a huge) number of rows<br>
	 * Original signature : <code>CvMat* cvGetMat(const CvArr*, CvMat*, int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:354</i><br>
	 * @deprecated use the safer method {@link #cvGetMat(highgui.HighguiLibrary.CvArr, cxcore.CvMat, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvMat cvGetMat(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat header, com.sun.jna.ptr.IntByReference coi, int allowND);
	/**
	 * Converts CvArr (IplImage or CvMat,...) to CvMat.<br>
	 * If the last parameter is non-zero, function can<br>
	 * convert multi(>2)-dimensional array to CvMat as long as<br>
	 * the last array's dimension is continous. The resultant<br>
	 * matrix will be have appropriate (a huge) number of rows<br>
	 * Original signature : <code>CvMat* cvGetMat(const CvArr*, CvMat*, int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:354</i>
	 */
	cxcore.CvMat cvGetMat(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat header, java.nio.IntBuffer coi, int allowND);
	/**
	 * Converts CvArr (IplImage or CvMat) to IplImage<br>
	 * Original signature : <code>IplImage* cvGetImage(const CvArr*, IplImage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:359</i>
	 */
	cxcore.IplImage cvGetImage(highgui.HighguiLibrary.CvArr arr, cxcore.IplImage image_header);
	/**
	 * Changes a shape of multi-dimensional array.<br>
	 * new_cn == 0 means that number of channels remains unchanged.<br>
	 * new_dims == 0 means that number and sizes of dimensions remain the same<br>
	 * (unless they need to be changed to set the new number of channels)<br>
	 * if new_dims == 1, there is no need to specify new dimension sizes<br>
	 * The resultant configuration should be achievable w/o data copying.<br>
	 * If the resultant array is sparse, CvSparseMat header should be passed<br>
	 * to the function else if the result is 1 or 2 dimensional,<br>
	 * CvMat header should be passed to the function<br>
	 * else CvMatND header should be passed<br>
	 * Original signature : <code>CvArr* cvReshapeMatND(const CvArr*, int, CvArr*, int, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:372</i><br>
	 * @deprecated use the safer method {@link #cvReshapeMatND(highgui.HighguiLibrary.CvArr, int, highgui.HighguiLibrary.CvArr, int, int, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	highgui.HighguiLibrary.CvArr cvReshapeMatND(highgui.HighguiLibrary.CvArr arr, int sizeof_header, highgui.HighguiLibrary.CvArr header, int new_cn, int new_dims, com.sun.jna.ptr.IntByReference new_sizes);
	/**
	 * Changes a shape of multi-dimensional array.<br>
	 * new_cn == 0 means that number of channels remains unchanged.<br>
	 * new_dims == 0 means that number and sizes of dimensions remain the same<br>
	 * (unless they need to be changed to set the new number of channels)<br>
	 * if new_dims == 1, there is no need to specify new dimension sizes<br>
	 * The resultant configuration should be achievable w/o data copying.<br>
	 * If the resultant array is sparse, CvSparseMat header should be passed<br>
	 * to the function else if the result is 1 or 2 dimensional,<br>
	 * CvMat header should be passed to the function<br>
	 * else CvMatND header should be passed<br>
	 * Original signature : <code>CvArr* cvReshapeMatND(const CvArr*, int, CvArr*, int, int, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:372</i>
	 */
	highgui.HighguiLibrary.CvArr cvReshapeMatND(highgui.HighguiLibrary.CvArr arr, int sizeof_header, highgui.HighguiLibrary.CvArr header, int new_cn, int new_dims, java.nio.IntBuffer new_sizes);
	/**
	 * Original signature : <code>CvMat* cvReshape(const CvArr*, CvMat*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:380</i>
	 */
	cxcore.CvMat cvReshape(highgui.HighguiLibrary.CvArr arr, cxcore.CvMat header, int new_cn, int new_rows);
	/**
	 * Repeats source 2d array several times in both horizontal and<br>
	 * vertical direction to fill destination array<br>
	 * Original signature : <code>void cvRepeat(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:385</i>
	 */
	void cvRepeat(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Allocates array data<br>
	 * Original signature : <code>void cvCreateData(CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:388</i>
	 */
	void cvCreateData(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Releases array data<br>
	 * Original signature : <code>void cvReleaseData(CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:391</i>
	 */
	void cvReleaseData(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Attaches user data to the array header. The step is reffered to<br>
	 * the pre-last dimension. That is, all the planes of the array<br>
	 * must be joint (w/o gaps)<br>
	 * Original signature : <code>void cvSetData(CvArr*, void*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:396</i>
	 */
	void cvSetData(highgui.HighguiLibrary.CvArr arr, com.sun.jna.Pointer data, int step);
	/**
	 * Retrieves raw data of CvMat, IplImage or CvMatND.<br>
	 * In the latter case the function raises an error if<br>
	 * the array can not be represented as a matrix<br>
	 * Original signature : <code>void cvGetRawData(const CvArr*, uchar**, int*, CvSize*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:401</i><br>
	 * @deprecated use the safer method {@link #cvGetRawData(highgui.HighguiLibrary.CvArr, com.sun.jna.ptr.PointerByReference, java.nio.IntBuffer, cxcore.CvSize)} instead
	 */
	@java.lang.Deprecated
	void cvGetRawData(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.PointerByReference data, com.sun.jna.ptr.IntByReference step, cxcore.CvSize roi_size);
	/**
	 * Retrieves raw data of CvMat, IplImage or CvMatND.<br>
	 * In the latter case the function raises an error if<br>
	 * the array can not be represented as a matrix<br>
	 * Original signature : <code>void cvGetRawData(const CvArr*, uchar**, int*, CvSize*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:401</i>
	 */
	void cvGetRawData(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.PointerByReference data, java.nio.IntBuffer step, cxcore.CvSize roi_size);
	/**
	 * Returns width and height of array in elements<br>
	 * Original signature : <code>CvSize cvGetSize(const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:406</i>
	 */
	cxcore.CvSize.ByValue cvGetSize(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Copies source array to destination array<br>
	 * Original signature : <code>void cvCopy(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:409</i>
	 */
	void cvCopy(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Sets all or "masked" elements of input array<br>
	 * to the same value<br>
	 * Original signature : <code>void cvSet(CvArr*, CvScalar, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:414</i>
	 */
	void cvSet(highgui.HighguiLibrary.CvArr arr, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Clears all the array elements (sets them to 0)<br>
	 * Original signature : <code>void cvSetZero(CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:418</i>
	 */
	void cvSetZero(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Splits a multi-channel array into the set of single-channel arrays or<br>
	 * extracts particular [color] plane<br>
	 * Original signature : <code>void cvSplit(const CvArr*, CvArr*, CvArr*, CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:424</i>
	 */
	void cvSplit(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst0, highgui.HighguiLibrary.CvArr dst1, highgui.HighguiLibrary.CvArr dst2, highgui.HighguiLibrary.CvArr dst3);
	/**
	 * Merges a set of single-channel arrays into the single multi-channel array<br>
	 * or inserts one particular [color] plane to the array<br>
	 * Original signature : <code>void cvMerge(const CvArr*, const CvArr*, const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:429</i>
	 */
	void cvMerge(highgui.HighguiLibrary.CvArr src0, highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr src3, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Copies several channels from input arrays to<br>
	 * certain channels of output arrays<br>
	 * Original signature : <code>void cvMixChannels(const CvArr**, int, CvArr**, int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:435</i><br>
	 * @deprecated use the safer methods {@link #cvMixChannels(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference, int, int[], int)} and {@link #cvMixChannels(com.sun.jna.ptr.PointerByReference, int, com.sun.jna.ptr.PointerByReference, int, java.nio.IntBuffer, int)} instead
	 */
	@java.lang.Deprecated
	void cvMixChannels(com.sun.jna.ptr.PointerByReference src, int src_count, com.sun.jna.ptr.PointerByReference dst, int dst_count, com.sun.jna.ptr.IntByReference from_to, int pair_count);
	/**
	 * Copies several channels from input arrays to<br>
	 * certain channels of output arrays<br>
	 * Original signature : <code>void cvMixChannels(const CvArr**, int, CvArr**, int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:435</i>
	 */
	void cvMixChannels(com.sun.jna.ptr.PointerByReference src, int src_count, com.sun.jna.ptr.PointerByReference dst, int dst_count, int from_to[], int pair_count);
	/**
	 * Copies several channels from input arrays to<br>
	 * certain channels of output arrays<br>
	 * Original signature : <code>void cvMixChannels(const CvArr**, int, CvArr**, int, const int*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:435</i>
	 */
	void cvMixChannels(com.sun.jna.ptr.PointerByReference src, int src_count, com.sun.jna.ptr.PointerByReference dst, int dst_count, java.nio.IntBuffer from_to, int pair_count);
	/**
	 * Performs linear transformation on every source array element:<br>
	 * dst(x,y,c) = scale*src(x,y,c)+shift.<br>
	 * Arbitrary combination of input and output array depths are allowed<br>
	 * (number of channels must be the same), thus the function can be used<br>
	 * for type conversion<br>
	 * Original signature : <code>void cvConvertScale(const CvArr*, CvArr*, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:444</i>
	 */
	void cvConvertScale(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double scale, double shift);
	/**
	 * Performs linear transformation on every source array element,<br>
	 * stores absolute value of the result:<br>
	 * dst(x,y,c) = abs(scale*src(x,y,c)+shift).<br>
	 * destination array must have 8u type.<br>
	 * In other cases one may use cvConvertScale + cvAbsDiffS<br>
	 * Original signature : <code>void cvConvertScaleAbs(const CvArr*, CvArr*, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:457</i>
	 */
	void cvConvertScaleAbs(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double scale, double shift);
	/**
	 * checks termination criteria validity and<br>
	 * sets eps to default_eps (if it is not set),<br>
	 * max_iter to default_max_iters (if it is not set)<br>
	 * Original signature : <code>CvTermCriteria cvCheckTermCriteria(CvTermCriteria, double, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:467</i>
	 */
	cxcore.CvTermCriteria.ByValue cvCheckTermCriteria(cxcore.CvTermCriteria.ByValue criteria, double default_eps, int default_max_iters);
	/**
	 * dst(mask) = src1(mask) + src2(mask)<br>
	 * Original signature : <code>void cvAdd(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:476</i>
	 */
	void cvAdd(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(mask) = src(mask) + value<br>
	 * Original signature : <code>void cvAddS(const CvArr*, CvScalar, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:480</i>
	 */
	void cvAddS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(mask) = src1(mask) - src2(mask)<br>
	 * Original signature : <code>void cvSub(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:484</i>
	 */
	void cvSub(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(mask) = src(mask) - value = src(mask) + (-value)<br>
	 * Original signature : <code>void cvSubS(const CvArr*, CvScalar, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:488</i>
	 */
	void cvSubS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(mask) = value - src(mask)<br>
	 * Original signature : <code>void cvSubRS(const CvArr*, CvScalar, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:496</i>
	 */
	void cvSubRS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = src1(idx) * src2(idx) * scale<br>
	 * (scaled element-wise multiplication of 2 arrays)<br>
	 * Original signature : <code>void cvMul(const CvArr*, const CvArr*, CvArr*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:501</i>
	 */
	void cvMul(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, double scale);
	/**
	 * element-wise division/inversion with scaling:<br>
	 * dst(idx) = src1(idx) * scale / src2(idx)<br>
	 * or dst(idx) = scale / src2(idx) if src1 == 0<br>
	 * Original signature : <code>void cvDiv(const CvArr*, const CvArr*, CvArr*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:507</i>
	 */
	void cvDiv(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, double scale);
	/**
	 * dst = src1 * scale + src2<br>
	 * Original signature : <code>void cvScaleAdd(const CvArr*, CvScalar, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:511</i>
	 */
	void cvScaleAdd(highgui.HighguiLibrary.CvArr src1, cxcore.CvScalar.ByValue scale, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst = src1 * alpha + src2 * beta + gamma<br>
	 * Original signature : <code>void cvAddWeighted(const CvArr*, double, const CvArr*, double, double, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:516</i>
	 */
	void cvAddWeighted(highgui.HighguiLibrary.CvArr src1, double alpha, highgui.HighguiLibrary.CvArr src2, double beta, double gamma, highgui.HighguiLibrary.CvArr dst);
	/**
	 * result = sum_i(src1(i) * src2(i)) (results for all channels are accumulated together)<br>
	 * Original signature : <code>double cvDotProduct(const CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:521</i>
	 */
	double cvDotProduct(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2);
	/**
	 * dst(idx) = src1(idx) & src2(idx)<br>
	 * Original signature : <code>void cvAnd(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:524</i>
	 */
	void cvAnd(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = src(idx) & value<br>
	 * Original signature : <code>void cvAndS(const CvArr*, CvScalar, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:528</i>
	 */
	void cvAndS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = src1(idx) | src2(idx)<br>
	 * Original signature : <code>void cvOr(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:532</i>
	 */
	void cvOr(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = src(idx) | value<br>
	 * Original signature : <code>void cvOrS(const CvArr*, CvScalar, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:536</i>
	 */
	void cvOrS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = src1(idx) ^ src2(idx)<br>
	 * Original signature : <code>void cvXor(const CvArr*, const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:540</i>
	 */
	void cvXor(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = src(idx) ^ value<br>
	 * Original signature : <code>void cvXorS(const CvArr*, CvScalar, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:544</i>
	 */
	void cvXorS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue value, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr mask);
	/**
	 * dst(idx) = ~src(idx)<br>
	 * Original signature : <code>void cvNot(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:548</i>
	 */
	void cvNot(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(idx) = lower(idx) <= src(idx) < upper(idx)<br>
	 * Original signature : <code>void cvInRange(const CvArr*, const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:551</i>
	 */
	void cvInRange(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr lower, highgui.HighguiLibrary.CvArr upper, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(idx) = lower <= src(idx) < upper<br>
	 * Original signature : <code>void cvInRangeS(const CvArr*, CvScalar, CvScalar, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:555</i>
	 */
	void cvInRangeS(highgui.HighguiLibrary.CvArr src, cxcore.CvScalar.ByValue lower, cxcore.CvScalar.ByValue upper, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(idx) = src1(idx) _cmp_op_ src2(idx)<br>
	 * Original signature : <code>void cvCmp(const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:569</i>
	 */
	void cvCmp(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, int cmp_op);
	/**
	 * dst(idx) = src1(idx) _cmp_op_ value<br>
	 * Original signature : <code>void cvCmpS(const CvArr*, double, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:572</i>
	 */
	void cvCmpS(highgui.HighguiLibrary.CvArr src, double value, highgui.HighguiLibrary.CvArr dst, int cmp_op);
	/**
	 * dst(idx) = min(src1(idx),src2(idx))<br>
	 * Original signature : <code>void cvMin(const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:575</i>
	 */
	void cvMin(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(idx) = max(src1(idx),src2(idx))<br>
	 * Original signature : <code>void cvMax(const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:578</i>
	 */
	void cvMax(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(idx) = min(src(idx),value)<br>
	 * Original signature : <code>void cvMinS(const CvArr*, double, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:581</i>
	 */
	void cvMinS(highgui.HighguiLibrary.CvArr src, double value, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(idx) = max(src(idx),value)<br>
	 * Original signature : <code>void cvMaxS(const CvArr*, double, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:584</i>
	 */
	void cvMaxS(highgui.HighguiLibrary.CvArr src, double value, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(x,y,c) = abs(src1(x,y,c) - src2(x,y,c))<br>
	 * Original signature : <code>void cvAbsDiff(const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:587</i>
	 */
	void cvAbsDiff(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst);
	/**
	 * dst(x,y,c) = abs(src(x,y,c) - value(c))<br>
	 * Original signature : <code>void cvAbsDiffS(const CvArr*, CvArr*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:590</i>
	 */
	void cvAbsDiffS(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvScalar.ByValue value);
	/**
	 * Does cartesian->polar coordinates conversion.<br>
	 * Either of output components (magnitude or angle) is optional<br>
	 * Original signature : <code>void cvCartToPolar(const CvArr*, const CvArr*, CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:599</i>
	 */
	void cvCartToPolar(highgui.HighguiLibrary.CvArr x, highgui.HighguiLibrary.CvArr y, highgui.HighguiLibrary.CvArr magnitude, highgui.HighguiLibrary.CvArr angle, int angle_in_degrees);
	/**
	 * Does polar->cartesian coordinates conversion.<br>
	 * Either of output components (magnitude or angle) is optional.<br>
	 * If magnitude is missing it is assumed to be all 1's<br>
	 * Original signature : <code>void cvPolarToCart(const CvArr*, const CvArr*, CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:606</i>
	 */
	void cvPolarToCart(highgui.HighguiLibrary.CvArr magnitude, highgui.HighguiLibrary.CvArr angle, highgui.HighguiLibrary.CvArr x, highgui.HighguiLibrary.CvArr y, int angle_in_degrees);
	/**
	 * Does powering: dst(idx) = src(idx)^power<br>
	 * Original signature : <code>void cvPow(const CvArr*, CvArr*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:611</i>
	 */
	void cvPow(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double power);
	/**
	 * Does exponention: dst(idx) = exp(src(idx)).<br>
	 * Overflow is not handled yet. Underflow is handled.<br>
	 * Maximal relative error is ~7e-6 for single-precision input<br>
	 * Original signature : <code>void cvExp(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:616</i>
	 */
	void cvExp(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Calculates natural logarithms: dst(idx) = log(abs(src(idx))).<br>
	 * Logarithm of 0 gives large negative number(~-700)<br>
	 * Maximal relative error is ~3e-7 for single-precision output<br>
	 * Original signature : <code>void cvLog(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:622</i>
	 */
	void cvLog(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Fast arctangent calculation<br>
	 * Original signature : <code>float cvFastArctan(float, float)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:625</i>
	 */
	float cvFastArctan(float y, float x);
	/**
	 * Fast cubic root calculation<br>
	 * Original signature : <code>float cvCbrt(float)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:628</i>
	 */
	float cvCbrt(float value);
	/**
	 * Original signature : <code>int cvCheckArr(const CvArr*, int, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:636</i>
	 */
	int cvCheckArr(highgui.HighguiLibrary.CvArr arr, int flags, double min_val, double max_val);
	/**
	 * Original signature : <code>void cvRandArr(CvRNG*, CvArr*, int, CvScalar, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:642</i><br>
	 * @deprecated use the safer method {@link #cvRandArr(java.nio.LongBuffer, highgui.HighguiLibrary.CvArr, int, cxcore.CvScalar.ByValue, cxcore.CvScalar.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvRandArr(com.sun.jna.ptr.LongByReference rng, highgui.HighguiLibrary.CvArr arr, int dist_type, cxcore.CvScalar.ByValue param1, cxcore.CvScalar.ByValue param2);
	/**
	 * Original signature : <code>void cvRandArr(CvRNG*, CvArr*, int, CvScalar, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:642</i>
	 */
	void cvRandArr(java.nio.LongBuffer rng, highgui.HighguiLibrary.CvArr arr, int dist_type, cxcore.CvScalar.ByValue param1, cxcore.CvScalar.ByValue param2);
	/**
	 * Original signature : <code>void cvRandShuffle(CvArr*, CvRNG*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:645</i><br>
	 * @deprecated use the safer method {@link #cvRandShuffle(highgui.HighguiLibrary.CvArr, java.nio.LongBuffer, double)} instead
	 */
	@java.lang.Deprecated
	void cvRandShuffle(highgui.HighguiLibrary.CvArr mat, com.sun.jna.ptr.LongByReference rng, double iter_factor);
	/**
	 * Original signature : <code>void cvRandShuffle(CvArr*, CvRNG*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:645</i>
	 */
	void cvRandShuffle(highgui.HighguiLibrary.CvArr mat, java.nio.LongBuffer rng, double iter_factor);
	/**
	 * Original signature : <code>void cvSort(const CvArr*, CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:653</i>
	 */
	void cvSort(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr idxmat, int flags);
	/**
	 * Finds real roots of a cubic equation<br>
	 * Original signature : <code>int cvSolveCubic(const CvMat*, CvMat*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:658</i>
	 */
	int cvSolveCubic(cxcore.CvMat coeffs, cxcore.CvMat roots);
	/**
	 * Finds all real and complex roots of a polynomial equation<br>
	 * Original signature : <code>void cvSolvePoly(const CvMat*, CvMat*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:661</i>
	 */
	void cvSolvePoly(cxcore.CvMat coeffs, cxcore.CvMat roots, int maxiter, int fig);
	/**
	 * Calculates cross product of two 3d vectors<br>
	 * Original signature : <code>void cvCrossProduct(const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:669</i>
	 */
	void cvCrossProduct(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Extended matrix transform:<br>
	 * dst = alpha*op(A)*op(B) + beta*op(C), where op(X) is X or X^T<br>
	 * Original signature : <code>void cvGEMM(const CvArr*, const CvArr*, double, const CvArr*, double, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:680</i>
	 */
	void cvGEMM(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, double alpha, highgui.HighguiLibrary.CvArr src3, double beta, highgui.HighguiLibrary.CvArr dst, int tABC);
	/**
	 * Transforms each element of source array and stores<br>
	 * resultant vectors in destination array<br>
	 * Original signature : <code>void cvTransform(const CvArr*, CvArr*, const CvMat*, const CvMat*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:687</i>
	 */
	void cvTransform(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat transmat, cxcore.CvMat shiftvec);
	/**
	 * Does perspective transform on every element of input array<br>
	 * Original signature : <code>void cvPerspectiveTransform(const CvArr*, CvArr*, const CvMat*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:693</i>
	 */
	void cvPerspectiveTransform(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, cxcore.CvMat mat);
	/**
	 * Calculates (A-delta)*(A-delta)^T (order=0) or (A-delta)^T*(A-delta) (order=1)<br>
	 * Original signature : <code>void cvMulTransposed(const CvArr*, CvArr*, int, const CvArr*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:697</i>
	 */
	void cvMulTransposed(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int order, highgui.HighguiLibrary.CvArr delta, double scale);
	/**
	 * Tranposes matrix. Square matrices can be transposed in-place<br>
	 * Original signature : <code>void cvTranspose(const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:702</i>
	 */
	void cvTranspose(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst);
	/**
	 * Completes the symmetric matrix from the lower (LtoR=0) or from the upper (LtoR!=0) part<br>
	 * Original signature : <code>void cvCompleteSymm(CvMat*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:706</i>
	 */
	void cvCompleteSymm(cxcore.CvMat matrix, int LtoR);
	/**
	 * Mirror array data around horizontal (flip=0),<br>
	 * vertical (flip=1) or both(flip=-1) axises:<br>
	 * cvFlip(src) flips images vertically and sequences horizontally (inplace)<br>
	 * Original signature : <code>void cvFlip(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:711</i>
	 */
	void cvFlip(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int flip_mode);
	/**
	 * Performs Singular Value Decomposition of a matrix<br>
	 * Original signature : <code>void cvSVD(CvArr*, CvArr*, CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:721</i>
	 */
	void cvSVD(highgui.HighguiLibrary.CvArr A, highgui.HighguiLibrary.CvArr W, highgui.HighguiLibrary.CvArr U, highgui.HighguiLibrary.CvArr V, int flags);
	/**
	 * Performs Singular Value Back Substitution (solves A*X = B):<br>
	 * flags must be the same as in cvSVD<br>
	 * Original signature : <code>void cvSVBkSb(const CvArr*, const CvArr*, const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:726</i>
	 */
	void cvSVBkSb(highgui.HighguiLibrary.CvArr W, highgui.HighguiLibrary.CvArr U, highgui.HighguiLibrary.CvArr V, highgui.HighguiLibrary.CvArr B, highgui.HighguiLibrary.CvArr X, int flags);
	/**
	 * Inverts matrix<br>
	 * Original signature : <code>double cvInvert(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:736</i>
	 */
	double cvInvert(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int method);
	/**
	 * Solves linear system (src1)*(dst) = (src2)<br>
	 * (returns 0 if src1 is a singular and CV_LU method is used)<br>
	 * Original signature : <code>int cvSolve(const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:742</i>
	 */
	int cvSolve(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, int method);
	/**
	 * Calculates determinant of input matrix<br>
	 * Original signature : <code>double cvDet(const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:746</i>
	 */
	double cvDet(highgui.HighguiLibrary.CvArr mat);
	/**
	 * Calculates trace of the matrix (sum of elements on the main diagonal)<br>
	 * Original signature : <code>CvScalar cvTrace(const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:749</i>
	 */
	cxcore.CvScalar.ByValue cvTrace(highgui.HighguiLibrary.CvArr mat);
	/**
	 * Finds eigen values and vectors of a symmetric matrix<br>
	 * Original signature : <code>void cvEigenVV(CvArr*, CvArr*, CvArr*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:752</i>
	 */
	void cvEigenVV(highgui.HighguiLibrary.CvArr mat, highgui.HighguiLibrary.CvArr evects, highgui.HighguiLibrary.CvArr evals, double eps);
	/**
	 * Makes an identity matrix (mat_ij = i == j)<br>
	 * Original signature : <code>void cvSetIdentity(CvArr*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:756</i>
	 */
	void cvSetIdentity(highgui.HighguiLibrary.CvArr mat, cxcore.CvScalar.ByValue value);
	/**
	 * Fills matrix with given range of numbers<br>
	 * Original signature : <code>CvArr* cvRange(CvArr*, double, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:759</i>
	 */
	highgui.HighguiLibrary.CvArr cvRange(highgui.HighguiLibrary.CvArr mat, double start, double end);
	/**
	 * Original signature : <code>void cvCalcCovarMatrix(const CvArr**, int, CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:781</i>
	 */
	void cvCalcCovarMatrix(com.sun.jna.ptr.PointerByReference vects, int count, highgui.HighguiLibrary.CvArr cov_mat, highgui.HighguiLibrary.CvArr avg, int flags);
	/**
	 * Original signature : <code>void cvCalcPCA(const CvArr*, CvArr*, CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:787</i>
	 */
	void cvCalcPCA(highgui.HighguiLibrary.CvArr data, highgui.HighguiLibrary.CvArr mean, highgui.HighguiLibrary.CvArr eigenvals, highgui.HighguiLibrary.CvArr eigenvects, int flags);
	/**
	 * Original signature : <code>void cvProjectPCA(const CvArr*, const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:790</i>
	 */
	void cvProjectPCA(highgui.HighguiLibrary.CvArr data, highgui.HighguiLibrary.CvArr mean, highgui.HighguiLibrary.CvArr eigenvects, highgui.HighguiLibrary.CvArr result);
	/**
	 * Original signature : <code>void cvBackProjectPCA(const CvArr*, const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:793</i>
	 */
	void cvBackProjectPCA(highgui.HighguiLibrary.CvArr proj, highgui.HighguiLibrary.CvArr mean, highgui.HighguiLibrary.CvArr eigenvects, highgui.HighguiLibrary.CvArr result);
	/**
	 * Calculates Mahalanobis(weighted) distance<br>
	 * Original signature : <code>double cvMahalanobis(const CvArr*, const CvArr*, CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:797</i>
	 */
	double cvMahalanobis(highgui.HighguiLibrary.CvArr vec1, highgui.HighguiLibrary.CvArr vec2, highgui.HighguiLibrary.CvArr mat);
	/**
	 * Finds sum of array elements<br>
	 * Original signature : <code>CvScalar cvSum(const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:805</i>
	 */
	cxcore.CvScalar.ByValue cvSum(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Calculates number of non-zero pixels<br>
	 * Original signature : <code>int cvCountNonZero(const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:808</i>
	 */
	int cvCountNonZero(highgui.HighguiLibrary.CvArr arr);
	/**
	 * Calculates mean value of array elements<br>
	 * Original signature : <code>CvScalar cvAvg(const CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:811</i>
	 */
	cxcore.CvScalar.ByValue cvAvg(highgui.HighguiLibrary.CvArr arr, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Calculates mean and standard deviation of pixel values<br>
	 * Original signature : <code>void cvAvgSdv(const CvArr*, CvScalar*, CvScalar*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:814</i>
	 */
	void cvAvgSdv(highgui.HighguiLibrary.CvArr arr, cxcore.CvScalar mean, cxcore.CvScalar std_dev, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Finds global minimum, maximum and their positions<br>
	 * Original signature : <code>void cvMinMaxLoc(const CvArr*, double*, double*, CvPoint*, CvPoint*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:818</i><br>
	 * @deprecated use the safer method {@link #cvMinMaxLoc(highgui.HighguiLibrary.CvArr, java.nio.DoubleBuffer, java.nio.DoubleBuffer, cxcore.CvPoint, cxcore.CvPoint, highgui.HighguiLibrary.CvArr)} instead
	 */
	@java.lang.Deprecated
	void cvMinMaxLoc(highgui.HighguiLibrary.CvArr arr, com.sun.jna.ptr.DoubleByReference min_val, com.sun.jna.ptr.DoubleByReference max_val, cxcore.CvPoint min_loc, cxcore.CvPoint max_loc, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Finds global minimum, maximum and their positions<br>
	 * Original signature : <code>void cvMinMaxLoc(const CvArr*, double*, double*, CvPoint*, CvPoint*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:818</i>
	 */
	void cvMinMaxLoc(highgui.HighguiLibrary.CvArr arr, java.nio.DoubleBuffer min_val, java.nio.DoubleBuffer max_val, cxcore.CvPoint min_loc, cxcore.CvPoint max_loc, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Finds norm, difference norm or relative difference norm for an array (or two arrays)<br>
	 * Original signature : <code>double cvNorm(const CvArr*, const CvArr*, int, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:840</i>
	 */
	double cvNorm(highgui.HighguiLibrary.CvArr arr1, highgui.HighguiLibrary.CvArr arr2, int norm_type, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvNormalize(const CvArr*, CvArr*, double, double, int, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:844</i>
	 */
	void cvNormalize(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, double a, double b, int norm_type, highgui.HighguiLibrary.CvArr mask);
	/**
	 * Original signature : <code>void cvReduce(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:855</i>
	 */
	void cvReduce(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int dim, int op);
	/**
	 * Discrete Fourier Transform:<br>
	 * complex->complex,<br>
	 * real->ccs (forward),<br>
	 * ccs->real (inverse)<br>
	 * Original signature : <code>void cvDFT(const CvArr*, CvArr*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:874</i>
	 */
	void cvDFT(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int flags, int nonzero_rows);
	/**
	 * Multiply results of DFTs: DFT(X)*DFT(Y) or DFT(X)*conj(DFT(Y))<br>
	 * Original signature : <code>void cvMulSpectrums(const CvArr*, const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:879</i>
	 */
	void cvMulSpectrums(highgui.HighguiLibrary.CvArr src1, highgui.HighguiLibrary.CvArr src2, highgui.HighguiLibrary.CvArr dst, int flags);
	/**
	 * Finds optimal DFT vector size >= size0<br>
	 * Original signature : <code>int cvGetOptimalDFTSize(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:883</i>
	 */
	int cvGetOptimalDFTSize(int size0);
	/**
	 * Discrete Cosine Transform<br>
	 * Original signature : <code>void cvDCT(const CvArr*, CvArr*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:886</i>
	 */
	void cvDCT(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, int flags);
	/**
	 * Calculates length of sequence slice (with support of negative indices).<br>
	 * Original signature : <code>int cvSliceLength(CvSlice, const CvSeq*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:893</i>
	 */
	int cvSliceLength(cxcore.CvSlice.ByValue slice, cxcore.CvSeq seq);
	/**
	 * Creates new memory storage.<br>
	 * block_size == 0 means that default,<br>
	 * somewhat optimal size, is used (currently, it is 64K)<br>
	 * Original signature : <code>CvMemStorage* cvCreateMemStorage(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:899</i>
	 */
	cxcore.CvMemStorage cvCreateMemStorage(int block_size);
	/**
	 * Creates a memory storage that will borrow memory blocks from parent storage<br>
	 * Original signature : <code>CvMemStorage* cvCreateChildMemStorage(CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:903</i>
	 */
	cxcore.CvMemStorage cvCreateChildMemStorage(cxcore.CvMemStorage parent);
	/**
	 * Releases memory storage. All the children of a parent must be released before<br>
	 * the parent. A child storage returns all the blocks to parent when it is released<br>
	 * Original signature : <code>void cvReleaseMemStorage(CvMemStorage**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:908</i>
	 */
	void cvReleaseMemStorage(cxcore.CvMemStorage.ByReference storage[]);
	/**
	 * Clears memory storage. This is the only way(!!!) (besides cvRestoreMemStoragePos)<br>
	 * to reuse memory allocated for the storage - cvClearSeq,cvClearSet ...<br>
	 * do not free any memory.<br>
	 * A child storage returns all the blocks to the parent when it is cleared<br>
	 * Original signature : <code>void cvClearMemStorage(CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:915</i>
	 */
	void cvClearMemStorage(cxcore.CvMemStorage storage);
	/**
	 * Remember a storage "free memory" position<br>
	 * Original signature : <code>void cvSaveMemStoragePos(const CvMemStorage*, CvMemStoragePos*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:918</i>
	 */
	void cvSaveMemStoragePos(cxcore.CvMemStorage storage, cxcore.CvMemStoragePos pos);
	/**
	 * Restore a storage "free memory" position<br>
	 * Original signature : <code>void cvRestoreMemStoragePos(CvMemStorage*, CvMemStoragePos*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:921</i>
	 */
	void cvRestoreMemStoragePos(cxcore.CvMemStorage storage, cxcore.CvMemStoragePos pos);
	/**
	 * Allocates continuous buffer of the specified size in the storage<br>
	 * Original signature : <code>void* cvMemStorageAlloc(CvMemStorage*, size_t)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:924</i>
	 */
	com.sun.jna.Pointer cvMemStorageAlloc(cxcore.CvMemStorage storage, com.sun.jna.NativeLong size);
	/**
	 * Allocates string in memory storage<br>
	 * Original signature : <code>CvString cvMemStorageAllocString(CvMemStorage*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:927</i><br>
	 * @deprecated use the safer method {@link #cvMemStorageAllocString(cxcore.CvMemStorage, java.lang.String, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvString.ByValue cvMemStorageAllocString(cxcore.CvMemStorage storage, com.sun.jna.ptr.ByteByReference ptr, int len);
	/**
	 * Allocates string in memory storage<br>
	 * Original signature : <code>CvString cvMemStorageAllocString(CvMemStorage*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:927</i>
	 */
	cxcore.CvString.ByValue cvMemStorageAllocString(cxcore.CvMemStorage storage, java.lang.String ptr, int len);
	/**
	 * Creates new empty sequence that will reside in the specified storage<br>
	 * Original signature : <code>CvSeq* cvCreateSeq(int, int, int, CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:931</i>
	 */
	cxcore.CvSeq cvCreateSeq(int seq_flags, int header_size, int elem_size, cxcore.CvMemStorage storage);
	/**
	 * Changes default size (granularity) of sequence blocks.<br>
	 * The default size is ~1Kbyte<br>
	 * Original signature : <code>void cvSetSeqBlockSize(CvSeq*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:936</i>
	 */
	void cvSetSeqBlockSize(cxcore.CvSeq seq, int delta_elems);
	/**
	 * Adds new element to the end of sequence. Returns pointer to the element<br>
	 * Original signature : <code>schar* cvSeqPush(CvSeq*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:940</i>
	 */
	com.sun.jna.ptr.ByteByReference cvSeqPush(cxcore.CvSeq seq, com.sun.jna.Pointer element);
	/**
	 * Adds new element to the beginning of sequence. Returns pointer to it<br>
	 * Original signature : <code>schar* cvSeqPushFront(CvSeq*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:944</i>
	 */
	com.sun.jna.ptr.ByteByReference cvSeqPushFront(cxcore.CvSeq seq, com.sun.jna.Pointer element);
	/**
	 * Removes the last element from sequence and optionally saves it<br>
	 * Original signature : <code>void cvSeqPop(CvSeq*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:948</i>
	 */
	void cvSeqPop(cxcore.CvSeq seq, com.sun.jna.Pointer element);
	/**
	 * Removes the first element from sequence and optioanally saves it<br>
	 * Original signature : <code>void cvSeqPopFront(CvSeq*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:952</i>
	 */
	void cvSeqPopFront(cxcore.CvSeq seq, com.sun.jna.Pointer element);
	/**
	 * Adds several new elements to the end of sequence<br>
	 * Original signature : <code>void cvSeqPushMulti(CvSeq*, void*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:958</i>
	 */
	void cvSeqPushMulti(cxcore.CvSeq seq, com.sun.jna.Pointer elements, int count, int in_front);
	/**
	 * Removes several elements from the end of sequence and optionally saves them<br>
	 * Original signature : <code>void cvSeqPopMulti(CvSeq*, void*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:962</i>
	 */
	void cvSeqPopMulti(cxcore.CvSeq seq, com.sun.jna.Pointer elements, int count, int in_front);
	/**
	 * Inserts a new element in the middle of sequence.<br>
	 * cvSeqInsert(seq,0,elem) == cvSeqPushFront(seq,elem)<br>
	 * Original signature : <code>schar* cvSeqInsert(CvSeq*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:967</i>
	 */
	com.sun.jna.ptr.ByteByReference cvSeqInsert(cxcore.CvSeq seq, int before_index, com.sun.jna.Pointer element);
	/**
	 * Removes specified sequence element<br>
	 * Original signature : <code>void cvSeqRemove(CvSeq*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:971</i>
	 */
	void cvSeqRemove(cxcore.CvSeq seq, int index);
	/**
	 * Removes all the elements from the sequence. The freed memory<br>
	 * can be reused later only by the same sequence unless cvClearMemStorage<br>
	 * or cvRestoreMemStoragePos is called<br>
	 * Original signature : <code>void cvClearSeq(CvSeq*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:977</i>
	 */
	void cvClearSeq(cxcore.CvSeq seq);
	/**
	 * Retrieves pointer to specified sequence element.<br>
	 * Negative indices are supported and mean counting from the end<br>
	 * (e.g -1 means the last sequence element)<br>
	 * Original signature : <code>schar* cvGetSeqElem(const CvSeq*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:983</i>
	 */
	com.sun.jna.ptr.ByteByReference cvGetSeqElem(cxcore.CvSeq seq, int index);
	/**
	 * Calculates index of the specified sequence element.<br>
	 * Returns -1 if element does not belong to the sequence<br>
	 * Original signature : <code>int cvSeqElemIdx(const CvSeq*, const void*, CvSeqBlock**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:987</i>
	 */
	int cvSeqElemIdx(cxcore.CvSeq seq, com.sun.jna.Pointer element, cxcore.CvSeqBlock.ByReference block[]);
	/**
	 * Initializes sequence writer. The new elements will be added to the end of sequence<br>
	 * Original signature : <code>void cvStartAppendToSeq(CvSeq*, CvSeqWriter*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:991</i>
	 */
	void cvStartAppendToSeq(cxcore.CvSeq seq, cxcore.CvSeqWriter writer);
	/**
	 * Combination of cvCreateSeq and cvStartAppendToSeq<br>
	 * Original signature : <code>void cvStartWriteSeq(int, int, int, CvMemStorage*, CvSeqWriter*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:995</i>
	 */
	void cvStartWriteSeq(int seq_flags, int header_size, int elem_size, cxcore.CvMemStorage storage, cxcore.CvSeqWriter writer);
	/**
	 * Closes sequence writer, updates sequence header and returns pointer<br>
	 * to the resultant sequence<br>
	 * (which may be useful if the sequence was created using cvStartWriteSeq))<br>
	 * Original signature : <code>CvSeq* cvEndWriteSeq(CvSeqWriter*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1003</i>
	 */
	cxcore.CvSeq cvEndWriteSeq(cxcore.CvSeqWriter writer);
	/**
	 * Updates sequence header. May be useful to get access to some of previously<br>
	 * written elements via cvGetSeqElem or sequence reader<br>
	 * Original signature : <code>void cvFlushSeqWriter(CvSeqWriter*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1008</i>
	 */
	void cvFlushSeqWriter(cxcore.CvSeqWriter writer);
	/**
	 * Initializes sequence reader.<br>
	 * The sequence can be read in forward or backward direction<br>
	 * Original signature : <code>void cvStartReadSeq(const CvSeq*, CvSeqReader*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1013</i>
	 */
	void cvStartReadSeq(cxcore.CvSeq seq, cxcore.CvSeqReader reader, int reverse);
	/**
	 * Returns current sequence reader position (currently observed sequence element)<br>
	 * Original signature : <code>int cvGetSeqReaderPos(CvSeqReader*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1018</i>
	 */
	int cvGetSeqReaderPos(cxcore.CvSeqReader reader);
	/**
	 * Changes sequence reader position. It may seek to an absolute or<br>
	 * to relative to the current position<br>
	 * Original signature : <code>void cvSetSeqReaderPos(CvSeqReader*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1023</i>
	 */
	void cvSetSeqReaderPos(cxcore.CvSeqReader reader, int index, int is_relative);
	/**
	 * Copies sequence content to a continuous piece of memory<br>
	 * Original signature : <code>void* cvCvtSeqToArray(const CvSeq*, void*, CvSlice)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1027</i>
	 */
	com.sun.jna.Pointer cvCvtSeqToArray(cxcore.CvSeq seq, com.sun.jna.Pointer elements, cxcore.CvSlice.ByValue slice);
	/**
	 * Creates sequence header for array.<br>
	 * After that all the operations on sequences that do not alter the content<br>
	 * can be applied to the resultant sequence<br>
	 * Original signature : <code>CvSeq* cvMakeSeqHeaderForArray(int, int, int, void*, int, CvSeq*, CvSeqBlock*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1033</i>
	 */
	cxcore.CvSeq cvMakeSeqHeaderForArray(int seq_type, int header_size, int elem_size, com.sun.jna.Pointer elements, int total, cxcore.CvSeq seq, cxcore.CvSeqBlock block);
	/**
	 * Extracts sequence slice (with or without copying sequence elements)<br>
	 * Original signature : <code>CvSeq* cvSeqSlice(const CvSeq*, CvSlice, CvMemStorage*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1038</i>
	 */
	cxcore.CvSeq cvSeqSlice(cxcore.CvSeq seq, cxcore.CvSlice.ByValue slice, cxcore.CvMemStorage storage, int copy_data);
	/**
	 * Original signature : <code>CvSeq* cvCloneSeq(const CvSeq*, CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1042</i>
	 */
	cxcore.CvSeq cvCloneSeq(cxcore.CvSeq seq, cxcore.CvMemStorage storage);
	/**
	 * Removes sequence slice<br>
	 * Original signature : <code>void cvSeqRemoveSlice(CvSeq*, CvSlice)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1048</i>
	 */
	void cvSeqRemoveSlice(cxcore.CvSeq seq, cxcore.CvSlice.ByValue slice);
	/**
	 * Inserts a sequence or array into another sequence<br>
	 * Original signature : <code>void cvSeqInsertSlice(CvSeq*, int, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1051</i>
	 */
	void cvSeqInsertSlice(cxcore.CvSeq seq, int before_index, highgui.HighguiLibrary.CvArr from_arr);
	/**
	 * Sorts sequence in-place given element comparison function<br>
	 * Original signature : <code>void cvSeqSort(CvSeq*, CvCmpFunc, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1057</i>
	 */
	void cvSeqSort(cxcore.CvSeq seq, cxcore.CxcoreLibrary.CvCmpFunc func, com.sun.jna.Pointer userdata);
	/**
	 * Finds element in a [sorted] sequence<br>
	 * Original signature : <code>schar* cvSeqSearch(CvSeq*, const void*, CvCmpFunc, int, int*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1060</i><br>
	 * @deprecated use the safer method {@link #cvSeqSearch(cxcore.CvSeq, com.sun.jna.Pointer, cxcore.CxcoreLibrary.CvCmpFunc, int, java.nio.IntBuffer, com.sun.jna.Pointer)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvSeqSearch(cxcore.CvSeq seq, com.sun.jna.Pointer elem, cxcore.CxcoreLibrary.CvCmpFunc func, int is_sorted, com.sun.jna.ptr.IntByReference elem_idx, com.sun.jna.Pointer userdata);
	/**
	 * Finds element in a [sorted] sequence<br>
	 * Original signature : <code>schar* cvSeqSearch(CvSeq*, const void*, CvCmpFunc, int, int*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1060</i>
	 */
	com.sun.jna.ptr.ByteByReference cvSeqSearch(cxcore.CvSeq seq, com.sun.jna.Pointer elem, cxcore.CxcoreLibrary.CvCmpFunc func, int is_sorted, java.nio.IntBuffer elem_idx, com.sun.jna.Pointer userdata);
	/**
	 * Reverses order of sequence elements in-place<br>
	 * Original signature : <code>void cvSeqInvert(CvSeq*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1065</i>
	 */
	void cvSeqInvert(cxcore.CvSeq seq);
	/**
	 * Splits sequence into one or more equivalence classes using the specified criteria<br>
	 * Original signature : <code>int cvSeqPartition(const CvSeq*, CvMemStorage*, CvSeq**, CvCmpFunc, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1068</i>
	 */
	int cvSeqPartition(cxcore.CvSeq seq, cxcore.CvMemStorage storage, cxcore.CvSeq.ByReference labels[], cxcore.CxcoreLibrary.CvCmpFunc is_equal, com.sun.jna.Pointer userdata);
	/**
	 * Internal sequence functions ***********<br>
	 * Original signature : <code>void cvChangeSeqBlock(void*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1072</i>
	 */
	void cvChangeSeqBlock(com.sun.jna.Pointer reader, int direction);
	/**
	 * Original signature : <code>void cvCreateSeqBlock(CvSeqWriter*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1073</i>
	 */
	void cvCreateSeqBlock(cxcore.CvSeqWriter writer);
	/**
	 * Creates a new set<br>
	 * Original signature : <code>CvSet* cvCreateSet(int, int, int, CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1077</i>
	 */
	cxcore.CvSet cvCreateSet(int set_flags, int header_size, int elem_size, cxcore.CvMemStorage storage);
	/**
	 * Adds new element to the set and returns pointer to it<br>
	 * Original signature : <code>int cvSetAdd(CvSet*, CvSetElem*, CvSetElem**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1081</i>
	 */
	int cvSetAdd(cxcore.CvSet set_header, cxcore.CvSetElem elem, cxcore.CvSetElem.ByReference inserted_elem[]);
	/**
	 * Fast variant of cvSetAdd<br>
	 * Original signature : <code>CvSetElem* cvSetNew(CvSet*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1085</i>
	 */
	cxcore.CvSetElem cvSetNew(cxcore.CvSet set_header);
	/**
	 * Removes set element given its pointer<br>
	 * Original signature : <code>void cvSetRemoveByPtr(CvSet*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1100</i>
	 */
	void cvSetRemoveByPtr(cxcore.CvSet set_header, com.sun.jna.Pointer elem);
	/**
	 * Removes element from the set by its index<br>
	 * Original signature : <code>void cvSetRemove(CvSet*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1111</i>
	 */
	void cvSetRemove(cxcore.CvSet set_header, int index);
	/**
	 * Returns a set element by index. If the element doesn't belong to the set,<br>
	 * NULL is returned<br>
	 * Original signature : <code>CvSetElem* cvGetSetElem(const CvSet*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1115</i>
	 */
	cxcore.CvSetElem cvGetSetElem(cxcore.CvSet set_header, int index);
	/**
	 * Removes all the elements from the set<br>
	 * Original signature : <code>void cvClearSet(CvSet*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1122</i>
	 */
	void cvClearSet(cxcore.CvSet set_header);
	/**
	 * Creates new graph<br>
	 * Original signature : <code>CvGraph* cvCreateGraph(int, int, int, int, CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1125</i>
	 */
	cxcore.CvGraph cvCreateGraph(int graph_flags, int header_size, int vtx_size, int edge_size, cxcore.CvMemStorage storage);
	/**
	 * Adds new vertex to the graph<br>
	 * Original signature : <code>int cvGraphAddVtx(CvGraph*, const CvGraphVtx*, CvGraphVtx**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1130</i>
	 */
	int cvGraphAddVtx(cxcore.CvGraph graph, cxcore.CvGraphVtx vtx, cxcore.CvGraphVtx.ByReference inserted_vtx[]);
	/**
	 * Removes vertex from the graph together with all incident edges<br>
	 * Original signature : <code>int cvGraphRemoveVtx(CvGraph*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1135</i>
	 */
	int cvGraphRemoveVtx(cxcore.CvGraph graph, int index);
	/**
	 * Original signature : <code>int cvGraphRemoveVtxByPtr(CvGraph*, CvGraphVtx*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1136</i>
	 */
	int cvGraphRemoveVtxByPtr(cxcore.CvGraph graph, cxcore.CvGraphVtx vtx);
	/**
	 * Link two vertices specifed by indices or pointers if they<br>
	 * are not connected or return pointer to already existing edge<br>
	 * connecting the vertices.<br>
	 * Functions return 1 if a new edge was created, 0 otherwise<br>
	 * Original signature : <code>int cvGraphAddEdge(CvGraph*, int, int, const CvGraphEdge*, CvGraphEdge**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1143</i>
	 */
	int cvGraphAddEdge(cxcore.CvGraph graph, int start_idx, int end_idx, cxcore.CvGraphEdge edge, cxcore.CvGraphEdge.ByReference inserted_edge[]);
	/**
	 * Original signature : <code>int cvGraphAddEdgeByPtr(CvGraph*, CvGraphVtx*, CvGraphVtx*, const CvGraphEdge*, CvGraphEdge**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1148</i>
	 */
	int cvGraphAddEdgeByPtr(cxcore.CvGraph graph, cxcore.CvGraphVtx start_vtx, cxcore.CvGraphVtx end_vtx, cxcore.CvGraphEdge edge, cxcore.CvGraphEdge.ByReference inserted_edge[]);
	/**
	 * Remove edge connecting two vertices<br>
	 * Original signature : <code>void cvGraphRemoveEdge(CvGraph*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1154</i>
	 */
	void cvGraphRemoveEdge(cxcore.CvGraph graph, int start_idx, int end_idx);
	/**
	 * Original signature : <code>void cvGraphRemoveEdgeByPtr(CvGraph*, CvGraphVtx*, CvGraphVtx*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1155</i>
	 */
	void cvGraphRemoveEdgeByPtr(cxcore.CvGraph graph, cxcore.CvGraphVtx start_vtx, cxcore.CvGraphVtx end_vtx);
	/**
	 * Find edge connecting two vertices<br>
	 * Original signature : <code>CvGraphEdge* cvFindGraphEdge(const CvGraph*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1159</i>
	 */
	cxcore.CvGraphEdge cvFindGraphEdge(cxcore.CvGraph graph, int start_idx, int end_idx);
	/**
	 * Original signature : <code>CvGraphEdge* cvFindGraphEdgeByPtr(const CvGraph*, const CvGraphVtx*, const CvGraphVtx*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1160</i>
	 */
	cxcore.CvGraphEdge cvFindGraphEdgeByPtr(cxcore.CvGraph graph, cxcore.CvGraphVtx start_vtx, cxcore.CvGraphVtx end_vtx);
	/**
	 * Remove all vertices and edges from the graph<br>
	 * Original signature : <code>void cvClearGraph(CvGraph*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1167</i>
	 */
	void cvClearGraph(cxcore.CvGraph graph);
	/**
	 * Count number of edges incident to the vertex<br>
	 * Original signature : <code>int cvGraphVtxDegree(const CvGraph*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1171</i>
	 */
	int cvGraphVtxDegree(cxcore.CvGraph graph, int vtx_idx);
	/**
	 * Original signature : <code>int cvGraphVtxDegreeByPtr(const CvGraph*, const CvGraphVtx*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1172</i>
	 */
	int cvGraphVtxDegreeByPtr(cxcore.CvGraph graph, cxcore.CvGraphVtx vtx);
	/**
	 * Creates new graph scanner.<br>
	 * Original signature : <code>CvGraphScanner* cvCreateGraphScanner(CvGraph*, CvGraphVtx*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1222</i>
	 */
	cxcore.CvGraphScanner cvCreateGraphScanner(cxcore.CvGraph graph, cxcore.CvGraphVtx vtx, int mask);
	/**
	 * Releases graph scanner.<br>
	 * Original signature : <code>void cvReleaseGraphScanner(CvGraphScanner**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1227</i>
	 */
	void cvReleaseGraphScanner(cxcore.CvGraphScanner.ByReference scanner[]);
	/**
	 * Get next graph element<br>
	 * Original signature : <code>int cvNextGraphItem(CvGraphScanner*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1230</i>
	 */
	int cvNextGraphItem(cxcore.CvGraphScanner scanner);
	/**
	 * Creates a copy of graph<br>
	 * Original signature : <code>CvGraph* cvCloneGraph(const CvGraph*, CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1233</i>
	 */
	cxcore.CvGraph cvCloneGraph(cxcore.CvGraph graph, cxcore.CvMemStorage storage);
	/**
	 * Draws 4-connected, 8-connected or antialiased line segment connecting two points<br>
	 * Original signature : <code>void cvLine(CvArr*, CvPoint, CvPoint, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1255</i>
	 */
	void cvLine(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByValue pt1, cxcore.CvPoint.ByValue pt2, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Draws a rectangle given two opposite corners of the rectangle (pt1 & pt2),<br>
	 * if thickness<0 (e.g. thickness == CV_FILLED), the filled box is drawn<br>
	 * Original signature : <code>void cvRectangle(CvArr*, CvPoint, CvPoint, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1261</i>
	 */
	void cvRectangle(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByValue pt1, cxcore.CvPoint.ByValue pt2, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Draws a circle with specified center and radius.<br>
	 * Thickness works in the same way as with cvRectangle<br>
	 * Original signature : <code>void cvCircle(CvArr*, CvPoint, int, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1268</i>
	 */
	void cvCircle(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByValue center, int radius, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Draws ellipse outline, filled ellipse, elliptic arc or filled elliptic sector,<br>
	 * depending on <thickness>, <start_angle> and <end_angle> parameters. The resultant figure<br>
	 * is rotated by <angle>. All the angles are in degrees<br>
	 * Original signature : <code>void cvEllipse(CvArr*, CvPoint, CvSize, double, double, double, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1275</i>
	 */
	void cvEllipse(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByValue center, cxcore.CvSize.ByValue axes, double angle, double start_angle, double end_angle, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Original signature : <code>void cvEllipseBox(CvArr*, CvBox2D, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1280</i>
	 */
	void cvEllipseBox(highgui.HighguiLibrary.CvArr img, cxcore.CvBox2D.ByValue box, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Fills convex or monotonous polygon.<br>
	 * Original signature : <code>void cvFillConvexPoly(CvArr*, CvPoint*, int, CvScalar, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1293</i>
	 */
	void cvFillConvexPoly(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint pts, int npts, cxcore.CvScalar.ByValue color, int line_type, int shift);
	/**
	 * Fills an area bounded by one or more arbitrary polygons<br>
	 * Original signature : <code>void cvFillPoly(CvArr*, CvPoint**, int*, int, CvScalar, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1297</i><br>
	 * @deprecated use the safer method {@link #cvFillPoly(highgui.HighguiLibrary.CvArr, cxcore.CvPoint.ByReference[], java.nio.IntBuffer, int, cxcore.CvScalar.ByValue, int, int)} instead
	 */
	@java.lang.Deprecated
	void cvFillPoly(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByReference pts[], com.sun.jna.ptr.IntByReference npts, int contours, cxcore.CvScalar.ByValue color, int line_type, int shift);
	/**
	 * Fills an area bounded by one or more arbitrary polygons<br>
	 * Original signature : <code>void cvFillPoly(CvArr*, CvPoint**, int*, int, CvScalar, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1297</i>
	 */
	void cvFillPoly(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByReference pts[], java.nio.IntBuffer npts, int contours, cxcore.CvScalar.ByValue color, int line_type, int shift);
	/**
	 * Draws one or more polygonal curves<br>
	 * Original signature : <code>void cvPolyLine(CvArr*, CvPoint**, int*, int, int, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1301</i><br>
	 * @deprecated use the safer method {@link #cvPolyLine(highgui.HighguiLibrary.CvArr, cxcore.CvPoint.ByReference[], java.nio.IntBuffer, int, int, cxcore.CvScalar.ByValue, int, int, int)} instead
	 */
	@java.lang.Deprecated
	void cvPolyLine(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByReference pts[], com.sun.jna.ptr.IntByReference npts, int contours, int is_closed, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Draws one or more polygonal curves<br>
	 * Original signature : <code>void cvPolyLine(CvArr*, CvPoint**, int*, int, int, CvScalar, int, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1301</i>
	 */
	void cvPolyLine(highgui.HighguiLibrary.CvArr img, cxcore.CvPoint.ByReference pts[], java.nio.IntBuffer npts, int contours, int is_closed, cxcore.CvScalar.ByValue color, int thickness, int line_type, int shift);
	/**
	 * Clips the line segment connecting *pt1 and *pt2<br>
	 * by the rectangular window<br>
	 * (0<=x<img_size.width, 0<=y<img_size.height).<br>
	 * Original signature : <code>int cvClipLine(CvSize, CvPoint*, CvPoint*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1314</i>
	 */
	int cvClipLine(cxcore.CvSize.ByValue img_size, cxcore.CvPoint pt1, cxcore.CvPoint pt2);
	/**
	 * Initializes line iterator. Initially, line_iterator->ptr will point<br>
	 * to pt1 (or pt2, see left_to_right description) location in the image.<br>
	 * Returns the number of pixels on the line between the ending points.<br>
	 * Original signature : <code>int cvInitLineIterator(const CvArr*, CvPoint, CvPoint, CvLineIterator*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1319</i>
	 */
	int cvInitLineIterator(highgui.HighguiLibrary.CvArr image, cxcore.CvPoint.ByValue pt1, cxcore.CvPoint.ByValue pt2, cxcore.CvLineIterator line_iterator, int connectivity, int left_to_right);
	/**
	 * Initializes font structure used further in cvPutText<br>
	 * Original signature : <code>void cvInitFont(CvFont*, int, double, double, double, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1366</i>
	 */
	void cvInitFont(cxcore.CvFont font, int font_face, double hscale, double vscale, double shear, int thickness, int line_type);
	/**
	 * Original signature : <code>CvFont cvFont(double, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1372</i>
	 */
	cxcore.CvFont.ByValue cvFont(double scale, int thickness);
	/**
	 * Renders text stroke with specified font and color at specified location.<br>
	 * CvFont should be initialized with cvInitFont<br>
	 * Original signature : <code>void cvPutText(CvArr*, const char*, CvPoint, const CvFont*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1381</i><br>
	 * @deprecated use the safer method {@link #cvPutText(highgui.HighguiLibrary.CvArr, java.lang.String, cxcore.CvPoint.ByValue, cxcore.CvFont, cxcore.CvScalar.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvPutText(highgui.HighguiLibrary.CvArr img, com.sun.jna.ptr.ByteByReference text, cxcore.CvPoint.ByValue org, cxcore.CvFont font, cxcore.CvScalar.ByValue color);
	/**
	 * Renders text stroke with specified font and color at specified location.<br>
	 * CvFont should be initialized with cvInitFont<br>
	 * Original signature : <code>void cvPutText(CvArr*, const char*, CvPoint, const CvFont*, CvScalar)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1381</i>
	 */
	void cvPutText(highgui.HighguiLibrary.CvArr img, java.lang.String text, cxcore.CvPoint.ByValue org, cxcore.CvFont font, cxcore.CvScalar.ByValue color);
	/**
	 * Calculates bounding box of text stroke (useful for alignment)<br>
	 * Original signature : <code>void cvGetTextSize(const char*, const CvFont*, CvSize*, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1385</i><br>
	 * @deprecated use the safer method {@link #cvGetTextSize(java.lang.String, cxcore.CvFont, cxcore.CvSize, java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	void cvGetTextSize(com.sun.jna.ptr.ByteByReference text_string, cxcore.CvFont font, cxcore.CvSize text_size, com.sun.jna.ptr.IntByReference baseline);
	/**
	 * Calculates bounding box of text stroke (useful for alignment)<br>
	 * Original signature : <code>void cvGetTextSize(const char*, const CvFont*, CvSize*, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1385</i>
	 */
	void cvGetTextSize(java.lang.String text_string, cxcore.CvFont font, cxcore.CvSize text_size, java.nio.IntBuffer baseline);
	/**
	 * Unpacks color value, if arrtype is CV_8UC?, <color> is treated as<br>
	 * packed color value, otherwise the first channels (depending on arrtype)<br>
	 * of destination scalar are set to the same value = <color><br>
	 * Original signature : <code>CvScalar cvColorToScalar(double, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1391</i>
	 */
	cxcore.CvScalar.ByValue cvColorToScalar(double packed_color, int arrtype);
	/**
	 * Returns the polygon points which make up the given ellipse.  The ellipse is define by<br>
	 * the box of size 'axes' rotated 'angle' around the 'center'.  A partial sweep<br>
	 * of the ellipse arc can be done by spcifying arc_start and arc_end to be something<br>
	 * other than 0 and 360, respectively.  The input array 'pts' must be large enough to<br>
	 * hold the result.  The total number of points stored into 'pts' is returned by this<br>
	 * function.<br>
	 * Original signature : <code>int cvEllipse2Poly(CvPoint, CvSize, int, int, int, CvPoint*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1399</i>
	 */
	int cvEllipse2Poly(cxcore.CvPoint.ByValue center, cxcore.CvSize.ByValue axes, int angle, int arc_start, int arc_end, cxcore.CvPoint pts, int delta);
	/**
	 * Draws contour outlines or filled interiors on the image<br>
	 * Original signature : <code>void cvDrawContours(CvArr*, CvSeq*, CvScalar, CvScalar, int, int, int, CvPoint)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1403</i>
	 */
	void cvDrawContours(highgui.HighguiLibrary.CvArr img, cxcore.CvSeq contour, cxcore.CvScalar.ByValue external_color, cxcore.CvScalar.ByValue hole_color, int max_level, int thickness, int line_type, cxcore.CvPoint.ByValue offset);
	/**
	 * Does look-up transformation. Elements of the source array<br>
	 * (that should be 8uC1 or 8sC1) are used as indexes in lutarr 256-element table<br>
	 * Original signature : <code>void cvLUT(const CvArr*, CvArr*, const CvArr*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1411</i>
	 */
	void cvLUT(highgui.HighguiLibrary.CvArr src, highgui.HighguiLibrary.CvArr dst, highgui.HighguiLibrary.CvArr lut);
	/**
	 * Original signature : <code>void cvInitTreeNodeIterator(CvTreeNodeIterator*, const void*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1423</i>
	 */
	void cvInitTreeNodeIterator(cxcore.CvTreeNodeIterator tree_iterator, com.sun.jna.Pointer first, int max_level);
	/**
	 * Original signature : <code>void* cvNextTreeNode(CvTreeNodeIterator*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1425</i>
	 */
	com.sun.jna.Pointer cvNextTreeNode(cxcore.CvTreeNodeIterator tree_iterator);
	/**
	 * Original signature : <code>void* cvPrevTreeNode(CvTreeNodeIterator*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1426</i>
	 */
	com.sun.jna.Pointer cvPrevTreeNode(cxcore.CvTreeNodeIterator tree_iterator);
	/**
	 * Inserts sequence into tree with specified "parent" sequence.<br>
	 * If parent is equal to frame (e.g. the most external contour),<br>
	 * then added contour will have null pointer to parent.<br>
	 * Original signature : <code>void cvInsertNodeIntoTree(void*, void*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1431</i>
	 */
	void cvInsertNodeIntoTree(com.sun.jna.Pointer node, com.sun.jna.Pointer parent, com.sun.jna.Pointer frame);
	/**
	 * Removes contour from tree (together with the contour children).<br>
	 * Original signature : <code>void cvRemoveNodeFromTree(void*, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1434</i>
	 */
	void cvRemoveNodeFromTree(com.sun.jna.Pointer node, com.sun.jna.Pointer frame);
	/**
	 * Gathers pointers to all the sequences,<br>
	 * accessible from the <first>, to the single sequence<br>
	 * Original signature : <code>CvSeq* cvTreeToNodeSeq(const void*, int, CvMemStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1438</i>
	 */
	cxcore.CvSeq cvTreeToNodeSeq(com.sun.jna.Pointer first, int header_size, cxcore.CvMemStorage storage);
	/**
	 * The function implements the K-means algorithm for clustering an array of sample<br>
	 * vectors in a specified number of classes<br>
	 * Original signature : <code>void cvKMeans2(const CvArr*, int, CvArr*, CvTermCriteria)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1443</i>
	 */
	void cvKMeans2(highgui.HighguiLibrary.CvArr samples, int cluster_count, highgui.HighguiLibrary.CvArr labels, cxcore.CvTermCriteria.ByValue termcrit);
	/**
	 * Add the function pointers table with associated information to the IPP primitives list<br>
	 * Original signature : <code>int cvRegisterModule(const CvModuleInfo*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1451</i>
	 */
	int cvRegisterModule(cxcore.CvModuleInfo module_info);
	/**
	 * Loads optimized functions from IPP, MKL etc. or switches back to pure C code<br>
	 * Original signature : <code>int cvUseOptimized(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1454</i>
	 */
	int cvUseOptimized(int on_off);
	/**
	 * Retrieves information about the registered modules and loaded optimized plugins<br>
	 * Original signature : <code>void cvGetModuleInfo(const char*, const char**, const char**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1457</i><br>
	 * @deprecated use the safer method {@link #cvGetModuleInfo(java.lang.String, java.lang.String[], java.lang.String[])} instead
	 */
	@java.lang.Deprecated
	void cvGetModuleInfo(com.sun.jna.ptr.ByteByReference module_name, com.sun.jna.ptr.PointerByReference version, com.sun.jna.ptr.PointerByReference loaded_addon_plugins);
	/**
	 * Retrieves information about the registered modules and loaded optimized plugins<br>
	 * Original signature : <code>void cvGetModuleInfo(const char*, const char**, const char**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1457</i>
	 */
	void cvGetModuleInfo(java.lang.String module_name, java.lang.String version[], java.lang.String loaded_addon_plugins[]);
	/**
	 * Get current OpenCV error status<br>
	 * Original signature : <code>int cvGetErrStatus()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1462</i>
	 */
	int cvGetErrStatus();
	/**
	 * Sets error status silently<br>
	 * Original signature : <code>void cvSetErrStatus(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1465</i>
	 */
	void cvSetErrStatus(int status);
	/**
	 * Retrives current error processing mode<br>
	 * Original signature : <code>int cvGetErrMode()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1472</i>
	 */
	int cvGetErrMode();
	/**
	 * Sets error processing mode, returns previously used mode<br>
	 * Original signature : <code>int cvSetErrMode(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1475</i>
	 */
	int cvSetErrMode(int mode);
	/**
	 * Sets error status and performs some additonal actions (displaying message box,<br>
	 * writing message to stderr, terminating application etc.)<br>
	 * depending on the current error mode<br>
	 * Original signature : <code>void cvError(int, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1480</i><br>
	 * @deprecated use the safer method {@link #cvError(int, java.lang.String, java.lang.String, java.lang.String, int)} instead
	 */
	@java.lang.Deprecated
	void cvError(int status, com.sun.jna.ptr.ByteByReference func_name, com.sun.jna.ptr.ByteByReference err_msg, com.sun.jna.ptr.ByteByReference file_name, int line);
	/**
	 * Sets error status and performs some additonal actions (displaying message box,<br>
	 * writing message to stderr, terminating application etc.)<br>
	 * depending on the current error mode<br>
	 * Original signature : <code>void cvError(int, const char*, const char*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1480</i>
	 */
	void cvError(int status, java.lang.String func_name, java.lang.String err_msg, java.lang.String file_name, int line);
	/**
	 * Retrieves textual description of the error given its code<br>
	 * Original signature : <code>char* cvErrorStr(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1484</i>
	 */
	com.sun.jna.ptr.ByteByReference cvErrorStr(int status);
	/**
	 * Retrieves detailed information about the last error occured<br>
	 * Original signature : <code>int cvGetErrInfo(const char**, const char**, const char**, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1487</i><br>
	 * @deprecated use the safer method {@link #cvGetErrInfo(java.lang.String[], java.lang.String[], java.lang.String[], java.nio.IntBuffer)} instead
	 */
	@java.lang.Deprecated
	int cvGetErrInfo(com.sun.jna.ptr.PointerByReference errcode_desc, com.sun.jna.ptr.PointerByReference description, com.sun.jna.ptr.PointerByReference filename, com.sun.jna.ptr.IntByReference line);
	/**
	 * Retrieves detailed information about the last error occured<br>
	 * Original signature : <code>int cvGetErrInfo(const char**, const char**, const char**, int*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1487</i>
	 */
	int cvGetErrInfo(java.lang.String errcode_desc[], java.lang.String description[], java.lang.String filename[], java.nio.IntBuffer line);
	/**
	 * Maps IPP error codes to the counterparts from OpenCV<br>
	 * Original signature : <code>int cvErrorFromIppStatus(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1491</i>
	 */
	int cvErrorFromIppStatus(int ipp_status);
	/**
	 * Assigns a new error-handling function<br>
	 * Original signature : <code>CvErrorCallback cvRedirectError(CvErrorCallback, void*, void**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1497</i>
	 */
	cxcore.CxcoreLibrary.CvErrorCallback cvRedirectError(cxcore.CxcoreLibrary.CvErrorCallback error_handler, com.sun.jna.Pointer userdata, com.sun.jna.ptr.PointerByReference prev_userdata);
	/**
	 * Output to:<br>
	 * cvNulDevReport - nothing<br>
	 * cvStdErrReport - console(fprintf(stderr,...))<br>
	 * cvGuiBoxReport - MessageBox(WIN32)<br>
	 * Original signature : <code>int cvNulDevReport(int, const char*, const char*, const char*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1507</i><br>
	 * @deprecated use the safer method {@link #cvNulDevReport(int, java.lang.String, java.lang.String, java.lang.String, int, com.sun.jna.Pointer)} instead
	 */
	@java.lang.Deprecated
	int cvNulDevReport(int status, com.sun.jna.ptr.ByteByReference func_name, com.sun.jna.ptr.ByteByReference err_msg, com.sun.jna.ptr.ByteByReference file_name, int line, com.sun.jna.Pointer userdata);
	/**
	 * Output to:<br>
	 * cvNulDevReport - nothing<br>
	 * cvStdErrReport - console(fprintf(stderr,...))<br>
	 * cvGuiBoxReport - MessageBox(WIN32)<br>
	 * Original signature : <code>int cvNulDevReport(int, const char*, const char*, const char*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1507</i>
	 */
	int cvNulDevReport(int status, java.lang.String func_name, java.lang.String err_msg, java.lang.String file_name, int line, com.sun.jna.Pointer userdata);
	/**
	 * Original signature : <code>int cvStdErrReport(int, const char*, const char*, const char*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1510</i><br>
	 * @deprecated use the safer method {@link #cvStdErrReport(int, java.lang.String, java.lang.String, java.lang.String, int, com.sun.jna.Pointer)} instead
	 */
	@java.lang.Deprecated
	int cvStdErrReport(int status, com.sun.jna.ptr.ByteByReference func_name, com.sun.jna.ptr.ByteByReference err_msg, com.sun.jna.ptr.ByteByReference file_name, int line, com.sun.jna.Pointer userdata);
	/**
	 * Original signature : <code>int cvStdErrReport(int, const char*, const char*, const char*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1510</i>
	 */
	int cvStdErrReport(int status, java.lang.String func_name, java.lang.String err_msg, java.lang.String file_name, int line, com.sun.jna.Pointer userdata);
	/**
	 * Original signature : <code>int cvGuiBoxReport(int, const char*, const char*, const char*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1513</i><br>
	 * @deprecated use the safer method {@link #cvGuiBoxReport(int, java.lang.String, java.lang.String, java.lang.String, int, com.sun.jna.Pointer)} instead
	 */
	@java.lang.Deprecated
	int cvGuiBoxReport(int status, com.sun.jna.ptr.ByteByReference func_name, com.sun.jna.ptr.ByteByReference err_msg, com.sun.jna.ptr.ByteByReference file_name, int line, com.sun.jna.Pointer userdata);
	/**
	 * Original signature : <code>int cvGuiBoxReport(int, const char*, const char*, const char*, int, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1513</i>
	 */
	int cvGuiBoxReport(int status, java.lang.String func_name, java.lang.String err_msg, java.lang.String file_name, int line, com.sun.jna.Pointer userdata);
	/**
	 * Set user-defined memory managment functions (substitutors for malloc and free) that<br>
	 * will be called by cvAlloc, cvFree and higher-level functions (e.g. cvCreateImage)<br>
	 * Original signature : <code>void cvSetMemoryManager(CvAllocFunc, CvFreeFunc, void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1521</i>
	 */
	void cvSetMemoryManager(cxcore.CxcoreLibrary.CvAllocFunc alloc_func, cxcore.CxcoreLibrary.CvFreeFunc free_func, com.sun.jna.Pointer userdata);
	/**
	 * Makes OpenCV use IPL functions for IplImage allocation/deallocation<br>
	 * Original signature : <code>void cvSetIPLAllocators(Cv_iplCreateImageHeader, Cv_iplAllocateImageData, Cv_iplDeallocate, Cv_iplCreateROI, Cv_iplCloneImage)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1535</i>
	 */
	void cvSetIPLAllocators(cxcore.CxcoreLibrary.Cv_iplCreateImageHeader create_header, cxcore.CxcoreLibrary.Cv_iplAllocateImageData allocate_data, cxcore.CxcoreLibrary.Cv_iplDeallocate deallocate, cxcore.CxcoreLibrary.Cv_iplCreateROI create_roi, cxcore.CxcoreLibrary.Cv_iplCloneImage clone_image);
	/**
	 * opens existing or creates new file storage<br>
	 * Original signature : <code>CvFileStorage* cvOpenFileStorage(const char*, CvMemStorage*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1552</i><br>
	 * @deprecated use the safer method {@link #cvOpenFileStorage(java.lang.String, cxcore.CvMemStorage, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CxcoreLibrary.CvFileStorage cvOpenFileStorage(com.sun.jna.ptr.ByteByReference filename, cxcore.CvMemStorage memstorage, int flags);
	/**
	 * opens existing or creates new file storage<br>
	 * Original signature : <code>CvFileStorage* cvOpenFileStorage(const char*, CvMemStorage*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1552</i>
	 */
	cxcore.CxcoreLibrary.CvFileStorage cvOpenFileStorage(java.lang.String filename, cxcore.CvMemStorage memstorage, int flags);
	/**
	 * closes file storage and deallocates buffers<br>
	 * Original signature : <code>void cvReleaseFileStorage(CvFileStorage**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1557</i>
	 */
	void cvReleaseFileStorage(com.sun.jna.ptr.PointerByReference fs);
	/**
	 * returns attribute value or 0 (NULL) if there is no such attribute<br>
	 * Original signature : <code>char* cvAttrValue(const CvAttrList*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1560</i><br>
	 * @deprecated use the safer method {@link #cvAttrValue(cxcore.CvAttrList, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvAttrValue(cxcore.CvAttrList attr, com.sun.jna.ptr.ByteByReference attr_name);
	/**
	 * returns attribute value or 0 (NULL) if there is no such attribute<br>
	 * Original signature : <code>char* cvAttrValue(const CvAttrList*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1560</i>
	 */
	com.sun.jna.ptr.ByteByReference cvAttrValue(cxcore.CvAttrList attr, java.lang.String attr_name);
	/**
	 * starts writing compound structure (map or sequence)<br>
	 * Original signature : <code>void cvStartWriteStruct(CvFileStorage*, const char*, int, const char*, CvAttrList)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1563</i><br>
	 * @deprecated use the safer method {@link #cvStartWriteStruct(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, int, java.lang.String, cxcore.CvAttrList.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvStartWriteStruct(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference name, int struct_flags, com.sun.jna.ptr.ByteByReference type_name, cxcore.CvAttrList.ByValue attributes);
	/**
	 * starts writing compound structure (map or sequence)<br>
	 * Original signature : <code>void cvStartWriteStruct(CvFileStorage*, const char*, int, const char*, CvAttrList)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1563</i>
	 */
	void cvStartWriteStruct(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String name, int struct_flags, java.lang.String type_name, cxcore.CvAttrList.ByValue attributes);
	/**
	 * finishes writing compound structure<br>
	 * Original signature : <code>void cvEndWriteStruct(CvFileStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1568</i>
	 */
	void cvEndWriteStruct(cxcore.CxcoreLibrary.CvFileStorage fs);
	/**
	 * writes an integer<br>
	 * Original signature : <code>void cvWriteInt(CvFileStorage*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1571</i><br>
	 * @deprecated use the safer method {@link #cvWriteInt(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, int)} instead
	 */
	@java.lang.Deprecated
	void cvWriteInt(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference name, int value);
	/**
	 * writes an integer<br>
	 * Original signature : <code>void cvWriteInt(CvFileStorage*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1571</i>
	 */
	void cvWriteInt(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String name, int value);
	/**
	 * writes a floating-point number<br>
	 * Original signature : <code>void cvWriteReal(CvFileStorage*, const char*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1574</i><br>
	 * @deprecated use the safer method {@link #cvWriteReal(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, double)} instead
	 */
	@java.lang.Deprecated
	void cvWriteReal(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference name, double value);
	/**
	 * writes a floating-point number<br>
	 * Original signature : <code>void cvWriteReal(CvFileStorage*, const char*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1574</i>
	 */
	void cvWriteReal(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String name, double value);
	/**
	 * writes a string<br>
	 * Original signature : <code>void cvWriteString(CvFileStorage*, const char*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1577</i><br>
	 * @deprecated use the safer method {@link #cvWriteString(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, java.lang.String, int)} instead
	 */
	@java.lang.Deprecated
	void cvWriteString(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference name, com.sun.jna.ptr.ByteByReference str, int quote);
	/**
	 * writes a string<br>
	 * Original signature : <code>void cvWriteString(CvFileStorage*, const char*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1577</i>
	 */
	void cvWriteString(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String name, java.lang.String str, int quote);
	/**
	 * writes a comment<br>
	 * Original signature : <code>void cvWriteComment(CvFileStorage*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1581</i><br>
	 * @deprecated use the safer method {@link #cvWriteComment(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, int)} instead
	 */
	@java.lang.Deprecated
	void cvWriteComment(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference comment, int eol_comment);
	/**
	 * writes a comment<br>
	 * Original signature : <code>void cvWriteComment(CvFileStorage*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1581</i>
	 */
	void cvWriteComment(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String comment, int eol_comment);
	/**
	 * writes instance of a standard type (matrix, image, sequence, graph etc.)<br>
	 * or user-defined type<br>
	 * Original signature : <code>void cvWrite(CvFileStorage*, const char*, const void*, CvAttrList)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1586</i><br>
	 * @deprecated use the safer method {@link #cvWrite(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, com.sun.jna.Pointer, cxcore.CvAttrList.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvWrite(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference name, com.sun.jna.Pointer ptr, cxcore.CvAttrList.ByValue attributes);
	/**
	 * writes instance of a standard type (matrix, image, sequence, graph etc.)<br>
	 * or user-defined type<br>
	 * Original signature : <code>void cvWrite(CvFileStorage*, const char*, const void*, CvAttrList)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1586</i>
	 */
	void cvWrite(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String name, com.sun.jna.Pointer ptr, cxcore.CvAttrList.ByValue attributes);
	/**
	 * starts the next stream<br>
	 * Original signature : <code>void cvStartNextStream(CvFileStorage*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1590</i>
	 */
	void cvStartNextStream(cxcore.CxcoreLibrary.CvFileStorage fs);
	/**
	 * helper function: writes multiple integer or floating-point numbers<br>
	 * Original signature : <code>void cvWriteRawData(CvFileStorage*, const void*, int, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1593</i><br>
	 * @deprecated use the safer method {@link #cvWriteRawData(cxcore.CxcoreLibrary.CvFileStorage, com.sun.jna.Pointer, int, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	void cvWriteRawData(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.Pointer src, int len, com.sun.jna.ptr.ByteByReference dt);
	/**
	 * helper function: writes multiple integer or floating-point numbers<br>
	 * Original signature : <code>void cvWriteRawData(CvFileStorage*, const void*, int, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1593</i>
	 */
	void cvWriteRawData(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.Pointer src, int len, java.lang.String dt);
	/**
	 * returns the hash entry corresponding to the specified literal key string or 0<br>
	 * if there is no such a key in the storage<br>
	 * Original signature : <code>CvStringHashNode* cvGetHashedKey(CvFileStorage*, const char*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1598</i><br>
	 * @deprecated use the safer method {@link #cvGetHashedKey(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, int, int)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvStringHashNode cvGetHashedKey(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference name, int len, int create_missing);
	/**
	 * returns the hash entry corresponding to the specified literal key string or 0<br>
	 * if there is no such a key in the storage<br>
	 * Original signature : <code>CvStringHashNode* cvGetHashedKey(CvFileStorage*, const char*, int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1598</i>
	 */
	cxcore.CvStringHashNode cvGetHashedKey(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String name, int len, int create_missing);
	/**
	 * returns file node with the specified key within the specified map<br>
	 * (collection of named nodes)<br>
	 * Original signature : <code>CvFileNode* cvGetRootFileNode(const CvFileStorage*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1604</i>
	 */
	cxcore.CvFileNode cvGetRootFileNode(cxcore.CxcoreLibrary.CvFileStorage fs, int stream_index);
	/**
	 * returns file node with the specified key within the specified map<br>
	 * (collection of named nodes)<br>
	 * Original signature : <code>CvFileNode* cvGetFileNode(CvFileStorage*, CvFileNode*, const CvStringHashNode*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1609</i>
	 */
	cxcore.CvFileNode cvGetFileNode(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, cxcore.CvStringHashNode key, int create_missing);
	/**
	 * this is a slower version of cvGetFileNode that takes the key as a literal string<br>
	 * Original signature : <code>CvFileNode* cvGetFileNodeByName(const CvFileStorage*, const CvFileNode*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1614</i><br>
	 * @deprecated use the safer method {@link #cvGetFileNodeByName(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvFileNode, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvFileNode cvGetFileNodeByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, com.sun.jna.ptr.ByteByReference name);
	/**
	 * this is a slower version of cvGetFileNode that takes the key as a literal string<br>
	 * Original signature : <code>CvFileNode* cvGetFileNodeByName(const CvFileStorage*, const CvFileNode*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1614</i>
	 */
	cxcore.CvFileNode cvGetFileNodeByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, java.lang.String name);
	/**
	 * Original signature : <code>int cvReadInt(const CvFileNode*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1618</i>
	 */
	int cvReadInt(cxcore.CvFileNode node, int default_value);
	/**
	 * Original signature : <code>int cvReadIntByName(const CvFileStorage*, const CvFileNode*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1626</i><br>
	 * @deprecated use the safer method {@link #cvReadIntByName(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvFileNode, java.lang.String, int)} instead
	 */
	@java.lang.Deprecated
	int cvReadIntByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, com.sun.jna.ptr.ByteByReference name, int default_value);
	/**
	 * Original signature : <code>int cvReadIntByName(const CvFileStorage*, const CvFileNode*, const char*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1626</i>
	 */
	int cvReadIntByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, java.lang.String name, int default_value);
	/**
	 * Original signature : <code>double cvReadReal(const CvFileNode*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1633</i>
	 */
	double cvReadReal(cxcore.CvFileNode node, double default_value);
	/**
	 * Original signature : <code>double cvReadRealByName(const CvFileStorage*, const CvFileNode*, const char*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1641</i><br>
	 * @deprecated use the safer method {@link #cvReadRealByName(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvFileNode, java.lang.String, double)} instead
	 */
	@java.lang.Deprecated
	double cvReadRealByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, com.sun.jna.ptr.ByteByReference name, double default_value);
	/**
	 * Original signature : <code>double cvReadRealByName(const CvFileStorage*, const CvFileNode*, const char*, double)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1641</i>
	 */
	double cvReadRealByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, java.lang.String name, double default_value);
	/**
	 * Original signature : <code>char* cvReadString(const CvFileNode*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1648</i><br>
	 * @deprecated use the safer method {@link #cvReadString(cxcore.CvFileNode, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvReadString(cxcore.CvFileNode node, com.sun.jna.ptr.ByteByReference default_value);
	/**
	 * Original signature : <code>char* cvReadString(const CvFileNode*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1648</i>
	 */
	com.sun.jna.ptr.ByteByReference cvReadString(cxcore.CvFileNode node, java.lang.String default_value);
	/**
	 * Original signature : <code>char* cvReadStringByName(const CvFileStorage*, const CvFileNode*, const char*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1655</i><br>
	 * @deprecated use the safer method {@link #cvReadStringByName(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvFileNode, java.lang.String, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.ptr.ByteByReference cvReadStringByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, com.sun.jna.ptr.ByteByReference name, com.sun.jna.ptr.ByteByReference default_value);
	/**
	 * Original signature : <code>char* cvReadStringByName(const CvFileStorage*, const CvFileNode*, const char*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1655</i>
	 */
	com.sun.jna.ptr.ByteByReference cvReadStringByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, java.lang.String name, java.lang.String default_value);
	/**
	 * decodes standard or user-defined object and returns it<br>
	 * Original signature : <code>void* cvRead(CvFileStorage*, CvFileNode*, CvAttrList*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1663</i>
	 */
	com.sun.jna.Pointer cvRead(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode node, cxcore.CvAttrList attributes);
	/**
	 * decodes standard or user-defined object and returns it<br>
	 * Original signature : <code>void* cvReadByName(CvFileStorage*, const CvFileNode*, const char*, CvAttrList*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1667</i><br>
	 * @deprecated use the safer method {@link #cvReadByName(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvFileNode, java.lang.String, cxcore.CvAttrList)} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.Pointer cvReadByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, com.sun.jna.ptr.ByteByReference name, cxcore.CvAttrList attributes);
	/**
	 * decodes standard or user-defined object and returns it<br>
	 * Original signature : <code>void* cvReadByName(CvFileStorage*, const CvFileNode*, const char*, CvAttrList*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1667</i>
	 */
	com.sun.jna.Pointer cvReadByName(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode map, java.lang.String name, cxcore.CvAttrList attributes);
	/**
	 * starts reading data from sequence or scalar numeric node<br>
	 * Original signature : <code>void cvStartReadRawData(const CvFileStorage*, const CvFileNode*, CvSeqReader*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1675</i>
	 */
	void cvStartReadRawData(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode src, cxcore.CvSeqReader reader);
	/**
	 * reads multiple numbers and stores them to array<br>
	 * Original signature : <code>void cvReadRawDataSlice(const CvFileStorage*, CvSeqReader*, int, void*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1679</i><br>
	 * @deprecated use the safer method {@link #cvReadRawDataSlice(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvSeqReader, int, com.sun.jna.Pointer, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	void cvReadRawDataSlice(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvSeqReader reader, int count, com.sun.jna.Pointer dst, com.sun.jna.ptr.ByteByReference dt);
	/**
	 * reads multiple numbers and stores them to array<br>
	 * Original signature : <code>void cvReadRawDataSlice(const CvFileStorage*, CvSeqReader*, int, void*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1679</i>
	 */
	void cvReadRawDataSlice(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvSeqReader reader, int count, com.sun.jna.Pointer dst, java.lang.String dt);
	/**
	 * combination of two previous functions for easier reading of whole sequences<br>
	 * Original signature : <code>void cvReadRawData(const CvFileStorage*, const CvFileNode*, void*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1683</i><br>
	 * @deprecated use the safer method {@link #cvReadRawData(cxcore.CxcoreLibrary.CvFileStorage, cxcore.CvFileNode, com.sun.jna.Pointer, java.lang.String)} instead
	 */
	@java.lang.Deprecated
	void cvReadRawData(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode src, com.sun.jna.Pointer dst, com.sun.jna.ptr.ByteByReference dt);
	/**
	 * combination of two previous functions for easier reading of whole sequences<br>
	 * Original signature : <code>void cvReadRawData(const CvFileStorage*, const CvFileNode*, void*, const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1683</i>
	 */
	void cvReadRawData(cxcore.CxcoreLibrary.CvFileStorage fs, cxcore.CvFileNode src, com.sun.jna.Pointer dst, java.lang.String dt);
	/**
	 * writes a copy of file node to file storage<br>
	 * Original signature : <code>void cvWriteFileNode(CvFileStorage*, const char*, const CvFileNode*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1687</i><br>
	 * @deprecated use the safer method {@link #cvWriteFileNode(cxcore.CxcoreLibrary.CvFileStorage, java.lang.String, cxcore.CvFileNode, int)} instead
	 */
	@java.lang.Deprecated
	void cvWriteFileNode(cxcore.CxcoreLibrary.CvFileStorage fs, com.sun.jna.ptr.ByteByReference new_node_name, cxcore.CvFileNode node, int embed);
	/**
	 * writes a copy of file node to file storage<br>
	 * Original signature : <code>void cvWriteFileNode(CvFileStorage*, const char*, const CvFileNode*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1687</i>
	 */
	void cvWriteFileNode(cxcore.CxcoreLibrary.CvFileStorage fs, java.lang.String new_node_name, cxcore.CvFileNode node, int embed);
	/**
	 * returns name of file node<br>
	 * Original signature : <code>char* cvGetFileNodeName(const CvFileNode*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1691</i>
	 */
	com.sun.jna.ptr.ByteByReference cvGetFileNodeName(cxcore.CvFileNode node);
	/**
	 * Original signature : <code>void cvRegisterType(const CvTypeInfo*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1695</i>
	 */
	void cvRegisterType(cxcore.CvTypeInfo info);
	/**
	 * Original signature : <code>void cvUnregisterType(const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1696</i><br>
	 * @deprecated use the safer method {@link #cvUnregisterType(java.lang.String)} instead
	 */
	@java.lang.Deprecated
	void cvUnregisterType(com.sun.jna.ptr.ByteByReference type_name);
	/**
	 * Original signature : <code>void cvUnregisterType(const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1696</i>
	 */
	void cvUnregisterType(java.lang.String type_name);
	/**
	 * Original signature : <code>CvTypeInfo* cvFirstType()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1697</i>
	 */
	cxcore.CvTypeInfo cvFirstType();
	/**
	 * Original signature : <code>CvTypeInfo* cvFindType(const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1698</i><br>
	 * @deprecated use the safer method {@link #cvFindType(java.lang.String)} instead
	 */
	@java.lang.Deprecated
	cxcore.CvTypeInfo cvFindType(com.sun.jna.ptr.ByteByReference type_name);
	/**
	 * Original signature : <code>CvTypeInfo* cvFindType(const char*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1698</i>
	 */
	cxcore.CvTypeInfo cvFindType(java.lang.String type_name);
	/**
	 * Original signature : <code>CvTypeInfo* cvTypeOf(const void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1699</i>
	 */
	cxcore.CvTypeInfo cvTypeOf(com.sun.jna.Pointer struct_ptr);
	/**
	 * universal functions<br>
	 * Original signature : <code>void cvRelease(void**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1702</i>
	 */
	void cvRelease(com.sun.jna.ptr.PointerByReference struct_ptr);
	/**
	 * Original signature : <code>void* cvClone(const void*)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1703</i>
	 */
	com.sun.jna.Pointer cvClone(com.sun.jna.Pointer struct_ptr);
	/**
	 * simple API for reading/writing data<br>
	 * Original signature : <code>void cvSave(const char*, const void*, const char*, const char*, CvAttrList)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1706</i><br>
	 * @deprecated use the safer method {@link #cvSave(java.lang.String, com.sun.jna.Pointer, java.lang.String, java.lang.String, cxcore.CvAttrList.ByValue)} instead
	 */
	@java.lang.Deprecated
	void cvSave(com.sun.jna.ptr.ByteByReference filename, com.sun.jna.Pointer struct_ptr, com.sun.jna.ptr.ByteByReference name, com.sun.jna.ptr.ByteByReference comment, cxcore.CvAttrList.ByValue attributes);
	/**
	 * simple API for reading/writing data<br>
	 * Original signature : <code>void cvSave(const char*, const void*, const char*, const char*, CvAttrList)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1706</i>
	 */
	void cvSave(java.lang.String filename, com.sun.jna.Pointer struct_ptr, java.lang.String name, java.lang.String comment, cxcore.CvAttrList.ByValue attributes);
	/**
	 * Original signature : <code>void* cvLoad(const char*, CvMemStorage*, const char*, const char**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1710</i><br>
	 * @deprecated use the safer method {@link #cvLoad(java.lang.String, cxcore.CvMemStorage, java.lang.String, java.lang.String[])} instead
	 */
	@java.lang.Deprecated
	com.sun.jna.Pointer cvLoad(com.sun.jna.ptr.ByteByReference filename, cxcore.CvMemStorage memstorage, com.sun.jna.ptr.ByteByReference name, com.sun.jna.ptr.PointerByReference real_name);
	/**
	 * Original signature : <code>void* cvLoad(const char*, CvMemStorage*, const char*, const char**)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1710</i>
	 */
	com.sun.jna.Pointer cvLoad(java.lang.String filename, cxcore.CvMemStorage memstorage, java.lang.String name, java.lang.String real_name[]);
	/**
	 * helper functions for RNG initialization and accurate time measurement:<br>
	 * uses internal clock counter on x86<br>
	 * Original signature : <code>int64 cvGetTickCount()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1719</i>
	 */
	long cvGetTickCount();
	/**
	 * Original signature : <code>double cvGetTickFrequency()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1720</i>
	 */
	double cvGetTickFrequency();
	/**
	 * retrieve/set the number of threads used in OpenMP implementations<br>
	 * Original signature : <code>int cvGetNumThreads()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1725</i>
	 */
	int cvGetNumThreads();
	/**
	 * Original signature : <code>void cvSetNumThreads(int)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1726</i>
	 */
	void cvSetNumThreads(int threads);
	/**
	 * get index of the thread being executed<br>
	 * Original signature : <code>int cvGetThreadNum()</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1728</i>
	 */
	int cvGetThreadNum();
	/**
	 * Original signature : <code>int cvSetImageIOFunctions(CvLoadImageFunc, CvLoadImageMFunc, CvSaveImageFunc, CvShowImageFunc)</code><br>
	 * <i>native declaration : cxcore\include\cxcore.h:1737</i>
	 */
	int cvSetImageIOFunctions(cxcore.CxcoreLibrary.CvLoadImageFunc _load_image, cxcore.CxcoreLibrary.CvLoadImageMFunc _load_image_m, cxcore.CxcoreLibrary.CvSaveImageFunc _save_image, cxcore.CxcoreLibrary.CvShowImageFunc _show_image);
	/**
	 * Original signature : <code>void* cvAlignPtr(const void*, int)</code><br>
	 * <i>native declaration : cxcore\include\cxmisc.h:225</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z10cvAlignPtrPKvi", "?cvAlignPtr@@YAPAXPAXH@Z"})
	com.sun.jna.Pointer cvAlignPtr(com.sun.jna.Pointer ptr, int align);
	/**
	 * Original signature : <code>int cvAlign(int, int)</code><br>
	 * <i>native declaration : cxcore\include\cxmisc.h:231</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z7cvAlignii", "?cvAlign@@YAHHH@Z"})
	int cvAlign(int size, int align);
	/**
	 * Original signature : <code>~WImage()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:84</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv7~WImagev", "?~WImage@cv@@YAXXZ"})
	int cv_WImageDestructor();
	/**
	 * Original signature : <code>IplImage* Ipl()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:87</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv3Iplv", "?Ipl@cv@@YAPAU_IplImage@@XZ"})
	cxcore.IplImage cv_Ipl();
	/**
	 * Original signature : <code>T* ImageData()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:89</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv9ImageDatav", "?ImageData@cv@@YAPA1TXZ"})
	cxcore.CxcoreLibrary.T cv_ImageData();
	/**
	 * Original signature : <code>int Width()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:94</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv5Widthv", "?Width@cv@@YAHXZ"})
	int cv_Width();
	/**
	 * Original signature : <code>int Height()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:95</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv6Heightv", "?Height@cv@@YAHXZ"})
	int cv_Height();
	/**
	 * Original signature : <code>int WidthStep()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:98</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv9WidthStepv", "?WidthStep@cv@@YAHXZ"})
	int cv_WidthStep();
	/**
	 * Original signature : <code>int Channels()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:100</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv8Channelsv", "?Channels@cv@@YAHXZ"})
	int cv_Channels();
	/**
	 * Original signature : <code>int ChannelSize()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:101</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv11ChannelSizev", "?ChannelSize@cv@@YAHXZ"})
	int cv_ChannelSize();
	/**
	 * Original signature : <code>int PixelSize()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:104</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv9PixelSizev", "?PixelSize@cv@@YAHXZ"})
	int cv_PixelSize();
	/**
	 * Original signature : <code>int Depth()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:109</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv5Depthv", "?Depth@cv@@YAHXZ"})
	int cv_Depth();
	/**
	 * Original signature : <code>T* Row(int)</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:111</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_ZN2cv3Rowi", "?Row@cv@@YAPA1TH@Z"})
	cxcore.CxcoreLibrary.T cv_Row(int r);
	/**
	 * Original signature : <code>c* Channels()</code><br>
	 * <i>native declaration : cxcore\include\cvwimage.h:127</i>
	 */
	@com.ochafik.lang.jnaerator.runtime.Mangling({"_Z8Channelsv", "?Channels@@YAPA1cXZ"})
	cxcore.CxcoreLibrary.c Channels();
	/// Pointer to unknown (opaque) type
	public static class T extends com.sun.jna.PointerType {
		public T(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public T() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class c extends com.sun.jna.PointerType {
		public c(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public c() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvFileStorage extends com.sun.jna.PointerType {
		public CvFileStorage(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvFileStorage() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class CvGenericHash extends com.sun.jna.PointerType {
		public CvGenericHash(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public CvGenericHash() {
			super();
		}
	}
	/// Pointer to unknown (opaque) type
	public static class _IplTileInfo extends com.sun.jna.PointerType {
		public _IplTileInfo(com.sun.jna.Pointer pointer) {
			super(pointer);
		}
		public _IplTileInfo() {
			super();
		}
	}
}
