/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package ru.nickl.meanShift.direct.port.moveport;

import ru.nickl.meanShift.direct.port.moveport.PortedFilterWithConnector;

/**
 *
 * @author nickl
 */
public class PortedSegmentator extends PortedFilterWithConnector {

    private final int NODE_MULTIPLE = 10;
    private int[] visitTable;
    private float rR2;
    private RAList raList[];
    //////////RAMatrix Free List///////////
    private RAList freeRAList;			// a pointer to the head of a region adjacency list object
    // free list
    private RAList raPool[];				// a pool of RAList objects used in the construction of the
    private int minRegion;
    float epsilon = 1.0f;
    int kp = 2;
    int P[] = new int[]{2,3};
    float offset[] = new float[kp];

    public PortedSegmentator(int minRegion) {
        this.minRegion = minRegion;
    }


    



    protected void doFilter() {



        //Apply mean shift to data set using sigmaS and sigmaR...
        super.doFilter();





        //allocate memory visit table
        visitTable = new int[L];

        //Apply transitive closure iteratively to the regions classified
        //by the RAM updating labels and modes until the color of each neighboring
        //region is within sqrt(rR2) of one another.
        rR2 = (float) (h[1] * h[1] * 0.25);
        TransitiveClosure();
        int oldRC = regionCount;
        int deltaRC, counter = 0;
        do {
            TransitiveClosure();
            deltaRC = oldRC - regionCount;
            oldRC = regionCount;
            counter++;
        } while ((deltaRC <= 0) && (counter < 10));

        //de-allocate memory for visit table
        //delete [] visitTable;
        visitTable = null;






        //Prune spurious regions (regions whose area is under
        //minRegion) using RAM
        Prune(minRegion);







        //output to msRawData
        int j, i, label;
        for (i = 0; i < L; i++) {
            label = labels[i];
            for (j = 0; j < N; j++) {
                msRawData[N * i + j] = modes[N * label + j];
            }
        }

        //done.
        return;

    }

    void Prune(int minRegion) {

        //Allocate Memory for temporary buffers...

        //allocate memory for mode and point count temporary buffers...
        float modes_buffer[] = new float[N * regionCount];
        int MPC_buffer[] = new int[regionCount];

        //allocate memory for label buffer
        int label_buffer[] = new int[regionCount];

        //Declare variables
        int i, k, candidate, iCanEl, neighCanEl, iMPC, label, oldRegionCount, minRegionCount;
        double minSqDistance, neighborDistance;
        RAList neighbor;

        //Apply pruning algorithm to classification structure, removing all regions whose area
        //is under the threshold area minRegion (pixels)
        do {
            //Assume that no region has area under threshold area  of
            minRegionCount = 0;

            //Step (1):

            // Build RAM using classifiction structure originally
            // generated by the method GridTable::Connect()
            BuildRAM();

            // Step (2):

            // Traverse the RAM joining regions whose area is less than minRegion (pixels)
            // with its respective candidate region.

            // A candidate region is a region that displays the following properties:

            //	- it is adjacent to the region being pruned

            //  - the distance of its mode is a minimum to that of the region being pruned
            //    such that or it is the only adjacent region having an area greater than
            //    minRegion

            for (i = 0; i < regionCount; i++) {
                //if the area of the ith region is less than minRegion
                //join it with its candidate region...

                //*******************************************************************************

                //Note: Adjust this if statement if a more sophisticated pruning criterion
                //      is desired. Basically in this step a region whose area is less than
                //      minRegion is pruned by joining it with its "closest" neighbor (in color).
                //      Therefore, by placing a different criterion for fusing a region the
                //      pruning method may be altered to implement a more sophisticated algorithm.

                //*******************************************************************************

                if (modePointCounts[i] < minRegion) {
                    //update minRegionCount to indicate that a region
                    //having area less than minRegion was found
                    minRegionCount++;

                    //obtain a pointer to the first region in the
                    //region adjacency list of the ith region...
                    neighbor = raList[i].next;

                    //calculate the distance between the mode of the ith
                    //region and that of the neighboring region...
                    candidate = neighbor.label;
                    minSqDistance = SqDistance(i, candidate);

                    //traverse region adjacency list of region i and select
                    //a candidate region
                    neighbor = neighbor.next;
                    while (neighbor != null) {

                        //calculate the square distance between region i
                        //and current neighbor...
                        neighborDistance = SqDistance(i, neighbor.label);

                        //if this neighbors square distance to region i is less
                        //than minSqDistance, then select this neighbor as the
                        //candidate region for region i
                        if (neighborDistance < minSqDistance) {
                            minSqDistance = neighborDistance;
                            candidate = neighbor.label;
                        }

                        //traverse region list of region i
                        neighbor = neighbor.next;

                    }

                    //join region i with its candidate region:

                    // (1) find the canonical element of region i
                    iCanEl = i;
                    while (raList[iCanEl].label != iCanEl) {
                        iCanEl = raList[iCanEl].label;
                    }

                    // (2) find the canonical element of neighboring region
                    neighCanEl = candidate;
                    while (raList[neighCanEl].label != neighCanEl) {
                        neighCanEl = raList[neighCanEl].label;
                    }

                    // if the canonical elements of are not the same then assign
                    // the canonical element having the smaller label to be the parent
                    // of the other region...
                    if (iCanEl < neighCanEl) {
                        raList[neighCanEl].label = iCanEl;
                    } else {
                        //must replace the canonical element of previous
                        //parent as well
                        raList[raList[iCanEl].label].label = neighCanEl;

                        //re-assign canonical element
                        raList[iCanEl].label = neighCanEl;
                    }
                }
            }

            // Step (3):

            // Level binary trees formed by canonical elements
            for (i = 0; i < regionCount; i++) {
                iCanEl = i;
                while (raList[iCanEl].label != iCanEl) {
                    iCanEl = raList[iCanEl].label;
                }
                raList[i].label = iCanEl;
            }

            // Step (4):

            //Traverse joint sets, relabeling image.

            // Accumulate modes and re-compute point counts using canonical
            // elements generated by step 2.

            //initialize buffers to zero
            for (i = 0; i < regionCount; i++) {
                MPC_buffer[i] = 0;
            }
            for (i = 0; i < N * regionCount; i++) {
                modes_buffer[i] = 0;
            }

            //traverse raList accumulating modes and point counts
            //using canoncial element information...
            for (i = 0; i < regionCount; i++) {

                //obtain canonical element of region i
                iCanEl = raList[i].label;

                //obtain mode point count of region i
                iMPC = modePointCounts[i];

                //accumulate modes_buffer[iCanEl]
                for (k = 0; k < N; k++) {
                    modes_buffer[(N * iCanEl) + k] += iMPC * modes[(N * i) + k];
                }

                //accumulate MPC_buffer[iCanEl]
                MPC_buffer[iCanEl] += iMPC;

            }

            // (b)

            // Re-label new regions of the image using the canonical
            // element information generated by step (2)

            // Also use this information to compute the modes of the newly
            // defined regions, and to assign new region point counts in
            // a consecute manner to the modePointCounts array

            //initialize label buffer to -1
            for (i = 0; i < regionCount; i++) {
                label_buffer[i] = -1;
            }

            //traverse raList re-labeling the regions
            label = -1;
            for (i = 0; i < regionCount; i++) {
                //obtain canonical element of region i
                iCanEl = raList[i].label;
                if (label_buffer[iCanEl] < 0) {
                    //assign a label to the new region indicated by canonical
                    //element of i
                    label_buffer[iCanEl] = ++label;

                    //recompute mode storing the result in modes[label]...
                    iMPC = MPC_buffer[iCanEl];
                    for (k = 0; k < N; k++) {
                        modes[(N * label) + k] = (modes_buffer[(N * iCanEl) + k]) / (iMPC);
                    }

                    //assign a corresponding mode point count for this region into
                    //the mode point counts array using the MPC buffer...
                    modePointCounts[label] = MPC_buffer[iCanEl];
                }
            }

            //re-assign region count using label counter
            oldRegionCount = regionCount;
            regionCount = label + 1;

            // (c)

            // Use the label buffer to refinalruct the label map, which specified
            // the new image given its new regions calculated above

            for (i = 0; i < height * width; i++) {
                labels[i] = label_buffer[raList[labels[i]].label];
            }


        } while (minRegionCount > 0);

        //de-allocate memory
//	//delete [] modes_buffer;
//	//delete [] MPC_buffer;
//	//delete [] label_buffer;

        //done.
        return;

    }

    /**
     *Transitive Closure
     ******************************************************
     *Applies transitive closure to the RAM updating
     *labels, modes and modePointCounts to reflect the new
     *set of merged regions resulting from transitive clo-
     *sure.
     ******************************************************
     *Post:
     *      - transitive closure has been applied to the
     *        regions classified by the RAM and labels,
     *        modes and modePointCounts have been updated
     *        to reflect the new set of mergd regions res-
     *        ulting from transitive closure.
     */
    void TransitiveClosure() {

        //Step (1):

        // Build RAM using classifiction structure originally
        // generated by the method GridTable::Connect()
        BuildRAM();



        //Step (2):

        //Treat each region Ri as a disjoint set:

        // - attempt to join Ri and Rj for all i != j that are neighbors and
        //   whose associated modes are a normalized distance of < 0.5 from one
        //   another

        // - the label of each region in the raList is treated as a pointer to the
        //   canonical element of that region (e.g. raList[i], initially has raList[i].label = i,
        //   namely each region is initialized to have itself as its canonical element).

        //Traverse RAM attempting to join raList[i] with its neighbors...
        int i, iCanEl, neighCanEl;
        float threshold;
        RAList neighbor;
        for (i = 0; i < regionCount; i++) {
            //aquire first neighbor in region adjacency list pointed to
            //by raList[i]
            neighbor = raList[i].next;

            //compute edge strenght threshold using global and local
            //epsilon
            if (epsilon > raList[i].edgeStrength) {
                threshold = epsilon;
            } else {
                threshold = raList[i].edgeStrength;
            }

            //traverse region adjacency list of region i, attempting to join
            //it with regions whose mode is a normalized distance < 0.5 from
            //that of region i...
            while (neighbor != null) {
                //attempt to join region and neighbor...
                if ((InWindow(i, neighbor.label)) && (neighbor.edgeStrength < epsilon)) {
                    //region i and neighbor belong together so join them
                    //by:

                    // (1) find the canonical element of region i
                    iCanEl = i;
                    while (raList[iCanEl].label != iCanEl) {
                        iCanEl = raList[iCanEl].label;
                    }

                    // (2) find the canonical element of neighboring region
                    neighCanEl = neighbor.label;
                    while (raList[neighCanEl].label != neighCanEl) {
                        neighCanEl = raList[neighCanEl].label;
                    }

                    // if the canonical elements of are not the same then assign
                    // the canonical element having the smaller label to be the parent
                    // of the other region...
                    if (iCanEl < neighCanEl) {
                        raList[neighCanEl].label = iCanEl;
                    } else {
                        //must replace the canonical element of previous
                        //parent as well
                        raList[raList[iCanEl].label].label = neighCanEl;

                        //re-assign canonical element
                        raList[iCanEl].label = neighCanEl;
                    }
                }

                //check the next neighbor...
                neighbor = neighbor.next;

            }
        }

        // Step (3):

        // Level binary trees formed by canonical elements
        for (i = 0; i < regionCount; i++) {
            iCanEl = i;
            while (raList[iCanEl].label != iCanEl) {
                iCanEl = raList[iCanEl].label;
            }
            raList[i].label = iCanEl;
        }

        // Step (4):

        //Traverse joint sets, relabeling image.

        // (a)

        // Accumulate modes and re-compute point counts using canonical
        // elements generated by step 2.

        //allocate memory for mode and point count temporary buffers...
        float modes_buffer[] = new float[N * regionCount];
        int MPC_buffer[] = new int[regionCount];

        //initialize buffers to zero
        for (i = 0; i < regionCount; i++) {
            MPC_buffer[i] = 0;
        }
        for (i = 0; i < N * regionCount; i++) {
            modes_buffer[i] = 0;
        }

        //traverse raList accumulating modes and point counts
        //using canoncial element information...
        int k, iMPC;
        for (i = 0; i < regionCount; i++) {

            //obtain canonical element of region i
            iCanEl = raList[i].label;

            //obtain mode point count of region i
            iMPC = modePointCounts[i];

            //accumulate modes_buffer[iCanEl]
            for (k = 0; k < N; k++) {
                modes_buffer[(N * iCanEl) + k] += iMPC * modes[(N * i) + k];
            }

            //accumulate MPC_buffer[iCanEl]
            MPC_buffer[iCanEl] += iMPC;

        }

        // (b)

        // Re-label new regions of the image using the canonical
        // element information generated by step (2)

        // Also use this information to compute the modes of the newly
        // defined regions, and to assign new region point counts in
        // a consecute manner to the modePointCounts array

        //allocate memory for label buffer
        int label_buffer[] = new int[regionCount];

        //initialize label buffer to -1
        for (i = 0; i < regionCount; i++) {
            label_buffer[i] = -1;
        }

        //traverse raList re-labeling the regions
        int label = -1;
        for (i = 0; i < regionCount; i++) {
            //obtain canonical element of region i
            iCanEl = raList[i].label;
            if (label_buffer[iCanEl] < 0) {
                //assign a label to the new region indicated by canonical
                //element of i
                label_buffer[iCanEl] = ++label;

                //recompute mode storing the result in modes[label]...
                iMPC = MPC_buffer[iCanEl];
                for (k = 0; k < N; k++) {
                    modes[(N * label) + k] = (modes_buffer[(N * iCanEl) + k]) / (iMPC);
                }

                //assign a corresponding mode point count for this region into
                //the mode point counts array using the MPC buffer...
                modePointCounts[label] = MPC_buffer[iCanEl];
            }
        }

        //re-assign region count using label counter
        int oldRegionCount = regionCount;
        regionCount = label + 1;

        // (c)

        // Use the label buffer to refinalruct the label map, which specified
        // the new image given its new regions calculated above

        for (i = 0; i < height * width; i++) {
            labels[i] = label_buffer[raList[labels[i]].label];
        }

        //de-allocate memory
        ////delete [] modes_buffer;
        ////delete [] MPC_buffer;
        ////delete [] label_buffer;

        //done.
        return;

    }

    void BuildRAM() {

        //Allocate memory for region adjacency matrix if it hasn't already been allocated
        raList = new RAList[regionCount];

        for (int ii = 0; ii < raList.length; ii++) {
            raList[ii] = new RAList();
        }

        raPool = new RAList[NODE_MULTIPLE * regionCount];

        for (int ii = 0; ii < raPool.length; ii++) {
            raPool[ii] = new RAList();

        }


        //initialize the region adjacency list
        int i;
        for (i = 0; i < regionCount; i++) {
            raList[i].edgeStrength = 0;
            raList[i].edgePixelCount = 0;
            raList[i].label = i;
            raList[i].next = null;
        }

        //initialize RAM free list
        freeRAList = raPool[0];
        for (i = 0; i < NODE_MULTIPLE * regionCount - 1; i++) {
            raPool[i].edgeStrength = 0;
            raPool[i].edgePixelCount = 0;
            raPool[i].next = raPool[i + 1];
        }
        raPool[NODE_MULTIPLE * regionCount - 1].next = null;

        //traverse the labeled image building
        //the RAM by looking to the right of
        //and below the current pixel location thus
        //determining if a given region is adjacent
        //to another
        int j, curLabel, rightLabel, bottomLabel, exists;
        RAList raNode1, raNode2, oldRAFreeList;
        for (i = 0; i < height - 1; i++) {
            //check the right and below neighbors
            //for pixel locations whose x < width - 1
            for (j = 0; j < width - 1; j++) {
                //calculate pixel labels
                curLabel = labels[i * width + j];	//current pixel
                rightLabel = labels[i * width + j + 1];	//right   pixel
                bottomLabel = labels[(i + 1) * width + j];	//bottom  pixel

                //check to the right, if the label of
                //the right pixel is not the same as that
                //of the current one then region[j] and region[j+1]
                //are adjacent to one another - update the RAM
                if (curLabel != rightLabel) {
                    //obtain RAList object from region adjacency free
                    //list
                    raNode1 = freeRAList;
                    raNode2 = freeRAList.next;

                    //keep a pointer to the old region adj. free
                    //list just in case nodes already exist in respective
                    //region lists
                    oldRAFreeList = freeRAList;

                    //update region adjacency free list
                    freeRAList = freeRAList.next.next;

                    //populate RAList nodes
                    raNode1.label = curLabel;
                    raNode2.label = rightLabel;

                    //insert nodes into the RAM
                    exists = 0;
                    raList[curLabel].Insert(raNode2);
                    exists = raList[rightLabel].Insert(raNode1);

                    //if the node already exists then place
                    //nodes back onto the region adjacency
                    //free list
                    if (exists != 0) {
                        freeRAList = oldRAFreeList;
                    }

                }

                //check below, if the label of
                //the bottom pixel is not the same as that
                //of the current one then region[j] and region[j+width]
                //are adjacent to one another - update the RAM
                if (curLabel != bottomLabel) {
                    //obtain RAList object from region adjacency free
                    //list
                    raNode1 = freeRAList;
                    raNode2 = freeRAList.next;

                    //keep a pointer to the old region adj. free
                    //list just in case nodes already exist in respective
                    //region lists
                    oldRAFreeList = freeRAList;

                    //update region adjacency free list
                    freeRAList = freeRAList.next.next;

                    //populate RAList nodes
                    raNode1.label = curLabel;
                    raNode2.label = bottomLabel;

                    //insert nodes into the RAM
                    exists = 0;
                    raList[curLabel].Insert(raNode2);
                    exists = raList[bottomLabel].Insert(raNode1);

                    //if the node already exists then place
                    //nodes back onto the region adjacency
                    //free list
                    if (exists != 0) {
                        freeRAList = oldRAFreeList;
                    }

                }

            }

            //check only to the bottom neighbors of the right boundary
            //pixels...

            //calculate pixel locations (j = width-1)
            curLabel = labels[i * width + j];	//current pixel
            bottomLabel = labels[(i + 1) * width + j];	//bottom  pixel

            //check below, if the label of
            //the bottom pixel is not the same as that
            //of the current one then region[j] and region[j+width]
            //are adjacent to one another - update the RAM
            if (curLabel != bottomLabel) {
                //obtain RAList object from region adjacency free
                //list
                raNode1 = freeRAList;
                raNode2 = freeRAList.next;

                //keep a pointer to the old region adj. free
                //list just in case nodes already exist in respective
                //region lists
                oldRAFreeList = freeRAList;

                //update region adjacency free list
                freeRAList = freeRAList.next.next;

                //populate RAList nodes
                raNode1.label = curLabel;
                raNode2.label = bottomLabel;

                //insert nodes into the RAM
                exists = 0;
                raList[curLabel].Insert(raNode2);
                exists = raList[bottomLabel].Insert(raNode1);

                //if the node already exists then place
                //nodes back onto the region adjacency
                //free list
                if (exists != 0) {
                    freeRAList = oldRAFreeList;
                }

            }
        }

        //check only to the right neighbors of the bottom boundary
        //pixels...

        //check the right for pixel locations whose x < width - 1
        for (j = 0; j < width - 1; j++) {
            //calculate pixel labels (i = height-1)
            curLabel = labels[i * width + j];	//current pixel
            rightLabel = labels[i * width + j + 1];	//right   pixel

            //check to the right, if the label of
            //the right pixel is not the same as that
            //of the current one then region[j] and region[j+1]
            //are adjacent to one another - update the RAM
            if (curLabel != rightLabel) {
                //obtain RAList object from region adjacency free
                //list
                raNode1 = freeRAList;
                raNode2 = freeRAList.next;

                //keep a pointer to the old region adj. free
                //list just in case nodes already exist in respective
                //region lists
                oldRAFreeList = freeRAList;

                //update region adjacency free list
                freeRAList = freeRAList.next.next;

                //populate RAList nodes
                raNode1.label = curLabel;
                raNode2.label = rightLabel;

                //insert nodes into the RAM
                exists = 0;
                raList[curLabel].Insert(raNode2);
                exists = raList[rightLabel].Insert(raNode1);

                //if the node already exists then place
                //nodes back onto the region adjacency
                //free list
                if (exists != 0) {
                    freeRAList = oldRAFreeList;
                }

            }

        }

        //done.
        return;

    }

    /**
     *In Window
     ******************************************************
     *Returns true if the two specified data points are
     *within rR of each other.
     ******************************************************
     *Pre:
     *      - mode1 and mode2 are indeces into msRawData
     *        specifying the modes of the pixels having
     *        these indeces.
     *Post:
     *      - true is returned if mode1 and mode2 are wi-
     *        thin rR of one another, false is returned
     *        otherwise.
     */
    boolean InWindow(int mode1, int mode2) {
        int k = 1, s = 0, p;
        double diff = 0, el;
        while ((diff < 0.25) && (k != kp)) // Partial Distortion Search
        {
            //Calculate distance squared of sub-space s
            diff = 0;
            for (p = 0; p < P[k]; p++) {
                el = (modes[mode1 * N + p + s] - modes[mode2 * N + p + s]) / (h[k] * offset[k]);
                if ((0 == p) && (k == 1) && (modes[mode1 * N] > 80)) {
                    diff += 4 * el * el;
                } else {
                    diff += el * el;
                }
            }

            //next subspace
            s += P[k];
            k++;
        }
        return (diff < 0.25);
    }

    /**
     *Square Distance
     ******************************************************
     *Computs the normalized square distance between two
     *modes.
     ******************************************************
     *Pre:
     *      - mode1 and mode2 are indeces into the modes
     *        array specifying two modes of the image
     *Post:
     *      - the normalized square distance between modes
     *        indexed by mode1 and mode2 has been calc-
     *        ulated and the result has been returned.
     */
    float SqDistance(int mode1, int mode2) {

        int k = 1, s = 0, p;
        float dist = 0, el;
        for (k = 1; k < kp; k++) {
            //Calculate distance squared of sub-space s
            for (p = 0; p < P[k]; p++) {
                el = (float) ((modes[mode1 * N + p + s] - modes[mode2 * N + p + s]) / (h[k] * offset[k]));
                dist += el * el;
            }

            //next subspace
            s += P[k];
            k++;
        }

        //return normalized square distance between modes
        //1 and 2
        return dist;

    }
}
